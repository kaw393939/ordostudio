===== FILE: src/app/__tests__/e2e-account-registrations.test.ts =====
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { GET as getAccountRegistrations } from "../api/v1/account/registrations/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import { POST as postLogin } from "../api/v1/auth/login/route";
import { DELETE as deleteRegistration } from "../api/v1/events/[slug]/registrations/[userId]/route";
import { POST as postCheckin } from "../api/v1/events/[slug]/checkins/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

describe("e2e account registrations history", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("returns only registrations for the authenticated user", async () => {
    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "userb@example.com",
          password: "Password123!",
        }),
      }),
    );

    const login = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "userb@example.com",
          password: "Password123!",
        }),
      }),
    );

    const userBCookie = (login.headers.get("set-cookie") ?? "").split(";")[0];

    const userBRegistrations = await getAccountRegistrations(
      new Request("http://localhost:3000/api/v1/account/registrations", {
        headers: { cookie: userBCookie },
      }),
    );

    expect(userBRegistrations.status).toBe(200);
    const userBBody = await userBRegistrations.json();
    expect(userBBody.count).toBe(0);
    expect(userBBody.items).toEqual([]);

    const userARegistrations = await getAccountRegistrations(
      new Request("http://localhost:3000/api/v1/account/registrations", {
        headers: { cookie: fixture.userCookie },
      }),
    );

    expect(userARegistrations.status).toBe(200);
    const userABody = await userARegistrations.json();
    expect(userABody.count).toBeGreaterThan(0);
    expect(userABody.items.every((item: { event_slug: string }) => item.event_slug !== "non-existent")).toBe(true);
  });

  it("reflects lifecycle status updates in account history", async () => {
    const cancel = await deleteRegistration(
      new Request(`http://localhost:3000/api/v1/events/published-open/registrations/${fixture.userId}`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.userCookie,
        },
      }),
      { params: Promise.resolve({ slug: "published-open", userId: fixture.userId }) },
    );
    expect(cancel.status).toBe(200);

    const checkin = await postCheckin(
      new Request("http://localhost:3000/api/v1/events/published-full/checkins", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ user_id: fixture.userId }),
      }),
      { params: Promise.resolve({ slug: "published-full" }) },
    );
    expect(checkin.status).toBe(200);

    const response = await getAccountRegistrations(
      new Request("http://localhost:3000/api/v1/account/registrations", {
        headers: { cookie: fixture.userCookie },
      }),
    );

    expect(response.status).toBe(200);
    const body = await response.json();

    const openRegistration = body.items.find(
      (item: { event_slug: string; status: string }) => item.event_slug === "published-open",
    );
    const fullRegistration = body.items.find(
      (item: { event_slug: string; status: string }) => item.event_slug === "published-full",
    );

    expect(openRegistration?.status).toBe("CANCELLED");
    expect(fullRegistration?.status).toBe("CHECKED_IN");
  });

  it("returns unauthorized without an active session", async () => {
    const response = await getAccountRegistrations(
      new Request("http://localhost:3000/api/v1/account/registrations"),
    );

    expect(response.status).toBe(401);
    const body = await response.json();
    expect(body.type).toBe("https://lms-219.dev/problems/unauthorized");
  });
});


===== FILE: src/app/__tests__/e2e-admin-invitations.test.ts =====
import Database from "better-sqlite3";
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { POST as postInvite } from "../api/v1/admin/invitations/route";
import { POST as postAcceptInvite } from "../api/v1/admin/invitations/accept/route";
import { POST as postLogin } from "../api/v1/auth/login/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import { GET as getMe } from "../api/v1/me/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

const findInviteIdByEmail = (dbPath: string, email: string) => {
  const db = new Database(dbPath);
  const row = db.prepare("SELECT id FROM api_admin_invitations WHERE email = ? ORDER BY created_at DESC LIMIT 1").get(email) as { id: string };
  db.close();
  return row.id;
};

describe("e2e admin invitations", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("allows admin to invite and invited user to accept as ADMIN", async () => {
    const invite = await postInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ email: "invitee@example.com" }),
      }),
    );

    expect(invite.status).toBe(201);
    const inviteBody = await invite.json();
    expect(inviteBody.role).toBe("ADMIN");
    expect(inviteBody.invitation_token).toBeTruthy();

    const accept = await postAcceptInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations/accept", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          token: inviteBody.invitation_token,
          password: "Password123!",
        }),
      }),
    );

    expect(accept.status).toBe(200);

    const login = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "invitee@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(login.status).toBe(200);
    const cookie = (login.headers.get("set-cookie") ?? "").split(";")[0];

    const me = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        headers: {
          cookie,
        },
      }),
    );
    expect(me.status).toBe(200);

    const meBody = await me.json();
    expect(meBody.roles).toContain("ADMIN");
    expect(meBody.roles).not.toContain("SUPER_ADMIN");
  });

  it("blocks invitation reuse and expired invitations", async () => {
    const invite = await postInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ email: "reuse-invitee@example.com" }),
      }),
    );

    const inviteBody = await invite.json();

    const firstAccept = await postAcceptInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations/accept", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          token: inviteBody.invitation_token,
          password: "Password123!",
        }),
      }),
    );
    expect(firstAccept.status).toBe(200);

    const reuse = await postAcceptInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations/accept", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          token: inviteBody.invitation_token,
          password: "Password123!",
        }),
      }),
    );
    expect(reuse.status).toBe(409);

    const invite2 = await postInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ email: "expired-invitee@example.com" }),
      }),
    );

    const inviteBody2 = await invite2.json();
    const inviteId = findInviteIdByEmail(fixture.dbPath, "expired-invitee@example.com");
    const db = new Database(fixture.dbPath);
    db.prepare("UPDATE api_admin_invitations SET expires_at = ? WHERE id = ?").run("2000-01-01T00:00:00.000Z", inviteId);
    db.close();

    const expiredAccept = await postAcceptInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations/accept", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          token: inviteBody2.invitation_token,
          password: "Password123!",
        }),
      }),
    );

    expect(expiredAccept.status).toBe(412);
  });

  it("rejects invites for existing accounts and unauthorized invite attempts", async () => {
    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "existing@example.com",
          password: "Password123!",
        }),
      }),
    );

    const existingConflict = await postInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ email: "existing@example.com" }),
      }),
    );
    expect(existingConflict.status).toBe(409);

    const asUser = await postInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.userCookie,
        },
        body: JSON.stringify({ email: "forbidden@example.com" }),
      }),
    );
    expect(asUser.status).toBe(403);

    const asAnon = await postInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ email: "anon@example.com" }),
      }),
    );
    expect(asAnon.status).toBe(401);
  });
});


===== FILE: src/app/__tests__/e2e-admin-operations-security.test.ts =====
import { randomUUID } from "node:crypto";
import Database from "better-sqlite3";
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { POST as postLogin } from "../api/v1/auth/login/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import { POST as postEvents, GET as getEvents } from "../api/v1/events/route";
import { POST as postPublish } from "../api/v1/events/[slug]/publish/route";
import { POST as postCancel } from "../api/v1/events/[slug]/cancel/route";
import { POST as postRegistration } from "../api/v1/events/[slug]/registrations/route";
import { DELETE as deleteRegistration } from "../api/v1/events/[slug]/registrations/[userId]/route";
import { POST as postCheckin } from "../api/v1/events/[slug]/checkins/route";
import { GET as getExport } from "../api/v1/events/[slug]/export/route";
import { GET as getUsers } from "../api/v1/users/route";
import { PATCH as patchUser } from "../api/v1/users/[id]/route";
import { POST as postRole } from "../api/v1/users/[id]/roles/route";
import { DELETE as deleteRole } from "../api/v1/users/[id]/roles/[role]/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

const userIdByEmail = (dbPath: string, email: string) => {
  const db = new Database(dbPath);
  const row = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  db.close();
  return row.id;
};

describe("e2e admin operations security", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("enforces admin access boundaries for admin endpoints", async () => {
    const usersAsUser = await getUsers(
      new Request("http://localhost:3000/api/v1/users", {
        headers: {
          cookie: fixture.userCookie,
        },
      }),
    );
    expect(usersAsUser.status).toBe(403);

    const createAsUser = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.userCookie,
        },
        body: JSON.stringify({
          slug: "forbidden-user-create",
          title: "Forbidden",
          start: "2026-11-01T10:00:00.000Z",
          end: "2026-11-01T11:00:00.000Z",
          timezone: "UTC",
        }),
      }),
    );

    expect(createAsUser.status).toBe(403);
  });

  it("supports admin event create/publish/cancel and validation/conflict checks", async () => {
    const invalidCreate = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({
          slug: "",
          title: "",
          start: "bad",
          end: "bad",
          timezone: "UTC",
        }),
      }),
    );
    expect(invalidCreate.status).toBe(400);

    const create = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({
          slug: "admin-security-event",
          title: "Admin Security Event",
          start: "2026-11-02T10:00:00.000Z",
          end: "2026-11-02T11:00:00.000Z",
          timezone: "UTC",
          capacity: 2,
        }),
      }),
    );
    expect(create.status).toBe(201);

    const conflict = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({
          slug: "admin-security-event",
          title: "Dup",
          start: "2026-11-02T10:00:00.000Z",
          end: "2026-11-02T11:00:00.000Z",
          timezone: "UTC",
        }),
      }),
    );
    expect(conflict.status).toBe(409);

    const publish = await postPublish(
      new Request("http://localhost:3000/api/v1/events/admin-security-event/publish", {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "admin-security-event" }) },
    );
    expect(publish.status).toBe(200);

    const cancelNoReason = await postCancel(
      new Request("http://localhost:3000/api/v1/events/admin-security-event/cancel", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ reason: "" }),
      }),
      { params: Promise.resolve({ slug: "admin-security-event" }) },
    );
    expect(cancelNoReason.status).toBe(400);

    const cancel = await postCancel(
      new Request("http://localhost:3000/api/v1/events/admin-security-event/cancel", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ reason: "Operational cancel" }),
      }),
      { params: Promise.resolve({ slug: "admin-security-event" }) },
    );
    expect(cancel.status).toBe(200);
  });

  it("enforces registration/check-in/export governance and rate limits", async () => {
    const addUnknownUser = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/published-open/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ user_id: randomUUID() }),
      }),
      { params: Promise.resolve({ slug: "published-open" }) },
    );
    expect(addUnknownUser.status).toBe(404);

    const cancelExisting = await deleteRegistration(
      new Request(`http://localhost:3000/api/v1/events/published-open/registrations/${fixture.userId}`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "published-open", userId: fixture.userId }) },
    );
    expect(cancelExisting.status).toBe(200);

    const checkinCancelled = await postCheckin(
      new Request("http://localhost:3000/api/v1/events/published-open/checkins", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ user_id: fixture.userId }),
      }),
      { params: Promise.resolve({ slug: "published-open" }) },
    );
    expect(checkinCancelled.status).toBe(412);

    let exportResponse: Response | null = null;
    for (let index = 0; index < 6; index += 1) {
      exportResponse = await getExport(
        new Request("http://localhost:3000/api/v1/events/published-open/export?format=json", {
          headers: {
            cookie: fixture.adminCookie,
            "x-forwarded-for": "203.0.113.10",
          },
        }),
        { params: Promise.resolve({ slug: "published-open" }) },
      );
    }

    expect(exportResponse?.status).toBe(429);

    process.env.APPCTL_ENV = "prod";
    const includeEmailBlocked = await getExport(
      new Request("https://example.com/api/v1/events/published-open/export?format=json&include_email=true", {
        headers: {
          cookie: fixture.adminCookie,
          "x-forwarded-for": "203.0.113.20",
        },
      }),
      { params: Promise.resolve({ slug: "published-open" }) },
    );
    expect(includeEmailBlocked.status).toBe(403);
    process.env.APPCTL_ENV = "local";
  });

  it("enforces user role/state governance and blocks super-admin escalation", async () => {
    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "admin-ops-target@example.com",
          password: "Password123!",
        }),
      }),
    );

    const targetId = userIdByEmail(fixture.dbPath, "admin-ops-target@example.com");

    const addAdmin = await postRole(
      new Request(`http://localhost:3000/api/v1/users/${targetId}/roles`, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ role: "ADMIN" }),
      }),
      { params: Promise.resolve({ id: targetId }) },
    );
    expect(addAdmin.status).toBe(200);
    expect((await addAdmin.json()).changed).toBe(true);

    const addAdminAgain = await postRole(
      new Request(`http://localhost:3000/api/v1/users/${targetId}/roles`, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ role: "ADMIN" }),
      }),
      { params: Promise.resolve({ id: targetId }) },
    );
    expect((await addAdminAgain.json()).changed).toBe(false);

    const removeAdmin = await deleteRole(
      new Request(`http://localhost:3000/api/v1/users/${targetId}/roles/ADMIN`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ id: targetId, role: "ADMIN" }) },
    );
    expect((await removeAdmin.json()).changed).toBe(true);

    const removeAdminAgain = await deleteRole(
      new Request(`http://localhost:3000/api/v1/users/${targetId}/roles/ADMIN`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ id: targetId, role: "ADMIN" }) },
    );
    expect((await removeAdminAgain.json()).changed).toBe(false);

    const addSuperAdmin = await postRole(
      new Request(`http://localhost:3000/api/v1/users/${targetId}/roles`, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ role: "SUPER_ADMIN" }),
      }),
      { params: Promise.resolve({ id: targetId }) },
    );
    expect(addSuperAdmin.status).toBe(403);

    const disable = await patchUser(
      new Request(`http://localhost:3000/api/v1/users/${targetId}`, {
        method: "PATCH",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ status: "DISABLED" }),
      }),
      { params: Promise.resolve({ id: targetId }) },
    );
    expect(disable.status).toBe(200);

    const disabledLogin = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "admin-ops-target@example.com",
          password: "Password123!",
        }),
      }),
    );
    expect(disabledLogin.status).toBe(401);

    const enable = await patchUser(
      new Request(`http://localhost:3000/api/v1/users/${targetId}`, {
        method: "PATCH",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ status: "ACTIVE" }),
      }),
      { params: Promise.resolve({ id: targetId }) },
    );
    expect(enable.status).toBe(200);

    const activeLogin = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "admin-ops-target@example.com",
          password: "Password123!",
        }),
      }),
    );
    expect(activeLogin.status).toBe(200);
  });

  it("keeps users listing usable for admin search/filter", async () => {
    const filtered = await getUsers(
      new Request("http://localhost:3000/api/v1/users?search=usera@example.com&role=USER&status=ACTIVE", {
        headers: {
          cookie: fixture.adminCookie,
        },
      }),
    );

    expect(filtered.status).toBe(200);
    const body = await filtered.json();
    expect(Array.isArray(body.items)).toBe(true);
    expect(body.items.some((user: { email: string }) => user.email === "usera@example.com")).toBe(true);

    const allEvents = await getEvents(new Request("http://localhost:3000/api/v1/events"));
    expect(allEvents.status).toBe(200);
  });
});


===== FILE: src/app/__tests__/e2e-api-foundation.test.ts =====
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { GET as getDocs } from "../api/v1/docs/route";
import { GET as getEvents } from "../api/v1/events/route";
import { GET as getEventBySlug } from "../api/v1/events/[slug]/route";
import { GET as getRegistrations } from "../api/v1/events/[slug]/registrations/route";
import { GET as getApiRoot } from "../api/v1/route";

import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

describe("e2e api-foundation", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("serves api root as HAL with discoverable links", async () => {
    const response = await getApiRoot();

    expect(response.status).toBe(200);
    expect(response.headers.get("content-type")).toContain("application/hal+json");

    const body = await response.json();
    expect(body._links.self.href).toBe("/api/v1");
    expect(body._links.docs.href).toBe("/api/v1/docs");
    expect(body._links.events.href).toBe("/api/v1/events");
    expect(body._links.auth_login.href).toBe("/api/v1/auth/login");
  });

  it("serves docs endpoint with openapi payload", async () => {
    const response = await getDocs();

    expect(response.status).toBe(200);
    expect(response.headers.get("content-type")).toContain("application/json");

    const body = await response.json();
    expect(body.openapi).toBeTruthy();
    expect(body.info).toBeTruthy();
    expect(body.paths).toBeTruthy();
  });

  it("returns problem details with request correlation on not-found resource", async () => {
    const request = new Request("http://localhost:3000/api/v1/events/does-not-exist");
    const response = await getEventBySlug(request, {
      params: Promise.resolve({ slug: "does-not-exist" }),
    });

    expect(response.status).toBe(404);
    expect(response.headers.get("content-type")).toContain("application/problem+json");

    const body = await response.json();
    expect(body.type).toBeTruthy();
    expect(body.title).toBe("Not Found");
    expect(body.status).toBe(404);
    expect(body.detail).toBeTruthy();
    expect(body.instance).toBe("http://localhost:3000/api/v1/events/does-not-exist");
    expect(body.request_id).toBeTruthy();
    expect(response.headers.get("x-request-id")).toBe(body.request_id);
  });

  it("keeps representative success/error media types consistent", async () => {
    const successResponse = await getEvents(new Request("http://localhost:3000/api/v1/events"));
    expect(successResponse.status).toBe(200);
    expect(successResponse.headers.get("content-type")).toContain("application/hal+json");

    const errorResponse = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/missing"),
      {
        params: Promise.resolve({ slug: "missing" }),
      },
    );

    expect(errorResponse.status).toBe(404);
    expect(errorResponse.headers.get("content-type")).toContain("application/problem+json");
  });

  it("provides deterministic baseline fixture resources", async () => {
    const published = await getEvents(
      new Request("http://localhost:3000/api/v1/events?status=PUBLISHED"),
    );
    const publishedBody = await published.json();
    const publishedSlugs = publishedBody.items.map((item: { slug: string }) => item.slug);

    expect(publishedSlugs).toContain("published-open");
    expect(publishedSlugs).toContain("published-full");

    const draft = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/draft-event"),
      { params: Promise.resolve({ slug: "draft-event" }) },
    );
    expect(draft.status).toBe(200);

    const cancelled = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/cancelled-event"),
      { params: Promise.resolve({ slug: "cancelled-event" }) },
    );
    const cancelledBody = await cancelled.json();
    expect(cancelledBody.status).toBe("CANCELLED");

    const registrations = await getRegistrations(
      new Request("http://localhost:3000/api/v1/events/published-open/registrations", {
        headers: {
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "published-open" }) },
    );

    expect(registrations.status).toBe(200);
    const registrationsBody = await registrations.json();
    const userEntry = registrationsBody.items.find((item: { user_id: string }) => item.user_id === fixture.userId);
    expect(userEntry).toBeTruthy();
  });
});


===== FILE: src/app/__tests__/e2e-audit-ui.test.ts =====
import { randomUUID } from "node:crypto";
import Database from "better-sqlite3";
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { GET as getAudit } from "../api/v1/audit/route";
import { POST as postEvents } from "../api/v1/events/route";
import { POST as postPublish } from "../api/v1/events/[slug]/publish/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

describe("e2e audit ui", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("allows admin audit visibility with action and actor filters", async () => {
    const create = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({
          slug: "audit-ops-event",
          title: "Audit Ops Event",
          start: "2026-11-10T10:00:00.000Z",
          end: "2026-11-10T11:00:00.000Z",
          timezone: "UTC",
          capacity: 10,
        }),
      }),
    );
    expect(create.status).toBe(201);

    const publish = await postPublish(
      new Request("http://localhost:3000/api/v1/events/audit-ops-event/publish", {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "audit-ops-event" }) },
    );
    expect(publish.status).toBe(200);

    const filtered = await getAudit(
      new Request(
        `http://localhost:3000/api/v1/audit?action=api.event.publish&actor_id=${fixture.adminId}&limit=20&offset=0`,
        {
          headers: {
            cookie: fixture.adminCookie,
          },
        },
      ),
    );

    expect(filtered.status).toBe(200);
    const body = await filtered.json();
    expect(body.count).toBeGreaterThan(0);
    expect(
      body.items.every(
        (item: { action: string; actor_id: string | null }) =>
          item.action === "api.event.publish" && item.actor_id === fixture.adminId,
      ),
    ).toBe(true);
  });

  it("denies non-admin users from reading audit entries", async () => {
    const response = await getAudit(
      new Request("http://localhost:3000/api/v1/audit", {
        headers: {
          cookie: fixture.userCookie,
        },
      }),
    );

    expect(response.status).toBe(403);
    const body = await response.json();
    expect(body.type).toBe("https://lms-219.dev/problems/forbidden");
  });

  it("redacts sensitive metadata fields in audit output", async () => {
    const db = new Database(fixture.dbPath);
    db.prepare(
      `
INSERT INTO audit_log (
  id,
  actor_type,
  actor_id,
  action,
  target_type,
  target_id,
  metadata,
  created_at,
  request_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
    ).run(
      randomUUID(),
      "USER",
      fixture.adminId,
      "api.test.sensitive",
      "system",
      null,
      JSON.stringify({
        token: "abc123",
        password_hash: "hash-value",
        user_email: "private@example.com",
        nested: {
          secret: "hide-me",
          reason: "keep-visible",
        },
      }),
      new Date().toISOString(),
      randomUUID(),
    );
    db.close();

    const response = await getAudit(
      new Request("http://localhost:3000/api/v1/audit?action=api.test.sensitive", {
        headers: {
          cookie: fixture.adminCookie,
        },
      }),
    );

    expect(response.status).toBe(200);
    const body = await response.json();
    expect(body.count).toBeGreaterThan(0);

    const item = body.items[0] as {
      metadata: {
        token: string;
        password_hash: string;
        user_email: string;
        nested: { secret: string; reason: string };
      };
    };

    expect(item.metadata.token).toBe("[REDACTED]");
    expect(item.metadata.password_hash).toBe("[REDACTED]");
    expect(item.metadata.user_email).toBe("[REDACTED]");
    expect(item.metadata.nested.secret).toBe("[REDACTED]");
    expect(item.metadata.nested.reason).toBe("keep-visible");
  });
});


===== FILE: src/app/__tests__/e2e-auth-session-hardening.test.ts =====
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { GET as getMe } from "../api/v1/me/route";
import { GET as getUsers } from "../api/v1/users/route";
import { POST as postLogin } from "../api/v1/auth/login/route";
import { POST as postLogout } from "../api/v1/auth/logout/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

describe("e2e auth session hardening", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("supports register/login/logout lifecycle with me gating", async () => {
    const register = await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.10",
        },
        body: JSON.stringify({
          email: "sprint22-user@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(register.status).toBe(201);

    const login = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.10",
        },
        body: JSON.stringify({
          email: "sprint22-user@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(login.status).toBe(200);
    const cookie = (login.headers.get("set-cookie") ?? "").split(";")[0];

    const meBeforeLogout = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        method: "GET",
        headers: {
          cookie,
        },
      }),
    );
    expect(meBeforeLogout.status).toBe(200);

    const logout = await postLogout(
      new Request("http://localhost:3000/api/v1/auth/logout", {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie,
        },
      }),
    );

    expect(logout.status).toBe(200);
    expect(logout.headers.get("set-cookie")).toContain("Max-Age=0");

    const meAfterLogout = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        method: "GET",
        headers: {
          cookie,
        },
      }),
    );

    expect(meAfterLogout.status).toBe(401);
  });

  it("shows invalid credentials as problem details with request correlation", async () => {
    const failedLogin = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.20",
        },
        body: JSON.stringify({
          email: "usera@example.com",
          password: "wrong-password",
        }),
      }),
    );

    expect(failedLogin.status).toBe(401);
    expect(failedLogin.headers.get("content-type")).toContain("application/problem+json");

    const body = await failedLogin.json();
    expect(body.title).toBe("Unauthorized");
    expect(body.status).toBe(401);
    expect(body.request_id).toBeTruthy();
    expect(failedLogin.headers.get("x-request-id")).toBe(body.request_id);
  });

  it("enforces rate limits for login and register", async () => {
    let loginResponse: Response | null = null;
    for (let index = 0; index < 6; index += 1) {
      loginResponse = await postLogin(
        new Request("http://localhost:3000/api/v1/auth/login", {
          method: "POST",
          headers: {
            "content-type": "application/json",
            origin: "http://localhost:3000",
            "x-forwarded-for": "198.51.100.30",
          },
          body: JSON.stringify({
            email: "usera@example.com",
            password: "bad-password",
          }),
        }),
      );
    }

    expect(loginResponse?.status).toBe(429);

    let registerResponse: Response | null = null;
    for (let index = 0; index < 6; index += 1) {
      registerResponse = await postRegister(
        new Request("http://localhost:3000/api/v1/auth/register", {
          method: "POST",
          headers: {
            "content-type": "application/json",
            origin: "http://localhost:3000",
            "x-forwarded-for": "198.51.100.40",
          },
          body: JSON.stringify({
            email: "rate-limit-user@example.com",
            password: "Password123!",
          }),
        }),
      );
    }

    expect(registerResponse?.status).toBe(429);
    expect(registerResponse?.headers.get("retry-after")).toBeTruthy();
  });

  it("blocks csrf-unsafe auth mutations with problem details", async () => {
    const csrfBlockedRegister = await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "https://evil.example",
          "x-forwarded-for": "198.51.100.50",
        },
        body: JSON.stringify({
          email: "csrf-user@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(csrfBlockedRegister.status).toBe(403);
    expect(csrfBlockedRegister.headers.get("content-type")).toContain("application/problem+json");

    const body = await csrfBlockedRegister.json();
    expect(body.title).toBe("Forbidden");
    expect(body.request_id).toBeTruthy();
  });

  it("supports role-aware me links and blocks admin routes when session expires", async () => {
    const meAsAdmin = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        method: "GET",
        headers: {
          cookie: fixture.adminCookie,
        },
      }),
    );

    expect(meAsAdmin.status).toBe(200);
    const meBody = await meAsAdmin.json();
    expect(meBody._links.users.href).toBe("/api/v1/users");

    const logout = await postLogout(
      new Request("http://localhost:3000/api/v1/auth/logout", {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
    );
    expect(logout.status).toBe(200);

    const usersAfterExpiry = await getUsers(
      new Request("http://localhost:3000/api/v1/users", {
        headers: {
          cookie: fixture.adminCookie,
        },
      }),
    );

    expect(usersAfterExpiry.status).toBe(401);
    expect(usersAfterExpiry.headers.get("content-type")).toContain("application/problem+json");
  });
});


===== FILE: src/app/__tests__/e2e-compliance-release.test.ts =====
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { GET as getApiRoot } from "../api/v1/route";
import { GET as getMe } from "../api/v1/me/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import { POST as postDeleteAccount } from "../api/v1/account/delete/route";
import { GET as getRegistrations } from "../api/v1/events/[slug]/registrations/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

describe("e2e compliance release", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("surfaces terms/privacy policy links in root and account flows", async () => {
    const root = await getApiRoot();
    expect(root.status).toBe(200);
    const rootBody = await root.json();
    expect(rootBody._links.terms.href).toBe("/terms");
    expect(rootBody._links.privacy.href).toBe("/privacy");
    expect(rootBody._links.account_delete.href).toBe("/api/v1/account/delete");

    const me = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        headers: { cookie: fixture.userCookie },
      }),
    );
    expect(me.status).toBe(200);
    const meBody = await me.json();
    expect(meBody._links.terms.href).toBe("/terms");
    expect(meBody._links.privacy.href).toBe("/privacy");
    expect(meBody._links.account_delete.href).toBe("/api/v1/account/delete");
  });

  it("rejects explicit missing consent during registration", async () => {
    const denied = await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "consent-denied@example.com",
          password: "Password123!",
          terms_accepted: false,
        }),
      }),
    );

    expect(denied.status).toBe(400);
    const deniedBody = await denied.json();
    expect(deniedBody.detail).toContain("acknowledgment");

    const accepted = await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "consent-accepted@example.com",
          password: "Password123!",
          terms_accepted: true,
        }),
      }),
    );

    expect(accepted.status).toBe(201);
  });

  it("applies retention-safe account deletion by revoking access and cancelling registrations", async () => {
    const deleted = await postDeleteAccount(
      new Request("http://localhost:3000/api/v1/account/delete", {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.userCookie,
        },
      }),
    );

    expect(deleted.status).toBe(200);

    const meAfterDelete = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        headers: { cookie: fixture.userCookie },
      }),
    );
    expect(meAfterDelete.status).toBe(401);

    const registrations = await getRegistrations(
      new Request("http://localhost:3000/api/v1/events/published-open/registrations", {
        headers: {
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "published-open" }) },
    );
    expect(registrations.status).toBe(200);
    const registrationsBody = await registrations.json();

    const deletedUserRegistration = registrationsBody.items.find(
      (item: { user_id: string; status: string }) => item.user_id === fixture.userId,
    );

    expect(deletedUserRegistration?.status).toBe("CANCELLED");
  });

  it("keeps escalation-only operations out of API discoverability surface", async () => {
    const root = await getApiRoot();
    expect(root.status).toBe(200);
    const body = await root.json();

    expect(body._links.db_backup).toBeUndefined();
    expect(body._links.db_restore).toBeUndefined();
    expect(body._links.auth_token_create).toBeUndefined();
  });
});


===== FILE: src/app/__tests__/e2e-email-verification.test.ts =====
import Database from "better-sqlite3";
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { POST as postLogin } from "../api/v1/auth/login/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import { POST as postVerifyRequest } from "../api/v1/auth/verify/request/route";
import { POST as postVerifyConfirm } from "../api/v1/auth/verify/confirm/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

const userIdByEmail = (dbPath: string, email: string) => {
  const db = new Database(dbPath);
  const row = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  db.close();
  return row.id;
};

describe("e2e email verification", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
    process.env.APPCTL_REQUIRE_EMAIL_VERIFICATION = "true";
  });

  afterEach(async () => {
    delete process.env.APPCTL_REQUIRE_EMAIL_VERIFICATION;
    await cleanupStandardE2EFixtures();
  });

  it("requires verification before login and allows login after confirm", async () => {
    const register = await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "verify-user@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(register.status).toBe(201);
    const registerBody = await register.json();
    expect(registerBody.status).toBe("PENDING");

    const loginBlocked = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "verify-user@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(loginBlocked.status).toBe(403);
    const blockedBody = await loginBlocked.json();
    expect(blockedBody.type).toContain("email-unverified");
    expect(blockedBody.request_id).toBeTruthy();

    const resend = await postVerifyRequest(
      new Request("http://localhost:3000/api/v1/auth/verify/request", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.81",
        },
        body: JSON.stringify({ email: "verify-user@example.com" }),
      }),
    );

    expect(resend.status).toBe(202);
    const resendBody = await resend.json();
    expect(resendBody.verification_token).toBeTruthy();

    const confirm = await postVerifyConfirm(
      new Request("http://localhost:3000/api/v1/auth/verify/confirm", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ token: resendBody.verification_token }),
      }),
    );

    expect(confirm.status).toBe(200);

    const loginAllowed = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "verify-user@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(loginAllowed.status).toBe(200);
  });

  it("rejects expired verification token", async () => {
    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "expired-verify@example.com",
          password: "Password123!",
        }),
      }),
    );

    const requestToken = await postVerifyRequest(
      new Request("http://localhost:3000/api/v1/auth/verify/request", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.82",
        },
        body: JSON.stringify({ email: "expired-verify@example.com" }),
      }),
    );
    const tokenBody = await requestToken.json();

    const userId = userIdByEmail(fixture.dbPath, "expired-verify@example.com");
    const db = new Database(fixture.dbPath);
    db.prepare(
      "UPDATE api_email_verifications SET expires_at = ?, used_at = NULL WHERE user_id = ?",
    ).run("2000-01-01T00:00:00.000Z", userId);
    db.close();

    const confirmExpired = await postVerifyConfirm(
      new Request("http://localhost:3000/api/v1/auth/verify/confirm", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ token: tokenBody.verification_token }),
      }),
    );

    expect(confirmExpired.status).toBe(412);
  });

  it("supports resend lifecycle and blocks old token after resend", async () => {
    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "resend-verify@example.com",
          password: "Password123!",
        }),
      }),
    );

    const first = await postVerifyRequest(
      new Request("http://localhost:3000/api/v1/auth/verify/request", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.83",
        },
        body: JSON.stringify({ email: "resend-verify@example.com" }),
      }),
    );
    const firstBody = await first.json();

    const second = await postVerifyRequest(
      new Request("http://localhost:3000/api/v1/auth/verify/request", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.83",
        },
        body: JSON.stringify({ email: "resend-verify@example.com" }),
      }),
    );
    const secondBody = await second.json();

    const confirmOld = await postVerifyConfirm(
      new Request("http://localhost:3000/api/v1/auth/verify/confirm", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ token: firstBody.verification_token }),
      }),
    );
    expect(confirmOld.status).toBe(409);

    const confirmNew = await postVerifyConfirm(
      new Request("http://localhost:3000/api/v1/auth/verify/confirm", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ token: secondBody.verification_token }),
      }),
    );
    expect(confirmNew.status).toBe(200);
  });

  it("rate limits verification resend endpoint", async () => {
    let response: Response | null = null;

    for (let index = 0; index < 6; index += 1) {
      response = await postVerifyRequest(
        new Request("http://localhost:3000/api/v1/auth/verify/request", {
          method: "POST",
          headers: {
            "content-type": "application/json",
            origin: "http://localhost:3000",
            "x-forwarded-for": "198.51.100.84",
          },
          body: JSON.stringify({ email: "any@example.com" }),
        }),
      );
    }

    expect(response?.status).toBe(429);
    expect(response?.headers.get("retry-after")).toBeTruthy();
  });
});


===== FILE: src/app/__tests__/e2e-event-discovery.test.ts =====
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { GET as getEvents } from "../api/v1/events/route";
import { POST as postEvent } from "../api/v1/events/route";
import { POST as postPublish } from "../api/v1/events/[slug]/publish/route";
import { GET as getEventIcs } from "../api/v1/events/[slug]/ics/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

describe("e2e event discovery", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("supports title search with stable pagination", async () => {
    const created = [
      { slug: "summit-alpha", title: "Summit Alpha", day: "05" },
      { slug: "summit-beta", title: "Summit Beta", day: "06" },
      { slug: "summit-gamma", title: "Summit Gamma", day: "07" },
    ];

    for (const item of created) {
      const create = await postEvent(
        new Request("http://localhost:3000/api/v1/events", {
          method: "POST",
          headers: {
            "content-type": "application/json",
            origin: "http://localhost:3000",
            cookie: fixture.adminCookie,
          },
          body: JSON.stringify({
            slug: item.slug,
            title: item.title,
            start: `2026-10-${item.day}T10:00:00.000Z`,
            end: `2026-10-${item.day}T11:00:00.000Z`,
            timezone: "UTC",
            capacity: 20,
          }),
        }),
      );
      expect(create.status).toBe(201);

      const publish = await postPublish(
        new Request(`http://localhost:3000/api/v1/events/${item.slug}/publish`, {
          method: "POST",
          headers: {
            origin: "http://localhost:3000",
            cookie: fixture.adminCookie,
          },
        }),
        { params: Promise.resolve({ slug: item.slug }) },
      );
      expect(publish.status).toBe(200);
    }

    const firstPage = await getEvents(
      new Request("http://localhost:3000/api/v1/events?q=Summit&limit=2&offset=0"),
    );
    expect(firstPage.status).toBe(200);
    const firstPageBody = await firstPage.json();
    expect(firstPageBody.items).toHaveLength(2);
    expect(
      firstPageBody.items.every((item: { title: string }) => item.title.toLowerCase().includes("summit")),
    ).toBe(true);

    const secondPage = await getEvents(
      new Request("http://localhost:3000/api/v1/events?q=Summit&limit=2&offset=2"),
    );
    expect(secondPage.status).toBe(200);
    const secondPageBody = await secondPage.json();
    expect(secondPageBody.items).toHaveLength(1);
    expect(secondPageBody.items[0].title).toContain("Summit");

    const pageOneIds = new Set(firstPageBody.items.map((item: { id: string }) => item.id));
    expect(pageOneIds.has(secondPageBody.items[0].id)).toBe(false);
  });

  it("exports timezone-correct ICS event data", async () => {
    const response = await getEventIcs(
      new Request("http://localhost:3000/api/v1/events/published-open/ics"),
      { params: Promise.resolve({ slug: "published-open" }) },
    );

    expect(response.status).toBe(200);
    expect(response.headers.get("content-type")).toContain("text/calendar");

    const body = await response.text();
    expect(body).toContain("BEGIN:VCALENDAR");
    expect(body).toContain("SUMMARY:Published Open");
    expect(body).toContain("DTSTART:20260901T100000Z");
    expect(body).toContain("DTEND:20260901T110000Z");
  });
});


===== FILE: src/app/__tests__/e2e-password-reset.test.ts =====
import Database from "better-sqlite3";
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { POST as postLogin } from "../api/v1/auth/login/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import { POST as postResetRequest } from "../api/v1/auth/password-reset/request/route";
import { POST as postResetConfirm } from "../api/v1/auth/password-reset/confirm/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

const userIdByEmail = (dbPath: string, email: string) => {
  const db = new Database(dbPath);
  const row = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  db.close();
  return row.id;
};

describe("e2e password reset", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("supports password reset request and confirm with one-time token", async () => {
    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "reset-user@example.com",
          password: "Password123!",
        }),
      }),
    );

    const requestReset = await postResetRequest(
      new Request("http://localhost:3000/api/v1/auth/password-reset/request", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.70",
        },
        body: JSON.stringify({ email: "reset-user@example.com" }),
      }),
    );

    expect(requestReset.status).toBe(202);
    const requestBody = await requestReset.json();
    expect(requestBody.accepted).toBe(true);
    expect(requestBody.reset_token).toBeTruthy();

    const oldPasswordLogin = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ email: "reset-user@example.com", password: "Password123!" }),
      }),
    );
    expect(oldPasswordLogin.status).toBe(200);

    const confirm = await postResetConfirm(
      new Request("http://localhost:3000/api/v1/auth/password-reset/confirm", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          token: requestBody.reset_token,
          password: "NewPassword123!",
        }),
      }),
    );

    expect(confirm.status).toBe(200);

    const oldLoginAfterReset = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ email: "reset-user@example.com", password: "Password123!" }),
      }),
    );
    expect(oldLoginAfterReset.status).toBe(401);

    const newLoginAfterReset = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ email: "reset-user@example.com", password: "NewPassword123!" }),
      }),
    );
    expect(newLoginAfterReset.status).toBe(200);

    const reuse = await postResetConfirm(
      new Request("http://localhost:3000/api/v1/auth/password-reset/confirm", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          token: requestBody.reset_token,
          password: "AnotherPassword123!",
        }),
      }),
    );
    expect(reuse.status).toBe(409);
  });

  it("rejects expired password reset token", async () => {
    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "expired-reset@example.com",
          password: "Password123!",
        }),
      }),
    );

    const requestReset = await postResetRequest(
      new Request("http://localhost:3000/api/v1/auth/password-reset/request", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.71",
        },
        body: JSON.stringify({ email: "expired-reset@example.com" }),
      }),
    );
    const requestBody = await requestReset.json();

    const userId = userIdByEmail(fixture.dbPath, "expired-reset@example.com");
    const db = new Database(fixture.dbPath);
    db.prepare(
      "UPDATE api_password_resets SET expires_at = ?, used_at = NULL WHERE user_id = ?",
    ).run("2000-01-01T00:00:00.000Z", userId);
    db.close();

    const confirmExpired = await postResetConfirm(
      new Request("http://localhost:3000/api/v1/auth/password-reset/confirm", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          token: requestBody.reset_token,
          password: "NewPassword123!",
        }),
      }),
    );

    expect(confirmExpired.status).toBe(412);
  });

  it("accepts unknown email requests without leaking account existence", async () => {
    const response = await postResetRequest(
      new Request("http://localhost:3000/api/v1/auth/password-reset/request", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.72",
        },
        body: JSON.stringify({ email: "unknown@example.com" }),
      }),
    );

    expect(response.status).toBe(202);
    const body = await response.json();
    expect(body.accepted).toBe(true);
  });

  it("rate limits reset requests", async () => {
    let response: Response | null = null;

    for (let index = 0; index < 6; index += 1) {
      response = await postResetRequest(
        new Request("http://localhost:3000/api/v1/auth/password-reset/request", {
          method: "POST",
          headers: {
            "content-type": "application/json",
            origin: "http://localhost:3000",
            "x-forwarded-for": "198.51.100.73",
          },
          body: JSON.stringify({ email: "rate-reset@example.com" }),
        }),
      );
    }

    expect(response?.status).toBe(429);
    expect(response?.headers.get("retry-after")).toBeTruthy();
  });
});


===== FILE: src/app/__tests__/e2e-public-events-hal.test.ts =====
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { GET as getEvents } from "../api/v1/events/route";
import { GET as getEventBySlug } from "../api/v1/events/[slug]/route";
import { POST as postPublish } from "../api/v1/events/[slug]/publish/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

describe("e2e public events + hal", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("renders public events list and detail resources", async () => {
    const listResponse = await getEvents(new Request("http://localhost:3000/api/v1/events"));
    expect(listResponse.status).toBe(200);
    expect(listResponse.headers.get("content-type")).toContain("application/hal+json");

    const listBody = await listResponse.json();
    expect(listBody.count).toBeGreaterThanOrEqual(4);

    const detailResponse = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/published-open"),
      { params: Promise.resolve({ slug: "published-open" }) },
    );

    expect(detailResponse.status).toBe(200);
    const detailBody = await detailResponse.json();
    expect(detailBody.slug).toBe("published-open");
    expect(detailBody.status).toBe("PUBLISHED");
  });

  it("returns consistent problem details for missing public event", async () => {
    const response = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/bad-slug"),
      { params: Promise.resolve({ slug: "bad-slug" }) },
    );

    expect(response.status).toBe(404);
    expect(response.headers.get("content-type")).toContain("application/problem+json");

    const body = await response.json();
    expect(body.title).toBe("Not Found");
    expect(body.status).toBe(404);
    expect(body.request_id).toBeTruthy();
  });

  it("shows state-driven HAL affordances by event status", async () => {
    const draft = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/draft-event"),
      { params: Promise.resolve({ slug: "draft-event" }) },
    );
    const draftBody = await draft.json();
    expect(draftBody.status).toBe("DRAFT");
    expect(draftBody._links["app:publish"]?.href).toBe("/api/v1/events/draft-event/publish");
    expect(draftBody._links["app:cancel"]).toBeFalsy();

    const published = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/published-open"),
      { params: Promise.resolve({ slug: "published-open" }) },
    );
    const publishedBody = await published.json();
    expect(publishedBody.status).toBe("PUBLISHED");
    expect(publishedBody._links["app:publish"]).toBeFalsy();
    expect(publishedBody._links["app:cancel"]?.href).toBe("/api/v1/events/published-open/cancel");

    const cancelled = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/cancelled-event"),
      { params: Promise.resolve({ slug: "cancelled-event" }) },
    );
    const cancelledBody = await cancelled.json();
    expect(cancelledBody.status).toBe("CANCELLED");
    expect(cancelledBody._links["app:publish"]).toBeFalsy();
    expect(cancelledBody._links["app:cancel"]).toBeFalsy();
  });

  it("executes publish via HAL href and removes publish affordance after transition", async () => {
    const draftResponse = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/draft-event"),
      { params: Promise.resolve({ slug: "draft-event" }) },
    );
    const draftBody = await draftResponse.json();
    const publishHref = draftBody._links["app:publish"]?.href as string;

    expect(publishHref).toBe("/api/v1/events/draft-event/publish");

    const publishSlug = publishHref.split("/").at(-2) as string;
    const publishResponse = await postPublish(
      new Request(`http://localhost:3000${publishHref}`, {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: publishSlug }) },
    );

    expect(publishResponse.status).toBe(200);

    const postPublishView = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/draft-event"),
      { params: Promise.resolve({ slug: "draft-event" }) },
    );
    const postPublishBody = await postPublishView.json();
    expect(postPublishBody.status).toBe("PUBLISHED");
    expect(postPublishBody._links["app:publish"]).toBeFalsy();
    expect(postPublishBody._links["app:cancel"]).toBeTruthy();
  });

  it("handles stale publish action gracefully and keeps HAL state authoritative", async () => {
    const draftResponse = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/draft-event"),
      { params: Promise.resolve({ slug: "draft-event" }) },
    );
    const draftBody = await draftResponse.json();
    const stalePublishHref = draftBody._links["app:publish"]?.href as string;

    await postPublish(
      new Request(`http://localhost:3000${stalePublishHref}`, {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "draft-event" }) },
    );

    const stalePublishAttempt = await postPublish(
      new Request(`http://localhost:3000${stalePublishHref}`, {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "draft-event" }) },
    );

    expect(stalePublishAttempt.status).toBe(200);

    const refreshed = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/draft-event"),
      { params: Promise.resolve({ slug: "draft-event" }) },
    );
    const refreshedBody = await refreshed.json();

    expect(refreshedBody.status).toBe("PUBLISHED");
    expect(refreshedBody._links["app:publish"]).toBeFalsy();
    expect(refreshedBody._links["app:cancel"]).toBeTruthy();
  });
});


===== FILE: src/app/__tests__/e2e-release-journeys-regression.test.ts =====
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";

import { POST as postLogin } from "../api/v1/auth/login/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import { POST as postEvents } from "../api/v1/events/route";
import { POST as postPublish } from "../api/v1/events/[slug]/publish/route";
import { POST as postRegistration } from "../api/v1/events/[slug]/registrations/route";
import { DELETE as deleteRegistration } from "../api/v1/events/[slug]/registrations/[userId]/route";
import { POST as postCheckin } from "../api/v1/events/[slug]/checkins/route";
import { GET as getExport } from "../api/v1/events/[slug]/export/route";
import { GET as getMe } from "../api/v1/me/route";
import { GET as getUsers } from "../api/v1/users/route";
import { DELETE as deleteRole } from "../api/v1/users/[id]/roles/[role]/route";
import { requestHal } from "../../lib/hal-client";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

describe("e2e release journeys regression", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    vi.restoreAllMocks();
    await cleanupStandardE2EFixtures();
  });

  it("passes the public journey browse-register-waitlist-cancel", async () => {
    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "release-public@example.com",
          password: "Password123!",
        }),
      }),
    );

    const login = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "release-public@example.com",
          password: "Password123!",
        }),
      }),
    );

    const cookie = (login.headers.get("set-cookie") ?? "").split(";")[0];

    const me = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        headers: { cookie },
      }),
    );
    const meBody = await me.json();

    const registerOpen = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/published-open/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie,
        },
        body: JSON.stringify({ user_id: meBody.id }),
      }),
      { params: Promise.resolve({ slug: "published-open" }) },
    );
    expect(registerOpen.status).toBe(200);
    expect((await registerOpen.json()).status).toBe("REGISTERED");

    const waitlist = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/published-full/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie,
        },
        body: JSON.stringify({ user_id: meBody.id }),
      }),
      { params: Promise.resolve({ slug: "published-full" }) },
    );
    expect(waitlist.status).toBe(200);
    expect((await waitlist.json()).status).toBe("WAITLISTED");

    const cancel = await deleteRegistration(
      new Request(`http://localhost:3000/api/v1/events/published-open/registrations/${meBody.id}`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie,
        },
      }),
      { params: Promise.resolve({ slug: "published-open", userId: meBody.id }) },
    );

    expect(cancel.status).toBe(200);
    expect((await cancel.json()).status).toBe("CANCELLED");
  });

  it("passes the admin journey create-publish-register-checkin-export", async () => {
    const create = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({
          slug: "release-admin-journey",
          title: "Release Admin Journey",
          start: "2026-12-01T10:00:00.000Z",
          end: "2026-12-01T11:00:00.000Z",
          timezone: "UTC",
          capacity: 10,
        }),
      }),
    );
    expect(create.status).toBe(201);

    const publish = await postPublish(
      new Request("http://localhost:3000/api/v1/events/release-admin-journey/publish", {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "release-admin-journey" }) },
    );
    expect(publish.status).toBe(200);

    const addRegistration = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/release-admin-journey/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ user_id: fixture.userId }),
      }),
      { params: Promise.resolve({ slug: "release-admin-journey" }) },
    );
    expect(addRegistration.status).toBe(200);

    const checkin = await postCheckin(
      new Request("http://localhost:3000/api/v1/events/release-admin-journey/checkins", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ user_id: fixture.userId }),
      }),
      { params: Promise.resolve({ slug: "release-admin-journey" }) },
    );
    expect(checkin.status).toBe(200);

    const exported = await getExport(
      new Request("http://localhost:3000/api/v1/events/release-admin-journey/export?format=json", {
        headers: { cookie: fixture.adminCookie },
      }),
      { params: Promise.resolve({ slug: "release-admin-journey" }) },
    );

    expect(exported.status).toBe(200);
    expect(exported.headers.get("content-type")).toContain("application/json");
  });

  it("keeps request_id supportability in surfaced API errors", async () => {
    vi.spyOn(globalThis, "fetch").mockResolvedValue(
      new Response(
        JSON.stringify({
          type: "about:blank",
          title: "Internal Server Error",
          status: 500,
          detail: "Injected failure",
          request_id: "req-release-journey-1",
        }),
        {
          status: 500,
          headers: {
            "content-type": "application/problem+json",
          },
        },
      ),
    );

    const failed = await requestHal<{ ok: true }>("/api/v1/events");
    expect(failed.ok).toBe(false);
    if (!failed.ok) {
      expect(failed.problem.request_id).toBe("req-release-journey-1");
      expect(failed.problem.status).toBe(500);
    }
  });

  it("removes admin access immediately after role downgrade mid-session", async () => {
    const meBefore = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        headers: { cookie: fixture.adminCookie },
      }),
    );
    expect(meBefore.status).toBe(200);
    const meBeforeBody = await meBefore.json();
    expect(meBeforeBody._links.users.href).toBe("/api/v1/users");

    const roleRemoval = await deleteRole(
      new Request(`http://localhost:3000/api/v1/users/${fixture.adminId}/roles/ADMIN`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ id: fixture.adminId, role: "ADMIN" }) },
    );
    expect(roleRemoval.status).toBe(200);

    const meAfter = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        headers: { cookie: fixture.adminCookie },
      }),
    );
    expect(meAfter.status).toBe(200);
    const meAfterBody = await meAfter.json();
    expect(meAfterBody._links.users).toBeUndefined();

    const usersAfter = await getUsers(
      new Request("http://localhost:3000/api/v1/users", {
        headers: { cookie: fixture.adminCookie },
      }),
    );
    expect(usersAfter.status).toBe(403);
  });
});


===== FILE: src/app/__tests__/e2e-ui-hardening.test.ts =====
import { readFile } from "node:fs/promises";
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it, vi } from "vitest";

import { GET as getEvents, POST as postEvents } from "../api/v1/events/route";
import { POST as postPublishEvent } from "../api/v1/events/[slug]/publish/route";
import { POST as postRegistration } from "../api/v1/events/[slug]/registrations/route";
import { DELETE as deleteRegistration } from "../api/v1/events/[slug]/registrations/[userId]/route";
import { POST as postCheckin } from "../api/v1/events/[slug]/checkins/route";
import { GET as getExport } from "../api/v1/events/[slug]/export/route";
import { GET as getMe } from "../api/v1/me/route";
import { POST as postAddRole } from "../api/v1/users/[id]/roles/route";
import { POST as postLogin } from "../api/v1/auth/login/route";
import { POST as postLogout } from "../api/v1/auth/logout/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import { runCli } from "../../cli/run-cli";
import { type CliIo } from "../../cli/types";
import { requestHal } from "../../lib/hal-client";
import { resetRateLimits } from "../../lib/api/rate-limit";

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-ui-hardening-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const runWithDb = async (argv: string[], dbPath: string): Promise<number> => {
  const { io } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return exitCode;
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

const registerAndLogin = async (email: string): Promise<string> => {
  await postRegister(
    new Request("http://localhost:3000/api/v1/auth/register", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  const login = await postLogin(
    new Request("http://localhost:3000/api/v1/auth/login", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  return (login.headers.get("set-cookie") ?? "").split(";")[0];
};

const withDb = (dbPath: string) => new Database(dbPath);

const userIdByEmail = (dbPath: string, email: string) => {
  const db = withDb(dbPath);
  const row = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  db.close();
  return row.id;
};

const addAdminRole = (dbPath: string, email: string) => {
  const db = withDb(dbPath);
  const user = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  const role = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
  db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(user.id, role.id);
  db.close();
};

afterEach(async () => {
  delete process.env.APPCTL_DB_FILE;
  delete process.env.APPCTL_ENV;
  vi.restoreAllMocks();
  resetRateLimits();
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("e2e ui hardening release gate", () => {
  it("passes critical auth, public events, registration, waitlist, cancel, admin check-in, and export flows", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("gate-admin@example.com");
    const userOneCookie = await registerAndLogin("gate-user-1@example.com");
    const userTwoCookie = await registerAndLogin("gate-user-2@example.com");

    addAdminRole(dbPath, "gate-admin@example.com");
    const adminId = userIdByEmail(dbPath, "gate-admin@example.com");
    const userOneId = userIdByEmail(dbPath, "gate-user-1@example.com");
    const userTwoId = userIdByEmail(dbPath, "gate-user-2@example.com");

    const meResponse = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        method: "GET",
        headers: {
          cookie: adminCookie,
        },
      }),
    );
    expect(meResponse.status).toBe(200);

    const logoutResponse = await postLogout(
      new Request("http://localhost:3000/api/v1/auth/logout", {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: userOneCookie,
        },
      }),
    );
    expect(logoutResponse.status).toBe(200);

    const reloginUserOne = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ email: "gate-user-1@example.com", password: "Password123!" }),
      }),
    );
    const reloginUserOneCookie = (reloginUserOne.headers.get("set-cookie") ?? "").split(";")[0];

    const createAdminEvent = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({
          slug: "admin-gate-event",
          title: "Admin Gate Event",
          start: "2026-08-01T10:00:00.000Z",
          end: "2026-08-01T11:00:00.000Z",
          timezone: "UTC",
          capacity: 5,
        }),
      }),
    );
    expect(createAdminEvent.status).toBe(201);

    const publishAdminEvent = await postPublishEvent(
      new Request("http://localhost:3000/api/v1/events/admin-gate-event/publish", {
        method: "POST",
        headers: {
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
      }),
      { params: Promise.resolve({ slug: "admin-gate-event" }) },
    );
    expect(publishAdminEvent.status).toBe(200);

    const publicEvents = await getEvents(new Request("http://localhost:3000/api/v1/events"));
    expect(publicEvents.status).toBe(200);
    const publicBody = await publicEvents.json();
    expect(publicBody.items.some((item: { slug: string }) => item.slug === "admin-gate-event")).toBe(true);

    const registerPublished = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/admin-gate-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: reloginUserOneCookie,
        },
        body: JSON.stringify({ user_id: userOneId }),
      }),
      { params: Promise.resolve({ slug: "admin-gate-event" }) },
    );
    expect(registerPublished.status).toBe(200);
    expect((await registerPublished.json()).status).toBe("REGISTERED");

    const checkinPublished = await postCheckin(
      new Request("http://localhost:3000/api/v1/events/admin-gate-event/checkins", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ user_id: userOneId }),
      }),
      { params: Promise.resolve({ slug: "admin-gate-event" }) },
    );
    expect(checkinPublished.status).toBe(200);

    const exportPublished = await getExport(
      new Request("http://localhost:3000/api/v1/events/admin-gate-event/export?format=json", {
        headers: {
          cookie: adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "admin-gate-event" }) },
    );
    expect(exportPublished.status).toBe(200);

    const createWaitlistEvent = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({
          slug: "waitlist-gate-event",
          title: "Waitlist Gate Event",
          start: "2026-08-02T10:00:00.000Z",
          end: "2026-08-02T11:00:00.000Z",
          timezone: "UTC",
          capacity: 1,
        }),
      }),
    );
    expect(createWaitlistEvent.status).toBe(201);

    const publishWaitlistEvent = await postPublishEvent(
      new Request("http://localhost:3000/api/v1/events/waitlist-gate-event/publish", {
        method: "POST",
        headers: {
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
      }),
      { params: Promise.resolve({ slug: "waitlist-gate-event" }) },
    );
    expect(publishWaitlistEvent.status).toBe(200);

    const userOneWaitlist = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/waitlist-gate-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: reloginUserOneCookie,
        },
        body: JSON.stringify({ user_id: userOneId }),
      }),
      { params: Promise.resolve({ slug: "waitlist-gate-event" }) },
    );
    expect((await userOneWaitlist.json()).status).toBe("REGISTERED");

    const userTwoWaitlist = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/waitlist-gate-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: userTwoCookie,
        },
        body: JSON.stringify({ user_id: userTwoId }),
      }),
      { params: Promise.resolve({ slug: "waitlist-gate-event" }) },
    );
    expect((await userTwoWaitlist.json()).status).toBe("WAITLISTED");

    const cancelUserOne = await deleteRegistration(
      new Request(`http://localhost:3000/api/v1/events/waitlist-gate-event/registrations/${userOneId}`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: reloginUserOneCookie,
        },
      }),
      { params: Promise.resolve({ slug: "waitlist-gate-event", userId: userOneId }) },
    );
    expect((await cancelUserOne.json()).status).toBe("CANCELLED");

    expect(adminId).toBeTruthy();
  });

  it("keeps accessibility and problem-details request_id behavior consistent and blocks super admin UI mutation", async () => {
    vi.spyOn(globalThis, "fetch").mockResolvedValue(
      new Response(
        JSON.stringify({
          type: "about:blank",
          title: "Forbidden",
          status: 403,
          detail: "Denied",
          request_id: "req-ui-hardening-1",
        }),
        {
          status: 403,
          headers: {
            "content-type": "application/problem+json",
          },
        },
      ),
    );

    const failed = await requestHal<{ ok: true }>("/api/v1/denied");
    expect(failed.ok).toBe(false);
    if (!failed.ok) {
      expect(failed.problem.request_id).toBe("req-ui-hardening-1");
    }

    const loginSource = await readFile(join(process.cwd(), "src/app/login/page.tsx"), "utf8");
    const registerSource = await readFile(join(process.cwd(), "src/app/register/page.tsx"), "utf8");
    const adminUsersSource = await readFile(join(process.cwd(), "src/app/admin/users/page.tsx"), "utf8");

    expect(loginSource.includes("<label htmlFor=")).toBe(true);
    expect(registerSource.includes("<label htmlFor=")).toBe(true);
    expect(adminUsersSource.includes("ProblemDetailsPanel")).toBe(true);
    expect(adminUsersSource.includes("Add SUPER_ADMIN")).toBe(false);
    expect(adminUsersSource.includes("Remove SUPER_ADMIN")).toBe(false);
  });

  it("enforces super-admin role mutation as API-forbidden", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("role-admin@example.com");
    const targetCookie = await registerAndLogin("role-target@example.com");

    addAdminRole(dbPath, "role-admin@example.com");
    const targetId = userIdByEmail(dbPath, "role-target@example.com");

    const blocked = await postAddRole(
      new Request(`http://localhost:3000/api/v1/users/${targetId}/roles`, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ role: "SUPER_ADMIN" }),
      }),
      { params: Promise.resolve({ id: targetId }) },
    );

    expect(blocked.status).toBe(403);
    expect(targetCookie).toContain("lms_session=");
  });
});


===== FILE: src/app/__tests__/helpers/e2e-fixtures.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";

import { POST as postLogin } from "../../api/v1/auth/login/route";
import { POST as postRegister } from "../../api/v1/auth/register/route";
import { POST as postEvent } from "../../api/v1/events/route";
import { POST as postPublish } from "../../api/v1/events/[slug]/publish/route";
import { POST as postCancel } from "../../api/v1/events/[slug]/cancel/route";
import { POST as postRegistration } from "../../api/v1/events/[slug]/registrations/route";
import { runCli } from "../../../cli/run-cli";
import type { CliIo } from "../../../cli/types";
import { resetRateLimits } from "../../../lib/api/rate-limit";

const tempDirs: string[] = [];

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const runWithDb = async (argv: string[], dbPath: string): Promise<number> => {
  const { io } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return exitCode;
};

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-e2e-fixture-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const login = async (email: string): Promise<string> => {
  const response = await postLogin(
    new Request("http://localhost:3000/api/v1/auth/login", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  return (response.headers.get("set-cookie") ?? "").split(";")[0];
};

const registerUser = async (email: string) => {
  const response = await postRegister(
    new Request("http://localhost:3000/api/v1/auth/register", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  if (response.status !== 201) {
    throw new Error(`failed_register_${email}`);
  }
};

const addAdminRole = (dbPath: string, email: string) => {
  const db = new Database(dbPath);
  const user = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  const role = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
  db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(user.id, role.id);
  db.close();
};

const userIdByEmail = (dbPath: string, email: string) => {
  const db = new Database(dbPath);
  const user = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  db.close();
  return user.id;
};

const createEvent = async (
  adminCookie: string,
  payload: {
    slug: string;
    title: string;
    start: string;
    end: string;
    timezone: string;
    capacity: number;
  },
) => {
  const response = await postEvent(
    new Request("http://localhost:3000/api/v1/events", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
        cookie: adminCookie,
      },
      body: JSON.stringify(payload),
    }),
  );

  if (response.status !== 201) {
    throw new Error(`failed_event_create_${payload.slug}`);
  }
};

const publishEvent = async (adminCookie: string, slug: string) => {
  const response = await postPublish(
    new Request(`http://localhost:3000/api/v1/events/${slug}/publish`, {
      method: "POST",
      headers: {
        origin: "http://localhost:3000",
        cookie: adminCookie,
      },
    }),
    { params: Promise.resolve({ slug }) },
  );

  if (response.status !== 200) {
    throw new Error(`failed_event_publish_${slug}`);
  }
};

const cancelEvent = async (adminCookie: string, slug: string, reason: string) => {
  const response = await postCancel(
    new Request(`http://localhost:3000/api/v1/events/${slug}/cancel`, {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
        cookie: adminCookie,
      },
      body: JSON.stringify({ reason }),
    }),
    { params: Promise.resolve({ slug }) },
  );

  if (response.status !== 200) {
    throw new Error(`failed_event_cancel_${slug}`);
  }
};

const registerForEvent = async (cookie: string, slug: string, userId: string) => {
  const response = await postRegistration(
    new Request(`http://localhost:3000/api/v1/events/${slug}/registrations`, {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
        cookie,
      },
      body: JSON.stringify({ user_id: userId }),
    }),
    { params: Promise.resolve({ slug }) },
  );

  if (response.status !== 200) {
    throw new Error(`failed_event_registration_${slug}`);
  }
};

export type StandardE2EFixture = {
  dbPath: string;
  adminCookie: string;
  userCookie: string;
  adminId: string;
  userId: string;
};

export const setupStandardE2EFixture = async (): Promise<StandardE2EFixture> => {
  const dbPath = await createDbPath();

  process.env.APPCTL_DB_FILE = dbPath;
  process.env.APPCTL_ENV = "local";

  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
  process.env.APPCTL_DB_FILE = dbPath;

  await registerUser("usera@example.com");
  await registerUser("admina@example.com");

  addAdminRole(dbPath, "admina@example.com");

  const userCookie = await login("usera@example.com");
  const adminCookie = await login("admina@example.com");

  await createEvent(adminCookie, {
    slug: "published-open",
    title: "Published Open",
    start: "2026-09-01T10:00:00.000Z",
    end: "2026-09-01T11:00:00.000Z",
    timezone: "UTC",
    capacity: 20,
  });

  await createEvent(adminCookie, {
    slug: "published-full",
    title: "Published Full",
    start: "2026-09-02T10:00:00.000Z",
    end: "2026-09-02T11:00:00.000Z",
    timezone: "UTC",
    capacity: 1,
  });

  await createEvent(adminCookie, {
    slug: "draft-event",
    title: "Draft Event",
    start: "2026-09-03T10:00:00.000Z",
    end: "2026-09-03T11:00:00.000Z",
    timezone: "UTC",
    capacity: 50,
  });

  await createEvent(adminCookie, {
    slug: "cancelled-event",
    title: "Cancelled Event",
    start: "2026-09-04T10:00:00.000Z",
    end: "2026-09-04T11:00:00.000Z",
    timezone: "UTC",
    capacity: 50,
  });

  await publishEvent(adminCookie, "published-open");
  await publishEvent(adminCookie, "published-full");
  await publishEvent(adminCookie, "cancelled-event");
  await cancelEvent(adminCookie, "cancelled-event", "Fixture cancellation");

  const userId = userIdByEmail(dbPath, "usera@example.com");
  const adminId = userIdByEmail(dbPath, "admina@example.com");

  await registerForEvent(userCookie, "published-open", userId);
  await registerForEvent(userCookie, "published-full", userId);

  return {
    dbPath,
    adminCookie,
    userCookie,
    adminId,
    userId,
  };
};

export const cleanupStandardE2EFixtures = async () => {
  delete process.env.APPCTL_DB_FILE;
  delete process.env.APPCTL_ENV;
  resetRateLimits();
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
};


===== FILE: src/app/account/page.tsx =====
"use client";

import Link from "next/link";
import { useEffect, useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { requestHal, type ProblemDetails } from "@/lib/hal-client";

type MeResponse = {
  id: string;
  email: string;
  status: string;
  roles: string[];
  _links: Record<string, { href: string }>;
};

type AccountRegistration = {
  registration_id: string;
  event_id: string;
  event_slug: string;
  event_title: string;
  status: string;
};

type AccountRegistrationsResponse = {
  count: number;
  items: AccountRegistration[];
};

export default function AccountPage() {
  const [me, setMe] = useState<MeResponse | null>(null);
  const [registrations, setRegistrations] = useState<AccountRegistration[]>([]);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);
  const [loading, setLoading] = useState(true);
  const [deleting, setDeleting] = useState(false);

  useEffect(() => {
    const load = async () => {
      setLoading(true);
      setProblem(null);

      const result = await requestHal<MeResponse>("/api/v1/me");
      if (!result.ok) {
        setProblem(result.problem);
        setLoading(false);
        return;
      }

      setMe(result.data);

      const history = await requestHal<AccountRegistrationsResponse>("/api/v1/account/registrations");
      if (history.ok) {
        setRegistrations(history.data.items ?? []);
      }

      setLoading(false);
    };

    void load();
  }, []);

  return (
    <main className="mx-auto max-w-2xl p-6">
      <h1 className="text-2xl font-semibold">Account</h1>
      {loading ? <p className="mt-2 text-sm">Loading account...</p> : null}

      {problem ? (
        <div className="mt-4 space-y-3">
          <ProblemDetailsPanel problem={problem} />
          {problem.status === 401 ? (
            <p className="text-sm">
              You are not logged in. <Link href="/login" className="underline">Go to login</Link>
            </p>
          ) : null}
        </div>
      ) : null}

      {me ? (
        <section className="mt-4 rounded border p-4">
          <p className="text-sm"><span className="font-medium">Email:</span> {me.email}</p>
          <p className="mt-1 text-sm"><span className="font-medium">Status:</span> {me.status}</p>
          <p className="mt-1 text-sm"><span className="font-medium">Roles:</span> {me.roles.join(", ")}</p>

          <div className="mt-3 text-sm">
            {me._links.events ? <Link href="/events" className="underline">Browse events</Link> : null}
          </div>
          <div className="mt-2 text-xs">
            <Link href="/terms" className="underline">Terms</Link>  <Link href="/privacy" className="underline">Privacy</Link>
          </div>

          <div className="mt-5">
            <h2 className="text-sm font-medium">My registrations ({registrations.length})</h2>
            <ul className="mt-2 space-y-2">
              {registrations.map((registration) => (
                <li key={registration.registration_id} className="rounded border p-2 text-sm">
                  <p className="font-medium">{registration.event_title}</p>
                  <p className="text-xs text-zinc-500">{registration.event_slug}</p>
                  <p className="text-xs">Status: {registration.status}</p>
                </li>
              ))}
              {registrations.length === 0 ? (
                <li className="text-xs text-zinc-500">No registrations yet.</li>
              ) : null}
            </ul>
          </div>

          <div className="mt-5 border-t pt-4">
            <button
              type="button"
              disabled={deleting}
              onClick={async () => {
                setDeleting(true);
                const result = await requestHal<{ deleted: true }>("/api/v1/account/delete", {
                  method: "POST",
                });
                if (!result.ok) {
                  setProblem(result.problem);
                  setDeleting(false);
                  return;
                }
                setDeleting(false);
                setMe(null);
                setRegistrations([]);
              }}
              className="rounded border px-3 py-2 text-sm"
            >
              {deleting ? "Deleting account..." : "Delete account"}
            </button>
          </div>
        </section>
      ) : null}
    </main>
  );
}


===== FILE: src/app/admin/audit/page.tsx =====
"use client";

import { useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { requestHal, type ProblemDetails } from "@/lib/hal-client";

type AuditItem = {
  id: string;
  action: string;
  actor_id: string | null;
  created_at: string;
  metadata: Record<string, unknown> | null;
  request_id: string;
};

type AuditResponse = {
  count: number;
  items: AuditItem[];
};

export default function AdminAuditPage() {
  const [action, setAction] = useState("");
  const [actorId, setActorId] = useState("");
  const [from, setFrom] = useState("");
  const [to, setTo] = useState("");
  const [items, setItems] = useState<AuditItem[]>([]);
  const [pending, setPending] = useState(false);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  const load = async () => {
    setPending(true);
    const params = new URLSearchParams({ limit: "50", offset: "0" });
    if (action.trim().length > 0) {
      params.set("action", action.trim());
    }
    if (actorId.trim().length > 0) {
      params.set("actor_id", actorId.trim());
    }
    if (from.trim().length > 0) {
      params.set("from", from.trim());
    }
    if (to.trim().length > 0) {
      params.set("to", to.trim());
    }

    const result = await requestHal<AuditResponse>(`/api/v1/audit?${params.toString()}`);
    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    setProblem(null);
    setItems(result.data.items ?? []);
    setPending(false);
  };

  return (
    <main className="mx-auto max-w-6xl p-6">
      <h1 className="text-2xl font-semibold">Admin Audit Log</h1>

      <section className="mt-4 rounded border p-4">
        <h2 className="text-sm font-medium">Filters</h2>
        <div className="mt-3 grid gap-2 md:grid-cols-2 lg:grid-cols-4">
          <input
            value={action}
            onChange={(event) => setAction(event.target.value)}
            placeholder="Action"
            className="rounded border px-3 py-2 text-sm"
          />
          <input
            value={actorId}
            onChange={(event) => setActorId(event.target.value)}
            placeholder="Actor ID"
            className="rounded border px-3 py-2 text-sm"
          />
          <input
            value={from}
            onChange={(event) => setFrom(event.target.value)}
            placeholder="From (ISO)"
            className="rounded border px-3 py-2 text-sm"
          />
          <input
            value={to}
            onChange={(event) => setTo(event.target.value)}
            placeholder="To (ISO)"
            className="rounded border px-3 py-2 text-sm"
          />
        </div>
        <button
          type="button"
          onClick={() => void load()}
          disabled={pending}
          className="mt-3 rounded border px-3 py-2 text-sm"
        >
          {pending ? "Loading..." : "Load audit entries"}
        </button>
      </section>

      {problem ? (
        <div className="mt-4">
          <ProblemDetailsPanel problem={problem} />
        </div>
      ) : null}

      <section className="mt-4 rounded border p-4">
        <h2 className="text-sm font-medium">Entries ({items.length})</h2>
        <div className="mt-3 overflow-x-auto">
          <table className="w-full text-left text-sm">
            <thead>
              <tr>
                <th className="pb-2">When</th>
                <th className="pb-2">Action</th>
                <th className="pb-2">Actor</th>
                <th className="pb-2">Metadata</th>
              </tr>
            </thead>
            <tbody>
              {items.map((item) => (
                <tr key={item.id} className="border-t align-top">
                  <td className="py-2">{item.created_at}</td>
                  <td className="py-2">{item.action}</td>
                  <td className="py-2">{item.actor_id ?? "-"}</td>
                  <td className="py-2">
                    <pre className="whitespace-pre-wrap break-all text-xs">
                      {JSON.stringify(item.metadata ?? {}, null, 2)}
                    </pre>
                  </td>
                </tr>
              ))}
              {items.length === 0 ? (
                <tr>
                  <td colSpan={4} className="py-3 text-sm text-zinc-500">
                    No audit entries loaded.
                  </td>
                </tr>
              ) : null}
            </tbody>
          </table>
        </div>
      </section>
    </main>
  );
}


===== FILE: src/app/admin/events/[slug]/export/page.tsx =====
"use client";

import { useParams } from "next/navigation";
import { useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { buildExportFileName } from "@/lib/admin-registration-view";
import type { ProblemDetails } from "@/lib/hal-client";

const parseProblem = async (response: Response): Promise<ProblemDetails> => {
  try {
    return (await response.json()) as ProblemDetails;
  } catch {
    return {
      type: "about:blank",
      title: "Request Failed",
      status: response.status,
      detail: "Failed to parse problem details response.",
    };
  }
};

export default function AdminEventExportPage() {
  const params = useParams<{ slug: string }>();
  const slug = params.slug;

  const [format, setFormat] = useState<"json" | "csv">("json");
  const [includeEmail, setIncludeEmail] = useState(false);
  const [pending, setPending] = useState(false);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);
  const [lastDownload, setLastDownload] = useState<string | null>(null);

  const onExport = async () => {
    if (!slug) {
      return;
    }

    setPending(true);
    setProblem(null);

    const query = new URLSearchParams({
      format,
      include_email: includeEmail ? "true" : "false",
    }).toString();

    const response = await fetch(`/api/v1/events/${slug}/export?${query}`, {
      credentials: "include",
      headers: {
        accept: "application/json, text/csv, application/problem+json",
      },
    });

    if (!response.ok) {
      setProblem(await parseProblem(response));
      setPending(false);
      return;
    }

    const fileName = buildExportFileName(slug, format);
    const blob = await response.blob();
    const url = URL.createObjectURL(blob);

    const anchor = document.createElement("a");
    anchor.href = url;
    anchor.download = fileName;
    anchor.click();
    URL.revokeObjectURL(url);

    setLastDownload(fileName);
    setPending(false);
  };

  return (
    <main className="mx-auto max-w-3xl p-6">
      <h1 className="text-2xl font-semibold">Event Export</h1>
      <p className="mt-1 text-sm">Event slug: {slug}</p>

      <section className="mt-4 rounded-md border p-4">
        <h2 className="text-sm font-medium">Export options</h2>

        <div className="mt-3 space-y-3">
          <label className="block text-sm">
            Format
            <select
              value={format}
              onChange={(event) => setFormat(event.target.value as "json" | "csv")}
              className="mt-1 w-full rounded border px-3 py-2"
            >
              <option value="json">JSON</option>
              <option value="csv">CSV</option>
            </select>
          </label>

          <label className="flex items-center gap-2 text-sm">
            <input
              type="checkbox"
              checked={includeEmail}
              onChange={(event) => setIncludeEmail(event.target.checked)}
            />
            Include email (subject to environment governance)
          </label>

          <button
            type="button"
            onClick={() => void onExport()}
            disabled={pending}
            className="rounded border px-3 py-2 text-sm"
          >
            {pending ? "Exporting..." : "Export"}
          </button>
        </div>

        {lastDownload ? <p className="mt-3 text-sm">Downloaded: {lastDownload}</p> : null}
      </section>

      {problem ? (
        <div className="mt-4">
          <ProblemDetailsPanel problem={problem} />
        </div>
      ) : null}
    </main>
  );
}


===== FILE: src/app/admin/events/[slug]/page.tsx =====
"use client";

import Link from "next/link";
import { useParams } from "next/navigation";
import { useEffect, useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { getEventActionHrefs } from "@/lib/admin-events-view";
import { requestHal, type ProblemDetails } from "@/lib/hal-client";

type EventDetail = {
  id: string;
  slug: string;
  title: string;
  status: string;
  start_at: string;
  end_at: string;
  timezone: string;
  capacity: number | null;
  _links: Record<string, { href: string }>;
};

export default function AdminEventDetailPage() {
  const params = useParams<{ slug: string }>();
  const slug = params.slug;

  const [event, setEvent] = useState<EventDetail | null>(null);
  const [pending, setPending] = useState(false);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  const [title, setTitle] = useState("");
  const [start, setStart] = useState("");
  const [end, setEnd] = useState("");
  const [capacity, setCapacity] = useState("");

  const load = async () => {
    if (!slug) {
      return;
    }

    const result = await requestHal<EventDetail>(`/api/v1/events/${slug}`);
    if (!result.ok) {
      setProblem(result.problem);
      return;
    }

    setProblem(null);
    setEvent(result.data);
    setTitle(result.data.title);
    setStart(result.data.start_at);
    setEnd(result.data.end_at);
    setCapacity(result.data.capacity === null ? "" : String(result.data.capacity));
  };

  useEffect(() => {
    if (!slug) {
      return;
    }

    void (async () => {
      const result = await requestHal<EventDetail>(`/api/v1/events/${slug}`);
      if (!result.ok) {
        setProblem(result.problem);
        return;
      }

      setProblem(null);
      setEvent(result.data);
      setTitle(result.data.title);
      setStart(result.data.start_at);
      setEnd(result.data.end_at);
      setCapacity(result.data.capacity === null ? "" : String(result.data.capacity));
    })();
  }, [slug]);

  const onSave = async () => {
    if (!slug) {
      return;
    }

    setPending(true);
    setProblem(null);

    const result = await requestHal<unknown>(`/api/v1/events/${slug}`, {
      method: "PATCH",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify({
        title,
        start,
        end,
        capacity: capacity.trim().length ? Number(capacity) : undefined,
      }),
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    await load();
    setPending(false);
  };

  const onAction = async (href: string, body?: Record<string, unknown>) => {
    setPending(true);
    setProblem(null);

    const result = await requestHal<unknown>(href, {
      method: "POST",
      headers: {
        "content-type": "application/json",
      },
      body: body ? JSON.stringify(body) : undefined,
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    await load();
    setPending(false);
  };

  const actions = event ? getEventActionHrefs(event) : { publish: null, cancel: null };

  return (
    <main className="mx-auto max-w-5xl p-6">
      <h1 className="text-2xl font-semibold">Event Detail</h1>
      <p className="mt-1 text-sm">Event slug: {slug}</p>

      {problem ? (
        <div className="mt-4">
          <ProblemDetailsPanel problem={problem} />
        </div>
      ) : null}

      {event ? (
        <>
          <section className="mt-4 rounded-md border p-4">
            <h2 className="text-sm font-medium">Edit event</h2>
            <div className="mt-3 grid gap-2 md:grid-cols-2">
              <input value={title} onChange={(e) => setTitle(e.target.value)} className="rounded border px-3 py-2 text-sm" />
              <input value={capacity} onChange={(e) => setCapacity(e.target.value)} className="rounded border px-3 py-2 text-sm" placeholder="Capacity" />
              <input value={start} onChange={(e) => setStart(e.target.value)} className="rounded border px-3 py-2 text-sm" placeholder="Start ISO" />
              <input value={end} onChange={(e) => setEnd(e.target.value)} className="rounded border px-3 py-2 text-sm" placeholder="End ISO" />
            </div>

            <button
              type="button"
              onClick={() => void onSave()}
              disabled={pending}
              className="mt-3 rounded border px-3 py-2 text-sm"
            >
              {pending ? "Saving..." : "Save changes"}
            </button>
          </section>

          <section className="mt-4 rounded-md border p-4">
            <h2 className="text-sm font-medium">Lifecycle actions</h2>
            <div className="mt-3 flex gap-2">
              {actions.publish ? (
                <button
                  type="button"
                  className="rounded border px-3 py-2 text-sm"
                  disabled={pending}
                  onClick={() => void onAction(actions.publish!)}
                >
                  Publish
                </button>
              ) : null}

              {actions.cancel ? (
                <button
                  type="button"
                  className="rounded border px-3 py-2 text-sm"
                  disabled={pending}
                  onClick={() => void onAction(actions.cancel!, { reason: "Cancelled via admin console" })}
                >
                  Cancel
                </button>
              ) : null}

              {!actions.publish && !actions.cancel ? (
                <p className="text-sm text-zinc-500">No lifecycle actions available in current state.</p>
              ) : null}
            </div>
          </section>

          <section className="mt-4 rounded-md border p-4">
            <h2 className="text-sm font-medium">Related admin tools</h2>
            <div className="mt-2 flex gap-3 text-sm">
              <Link className="underline" href={`/admin/events/${event.slug}/registrations`}>
                Registrations
              </Link>
              <Link className="underline" href={`/admin/events/${event.slug}/export`}>
                Export
              </Link>
            </div>
          </section>
        </>
      ) : null}
    </main>
  );
}


===== FILE: src/app/admin/events/[slug]/registrations/page.tsx =====
"use client";

import { useParams } from "next/navigation";
import { useEffect, useMemo, useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import {
  buildRegistrationPayload,
  canCancel,
  canCheckIn,
  type RegistrationStatus,
} from "@/lib/admin-registration-view";
import { requestHal, type ProblemDetails } from "@/lib/hal-client";

type RegistrationItem = {
  id: string;
  user_id: string;
  user_email: string;
  status: RegistrationStatus;
};

type RegistrationsResponse = {
  count: number;
  items: RegistrationItem[];
};

export default function AdminEventRegistrationsPage() {
  const params = useParams<{ slug: string }>();
  const slug = params.slug;

  const [registrations, setRegistrations] = useState<RegistrationItem[]>([]);
  const [identifier, setIdentifier] = useState("");
  const [pending, setPending] = useState(false);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  const registrationsHref = useMemo(() => {
    if (!slug) {
      return null;
    }
    return `/api/v1/events/${slug}/registrations`;
  }, [slug]);

  const loadRegistrations = async () => {
    if (!registrationsHref) {
      return;
    }

    setProblem(null);
    const result = await requestHal<RegistrationsResponse>(registrationsHref);
    if (!result.ok) {
      setProblem(result.problem);
      return;
    }

    setRegistrations(result.data.items ?? []);
  };

  useEffect(() => {
    if (!registrationsHref) {
      return;
    }

    let cancelled = false;

    void requestHal<RegistrationsResponse>(registrationsHref).then((result) => {
      if (cancelled) {
        return;
      }

      if (!result.ok) {
        setProblem(result.problem);
        return;
      }

      setRegistrations(result.data.items ?? []);
    });

    return () => {
      cancelled = true;
    };
  }, [registrationsHref]);

  const addRegistration = async () => {
    if (!registrationsHref) {
      return;
    }

    const payload = buildRegistrationPayload(identifier);
    if (!payload.user_email && !payload.user_id) {
      return;
    }

    setPending(true);
    setProblem(null);

    const result = await requestHal<unknown>(registrationsHref, {
      method: "POST",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify(payload),
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    setIdentifier("");
    await loadRegistrations();
    setPending(false);
  };

  const cancelRegistration = async (userId: string) => {
    if (!slug) {
      return;
    }

    setPending(true);
    setProblem(null);
    const result = await requestHal<unknown>(`/api/v1/events/${slug}/registrations/${userId}`, {
      method: "DELETE",
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    await loadRegistrations();
    setPending(false);
  };

  const checkInRegistration = async (userId: string) => {
    if (!slug) {
      return;
    }

    setPending(true);
    setProblem(null);
    const result = await requestHal<unknown>(`/api/v1/events/${slug}/checkins`, {
      method: "POST",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify({ user_id: userId }),
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    await loadRegistrations();
    setPending(false);
  };

  return (
    <main className="mx-auto max-w-5xl p-6">
      <h1 className="text-2xl font-semibold">Event Registrations</h1>
      <p className="mt-1 text-sm">Event slug: {slug}</p>

      <section className="mt-4 rounded-md border p-4">
        <h2 className="text-sm font-medium">Add registration</h2>
        <div className="mt-2 flex gap-2">
          <input
            value={identifier}
            onChange={(event) => setIdentifier(event.target.value)}
            placeholder="User ID or email"
            className="w-full rounded border px-3 py-2 text-sm"
          />
          <button
            type="button"
            onClick={() => void addRegistration()}
            disabled={pending}
            className="rounded border px-3 py-2 text-sm"
          >
            {pending ? "Working..." : "Add"}
          </button>
        </div>
      </section>

      {problem ? (
        <div className="mt-4">
          <ProblemDetailsPanel problem={problem} />
        </div>
      ) : null}

      <section className="mt-4 rounded-md border p-4">
        <h2 className="text-sm font-medium">Registrations ({registrations.length})</h2>
        <div className="mt-3 overflow-x-auto">
          <table className="w-full text-left text-sm">
            <thead>
              <tr>
                <th className="pb-2">User</th>
                <th className="pb-2">Status</th>
                <th className="pb-2">Actions</th>
              </tr>
            </thead>
            <tbody>
              {registrations.map((registration) => (
                <tr key={registration.id} className="border-t">
                  <td className="py-2">
                    <p>{registration.user_email}</p>
                    <p className="text-xs text-zinc-500">{registration.user_id}</p>
                  </td>
                  <td className="py-2">{registration.status}</td>
                  <td className="py-2">
                    <div className="flex gap-2">
                      <button
                        type="button"
                        className="rounded border px-2 py-1 text-xs"
                        disabled={pending || !canCheckIn(registration.status)}
                        onClick={() => void checkInRegistration(registration.user_id)}
                      >
                        Check-in
                      </button>
                      <button
                        type="button"
                        className="rounded border px-2 py-1 text-xs"
                        disabled={pending || !canCancel(registration.status)}
                        onClick={() => void cancelRegistration(registration.user_id)}
                      >
                        Cancel
                      </button>
                    </div>
                  </td>
                </tr>
              ))}
              {registrations.length === 0 ? (
                <tr>
                  <td colSpan={3} className="py-3 text-sm text-zinc-500">
                    No registrations yet.
                  </td>
                </tr>
              ) : null}
            </tbody>
          </table>
        </div>
      </section>
    </main>
  );
}


===== FILE: src/app/admin/events/page.tsx =====
"use client";

import Link from "next/link";
import { useEffect, useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { toEventCreatePayload } from "@/lib/admin-events-view";
import { requestHal, type ProblemDetails } from "@/lib/hal-client";

type EventItem = {
  id: string;
  slug: string;
  title: string;
  status: string;
};

type EventsResponse = {
  count: number;
  items: EventItem[];
};

export default function AdminEventsPage() {
  const [events, setEvents] = useState<EventItem[]>([]);
  const [pending, setPending] = useState(false);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  const [form, setForm] = useState({
    slug: "",
    title: "",
    start: "",
    end: "",
    timezone: "UTC",
    capacity: "",
  });

  const load = async () => {
    const result = await requestHal<EventsResponse>("/api/v1/events");
    if (!result.ok) {
      setProblem(result.problem);
      return;
    }

    setProblem(null);
    setEvents(result.data.items ?? []);
  };

  useEffect(() => {
    void (async () => {
      const result = await requestHal<EventsResponse>("/api/v1/events");
      if (!result.ok) {
        setProblem(result.problem);
        return;
      }

      setProblem(null);
      setEvents(result.data.items ?? []);
    })();
  }, []);

  const onCreate = async () => {
    setPending(true);
    setProblem(null);

    const result = await requestHal<unknown>("/api/v1/events", {
      method: "POST",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify(toEventCreatePayload(form)),
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    setForm({
      slug: "",
      title: "",
      start: "",
      end: "",
      timezone: "UTC",
      capacity: "",
    });
    await load();
    setPending(false);
  };

  return (
    <main className="mx-auto max-w-5xl p-6">
      <h1 className="text-2xl font-semibold">Admin Events</h1>

      <section className="mt-4 rounded-md border p-4">
        <h2 className="text-sm font-medium">Create event</h2>
        <div className="mt-3 grid gap-2 md:grid-cols-2">
          <input
            placeholder="Slug"
            value={form.slug}
            onChange={(event) => setForm((prev) => ({ ...prev, slug: event.target.value }))}
            className="rounded border px-3 py-2 text-sm"
          />
          <input
            placeholder="Title"
            value={form.title}
            onChange={(event) => setForm((prev) => ({ ...prev, title: event.target.value }))}
            className="rounded border px-3 py-2 text-sm"
          />
          <input
            placeholder="Start ISO"
            value={form.start}
            onChange={(event) => setForm((prev) => ({ ...prev, start: event.target.value }))}
            className="rounded border px-3 py-2 text-sm"
          />
          <input
            placeholder="End ISO"
            value={form.end}
            onChange={(event) => setForm((prev) => ({ ...prev, end: event.target.value }))}
            className="rounded border px-3 py-2 text-sm"
          />
          <input
            placeholder="Timezone"
            value={form.timezone}
            onChange={(event) => setForm((prev) => ({ ...prev, timezone: event.target.value }))}
            className="rounded border px-3 py-2 text-sm"
          />
          <input
            placeholder="Capacity (optional)"
            value={form.capacity}
            onChange={(event) => setForm((prev) => ({ ...prev, capacity: event.target.value }))}
            className="rounded border px-3 py-2 text-sm"
          />
        </div>

        <button
          type="button"
          onClick={() => void onCreate()}
          disabled={pending}
          className="mt-3 rounded border px-3 py-2 text-sm"
        >
          {pending ? "Creating..." : "Create event"}
        </button>
      </section>

      {problem ? (
        <div className="mt-4">
          <ProblemDetailsPanel problem={problem} />
        </div>
      ) : null}

      <section className="mt-4 rounded-md border p-4">
        <h2 className="text-sm font-medium">Events ({events.length})</h2>
        <ul className="mt-3 space-y-2">
          {events.map((event) => (
            <li key={event.id} className="rounded border p-3">
              <div className="flex items-center justify-between">
                <div>
                  <p className="font-medium">{event.title}</p>
                  <p className="text-xs text-zinc-500">{event.slug}  {event.status}</p>
                </div>
                <Link className="text-sm underline" href={`/admin/events/${event.slug}`}>
                  Manage
                </Link>
              </div>
            </li>
          ))}
        </ul>
      </section>
    </main>
  );
}


===== FILE: src/app/admin/layout.tsx =====
"use client";

import { useEffect, useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { requestHal, type HalResource, type ProblemDetails } from "@/lib/hal-client";
import { adminAccessProblem, canAccessAdminFromMe } from "@/lib/ui-access";

export default function AdminLayout({ children }: { children: React.ReactNode }) {
  const [loading, setLoading] = useState(true);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  useEffect(() => {
    const load = async () => {
      setLoading(true);
      const me = await requestHal<HalResource>("/api/v1/me");

      if (!me.ok) {
        setProblem(me.problem);
        setLoading(false);
        return;
      }

      if (!canAccessAdminFromMe(me.data)) {
        setProblem(adminAccessProblem);
        setLoading(false);
        return;
      }

      setProblem(null);
      setLoading(false);
    };

    void load();
  }, []);

  if (loading) {
    return <main className="mx-auto max-w-4xl p-6 text-sm">Checking admin access...</main>;
  }

  if (problem) {
    return (
      <main className="mx-auto max-w-4xl p-6">
        <ProblemDetailsPanel problem={problem} />
      </main>
    );
  }

  return <>{children}</>;
}


===== FILE: src/app/admin/page.tsx =====
export default function AdminHomePage() {
  return (
    <main className="mx-auto max-w-4xl p-6">
      <h1 className="text-2xl font-semibold">Admin Console</h1>
      <p className="mt-2 text-sm">Protected admin area scaffolded in Sprint 13.</p>
      <ul className="mt-4 list-disc pl-5 text-sm">
        <li>
          <a href="/admin/audit" className="underline">
            Open audit log viewer
          </a>
        </li>
      </ul>
    </main>
  );
}


===== FILE: src/app/admin/users/page.tsx =====
"use client";

import { useMemo, useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import {
  buildUsersListHref,
  canAddRole,
  canRemoveRole,
  MUTABLE_ROLES,
  normalizeRoles,
} from "@/lib/admin-users-ui";
import { requestHal, type ProblemDetails } from "@/lib/hal-client";

type UserSummary = {
  id: string;
  email: string;
  status: "ACTIVE" | "DISABLED" | "PENDING";
  roles: string[];
};

type UsersResponse = {
  count: number;
  items: UserSummary[];
};

type UserDetail = UserSummary & {
  _links: Record<string, { href: string }>;
};

export default function AdminUsersPage() {
  const [search, setSearch] = useState("");
  const [status, setStatus] = useState("");
  const [role, setRole] = useState("");

  const [users, setUsers] = useState<UserSummary[]>([]);
  const [selectedUser, setSelectedUser] = useState<UserDetail | null>(null);
  const [pending, setPending] = useState(false);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  const usersHref = useMemo(() => buildUsersListHref({ search, status, role }), [search, status, role]);

  const loadUsers = async () => {
    setPending(true);
    const listResult = await requestHal<UsersResponse>(usersHref);
    if (!listResult.ok) {
      setProblem(listResult.problem);
      setPending(false);
      return;
    }

    setProblem(null);
    setUsers(listResult.data.items ?? []);
    setPending(false);
  };

  const loadUserDetail = async (userId: string) => {
    setPending(true);
    const detailResult = await requestHal<UserDetail>(`/api/v1/users/${userId}`);
    if (!detailResult.ok) {
      setProblem(detailResult.problem);
      setPending(false);
      return;
    }

    setProblem(null);
    setSelectedUser(detailResult.data);
    setPending(false);
  };

  const updateStatus = async (nextStatus: UserSummary["status"]) => {
    if (!selectedUser) {
      return;
    }

    setPending(true);
    const result = await requestHal<unknown>(`/api/v1/users/${selectedUser.id}`, {
      method: "PATCH",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify({ status: nextStatus }),
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    await loadUsers();
    await loadUserDetail(selectedUser.id);
    setPending(false);
  };

  const addRole = async (nextRole: string) => {
    if (!selectedUser) {
      return;
    }

    setPending(true);
    const result = await requestHal<unknown>(`/api/v1/users/${selectedUser.id}/roles`, {
      method: "POST",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify({ role: nextRole }),
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    await loadUserDetail(selectedUser.id);
    setPending(false);
  };

  const removeRole = async (targetRole: string) => {
    if (!selectedUser) {
      return;
    }

    setPending(true);
    const result = await requestHal<unknown>(`/api/v1/users/${selectedUser.id}/roles/${targetRole}`, {
      method: "DELETE",
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    await loadUserDetail(selectedUser.id);
    setPending(false);
  };

  const selectedRoles = selectedUser ? normalizeRoles(selectedUser.roles) : [];

  return (
    <main className="mx-auto max-w-5xl p-6">
      <h1 className="text-2xl font-semibold">Admin Users</h1>

      <section className="mt-4 rounded-md border p-4">
        <h2 className="text-sm font-medium">Search and filters</h2>
        <div className="mt-3 grid gap-2 md:grid-cols-3">
          <input
            value={search}
            onChange={(event) => setSearch(event.target.value)}
            placeholder="Search by email"
            className="rounded border px-3 py-2 text-sm"
          />
          <select
            value={status}
            onChange={(event) => setStatus(event.target.value)}
            className="rounded border px-3 py-2 text-sm"
          >
            <option value="">All statuses</option>
            <option value="ACTIVE">ACTIVE</option>
            <option value="DISABLED">DISABLED</option>
            <option value="PENDING">PENDING</option>
          </select>
          <select
            value={role}
            onChange={(event) => setRole(event.target.value)}
            className="rounded border px-3 py-2 text-sm"
          >
            <option value="">All roles</option>
            <option value="USER">USER</option>
            <option value="ADMIN">ADMIN</option>
            <option value="SUPER_ADMIN">SUPER_ADMIN</option>
          </select>
        </div>
        <button
          type="button"
          onClick={() => void loadUsers()}
          disabled={pending}
          className="mt-3 rounded border px-3 py-2 text-sm"
        >
          {pending ? "Loading..." : "Load users"}
        </button>
      </section>

      {problem ? (
        <div className="mt-4">
          <ProblemDetailsPanel problem={problem} />
        </div>
      ) : null}

      <section className="mt-4 rounded-md border p-4">
        <h2 className="text-sm font-medium">Users ({users.length})</h2>
        <div className="mt-3 overflow-x-auto">
          <table className="w-full text-left text-sm">
            <thead>
              <tr>
                <th className="pb-2">Email</th>
                <th className="pb-2">Status</th>
                <th className="pb-2">Roles</th>
                <th className="pb-2">Actions</th>
              </tr>
            </thead>
            <tbody>
              {users.map((user) => (
                <tr key={user.id} className="border-t">
                  <td className="py-2">{user.email}</td>
                  <td className="py-2">{user.status}</td>
                  <td className="py-2">{normalizeRoles(user.roles).join(", ")}</td>
                  <td className="py-2">
                    <button
                      type="button"
                      className="rounded border px-2 py-1 text-xs"
                      onClick={() => void loadUserDetail(user.id)}
                      disabled={pending}
                    >
                      Manage
                    </button>
                  </td>
                </tr>
              ))}
              {users.length === 0 ? (
                <tr>
                  <td colSpan={4} className="py-3 text-sm text-zinc-500">
                    No users loaded.
                  </td>
                </tr>
              ) : null}
            </tbody>
          </table>
        </div>
      </section>

      {selectedUser ? (
        <section className="mt-4 rounded-md border p-4">
          <h2 className="text-sm font-medium">User detail</h2>
          <p className="mt-1 text-sm">{selectedUser.email}</p>
          <p className="text-xs text-zinc-500">{selectedUser.id}</p>

          <div className="mt-3">
            <p className="text-sm font-medium">Status</p>
            <div className="mt-2 flex gap-2">
              {(["ACTIVE", "DISABLED", "PENDING"] as const).map((nextStatus) => (
                <button
                  key={nextStatus}
                  type="button"
                  disabled={pending || selectedUser.status === nextStatus}
                  onClick={() => void updateStatus(nextStatus)}
                  className="rounded border px-2 py-1 text-xs"
                >
                  Set {nextStatus}
                </button>
              ))}
            </div>
          </div>

          <div className="mt-4">
            <p className="text-sm font-medium">Roles</p>
            <p className="mt-1 text-xs text-zinc-500">SUPER_ADMIN role mutations are intentionally hidden.</p>
            <div className="mt-2 flex gap-2">
              {selectedRoles.map((existingRole) => (
                <span key={existingRole} className="rounded border px-2 py-1 text-xs">
                  {existingRole}
                </span>
              ))}
            </div>
            <div className="mt-3 flex gap-2">
              {MUTABLE_ROLES.map((mutableRole) => (
                <button
                  key={`add-${mutableRole}`}
                  type="button"
                  disabled={pending || !canAddRole(selectedRoles, mutableRole)}
                  onClick={() => void addRole(mutableRole)}
                  className="rounded border px-2 py-1 text-xs"
                >
                  Add {mutableRole}
                </button>
              ))}
              {MUTABLE_ROLES.map((mutableRole) => (
                <button
                  key={`remove-${mutableRole}`}
                  type="button"
                  disabled={pending || !canRemoveRole(selectedRoles, mutableRole)}
                  onClick={() => void removeRole(mutableRole)}
                  className="rounded border px-2 py-1 text-xs"
                >
                  Remove {mutableRole}
                </button>
              ))}
            </div>
          </div>
        </section>
      ) : null}
    </main>
  );
}


===== FILE: src/app/api/v1/__tests__/hardening.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";

import { POST as postRegister } from "../auth/register/route";
import { POST as postLogin } from "../auth/login/route";
import { GET as getUsers } from "../users/route";
import { GET as getExport } from "../events/[slug]/export/route";
import { POST as postEvents } from "../events/route";
import { POST as postRegistration } from "../events/[slug]/registrations/route";
import { runCli } from "../../../../cli/run-cli";
import { CliIo } from "../../../../cli/types";

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-api-hardening-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const runWithDb = async (argv: string[], dbPath: string): Promise<number> => {
  const { io } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return exitCode;
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

afterEach(async () => {
  delete process.env.APPCTL_DB_FILE;
  delete process.env.APPCTL_ENV;
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("api hardening", () => {
  it("applies rate limit to register/login/export endpoints", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    for (let index = 0; index < 5; index += 1) {
      const registerResponse = await postRegister(
        new Request("http://localhost:3000/api/v1/auth/register", {
          method: "POST",
          headers: {
            "content-type": "application/json",
            origin: "http://localhost:3000",
            "x-forwarded-for": "10.0.0.1",
          },
          body: JSON.stringify({
            email: `limit${index}@example.com`,
            password: "Password123!",
          }),
        }),
      );
      expect(registerResponse.status).toBe(201);
    }

    const blockedRegister = await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "10.0.0.1",
        },
        body: JSON.stringify({
          email: "limit-block@example.com",
          password: "Password123!",
        }),
      }),
    );
    expect(blockedRegister.status).toBe(429);

    const loginAllowed = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "10.0.0.2",
        },
        body: JSON.stringify({
          email: "limit0@example.com",
          password: "Password123!",
        }),
      }),
    );
    expect(loginAllowed.status).toBe(200);

    for (let index = 0; index < 4; index += 1) {
      await postLogin(
        new Request("http://localhost:3000/api/v1/auth/login", {
          method: "POST",
          headers: {
            "content-type": "application/json",
            origin: "http://localhost:3000",
            "x-forwarded-for": "10.0.0.2",
          },
          body: JSON.stringify({
            email: "limit0@example.com",
            password: "Password123!",
          }),
        }),
      );
    }

    const blockedLogin = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "10.0.0.2",
        },
        body: JSON.stringify({
          email: "limit0@example.com",
          password: "Password123!",
        }),
      }),
    );
    expect(blockedLogin.status).toBe(429);
  });

  it("sets no-store cache headers on auth and users endpoints", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const register = await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "cache-admin@example.com",
          password: "Password123!",
        }),
      }),
    );
    expect(register.headers.get("cache-control")).toBe("no-store");

    const db = new Database(dbPath);
    const user = db.prepare("SELECT id FROM users WHERE email = 'cache-admin@example.com'").get() as { id: string };
    const role = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
    db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(user.id, role.id);
    db.close();

    const login = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "cache-admin@example.com",
          password: "Password123!",
        }),
      }),
    );

    const cookie = (login.headers.get("set-cookie") ?? "").split(";")[0];
    const users = await getUsers(
      new Request("http://localhost:3000/api/v1/users", {
        headers: { cookie },
      }),
    );

    expect(login.headers.get("cache-control")).toBe("no-store");
    expect(users.headers.get("cache-control")).toBe("no-store");
  });

  it("rate limits export endpoint independently", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "export-limit-admin@example.com",
          password: "Password123!",
        }),
      }),
    );

    const db = new Database(dbPath);
    const admin = db
      .prepare("SELECT id FROM users WHERE email = 'export-limit-admin@example.com'")
      .get() as { id: string };
    const adminRole = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
    db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(admin.id, adminRole.id);
    db.close();

    const login = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "export-limit-admin@example.com",
          password: "Password123!",
        }),
      }),
    );
    const cookie = (login.headers.get("set-cookie") ?? "").split(";")[0];

    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "export-limit-user@example.com",
          password: "Password123!",
        }),
      }),
    );

    await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie,
        },
        body: JSON.stringify({
          slug: "rate-export-event",
          title: "Rate Export Event",
          start: "2026-05-01T10:00:00.000Z",
          end: "2026-05-01T11:00:00.000Z",
          timezone: "UTC",
        }),
      }),
    );

    const dbAfter = new Database(dbPath);
    const user = dbAfter
      .prepare("SELECT id FROM users WHERE email = 'export-limit-user@example.com'")
      .get() as { id: string };
    dbAfter.close();

    await postRegistration(
      new Request("http://localhost:3000/api/v1/events/rate-export-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie,
        },
        body: JSON.stringify({ user_id: user.id }),
      }),
      { params: Promise.resolve({ slug: "rate-export-event" }) },
    );

    for (let index = 0; index < 5; index += 1) {
      const allowed = await getExport(
        new Request("http://localhost:3000/api/v1/events/rate-export-event/export?format=json", {
          headers: {
            cookie,
            "x-forwarded-for": "10.0.0.3",
          },
        }),
        { params: Promise.resolve({ slug: "rate-export-event" }) },
      );
      expect(allowed.status).toBe(200);
    }

    const blocked = await getExport(
      new Request("http://localhost:3000/api/v1/events/rate-export-event/export?format=json", {
        headers: {
          cookie,
          "x-forwarded-for": "10.0.0.3",
        },
      }),
      { params: Promise.resolve({ slug: "rate-export-event" }) },
    );

    expect(blocked.status).toBe(429);
  });
});


===== FILE: src/app/api/v1/account/delete/route.ts =====
import { deleteOwnAccount, getSessionUserFromRequest, isSameOriginMutation } from "../../../../../lib/api/auth";
import { hal, problem } from "../../../../../lib/api/response";

export async function POST(request: Request) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const user = getSessionUserFromRequest(request);
  if (!user) {
    return problem(
      {
        type: "https://lms-219.dev/problems/unauthorized",
        title: "Unauthorized",
        status: 401,
        detail: "Active session required.",
      },
      request,
    );
  }

  try {
    const result = deleteOwnAccount(user.id, crypto.randomUUID());
    return hal(
      result,
      {
        self: { href: "/api/v1/account/delete" },
        register: { href: "/api/v1/auth/register" },
      },
      {
        headers: {
          "cache-control": "no-store",
        },
      },
    );
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to process account deletion.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/account/registrations/route.ts =====
import { getSessionUserFromRequest } from "../../../../../lib/api/auth";
import { listRegistrationsForUser } from "../../../../../lib/api/registrations";
import { hal, problem } from "../../../../../lib/api/response";

export async function GET(request: Request) {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return problem(
      {
        type: "https://lms-219.dev/problems/unauthorized",
        title: "Unauthorized",
        status: 401,
        detail: "Active session required.",
      },
      request,
    );
  }

  try {
    const items = listRegistrationsForUser(user.id);
    return hal(
      {
        count: items.length,
        items,
      },
      {
        self: { href: "/api/v1/account/registrations" },
        me: { href: "/api/v1/me" },
      },
      {
        headers: {
          "cache-control": "no-store",
        },
      },
    );
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to load account registrations.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/admin/invitations/accept/route.ts =====
import { acceptAdminInvitation } from "../../../../../../lib/api/invitations";
import { hal, problem } from "../../../../../../lib/api/response";
import { isSameOriginMutation } from "../../../../../../lib/api/auth";

type Payload = {
  token?: string;
  password?: string;
};

export async function POST(request: Request) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  let payload: Payload;
  try {
    payload = (await request.json()) as Payload;
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.token || !payload.password) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "token and password are required.",
      },
      request,
    );
  }

  try {
    const accepted = await acceptAdminInvitation(payload.token, payload.password, crypto.randomUUID());

    return hal(
      {
        id: accepted.id,
        email: accepted.email,
        role: accepted.role,
      },
      {
        self: { href: "/api/v1/admin/invitations/accept" },
        login: { href: "/api/v1/auth/login" },
      },
    );
  } catch (error) {
    if (error instanceof Error && error.message === "invalid_payload") {
      return problem(
        {
          type: "https://lms-219.dev/problems/invalid-input",
          title: "Bad Request",
          status: 400,
          detail: "token and password are required.",
        },
        request,
      );
    }

    if (error instanceof Error && error.message === "invite_not_found") {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Invitation not found.",
        },
        request,
      );
    }

    if (error instanceof Error && error.message === "invite_expired") {
      return problem(
        {
          type: "https://lms-219.dev/problems/precondition-failed",
          title: "Precondition Failed",
          status: 412,
          detail: "Invitation is expired.",
        },
        request,
      );
    }

    if (error instanceof Error && (error.message === "invite_used" || error.message === "existing_account")) {
      return problem(
        {
          type: "https://lms-219.dev/problems/conflict",
          title: "Conflict",
          status: 409,
          detail: "Invitation cannot be accepted.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to accept invitation.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/admin/invitations/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../lib/api/auth";
import { createAdminInvitation } from "../../../../../lib/api/invitations";
import { hal, problem } from "../../../../../lib/api/response";

type Payload = {
  email?: string;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function POST(request: Request) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  let payload: Payload;
  try {
    payload = (await request.json()) as Payload;
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.email) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "email is required.",
      },
      request,
    );
  }

  try {
    const created = createAdminInvitation(payload.email, auth.user.id, crypto.randomUUID());

    return hal(
      {
        email: created.email,
        role: created.role,
        ...(created.token ? { invitation_token: created.token } : {}),
      },
      {
        self: { href: "/api/v1/admin/invitations" },
        accept: { href: "/api/v1/admin/invitations/accept" },
      },
      {
        status: 201,
      },
    );
  } catch (error) {
    if (error instanceof Error && error.message === "invalid_email") {
      return problem(
        {
          type: "https://lms-219.dev/problems/invalid-input",
          title: "Bad Request",
          status: 400,
          detail: "email is required.",
        },
        request,
      );
    }

    if (error instanceof Error && error.message === "existing_account") {
      return problem(
        {
          type: "https://lms-219.dev/problems/conflict",
          title: "Conflict",
          status: 409,
          detail: "Email already belongs to an account.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to create admin invitation.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/audit/route.ts =====
import { getSessionUserFromRequest } from "../../../../lib/api/auth";
import { listAuditEntries } from "../../../../lib/api/audit";
import { hal, problem } from "../../../../lib/api/response";

export async function GET(request: Request) {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return problem(
      {
        type: "https://lms-219.dev/problems/unauthorized",
        title: "Unauthorized",
        status: 401,
        detail: "Active session required.",
      },
      request,
    );
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return problem(
      {
        type: "https://lms-219.dev/problems/forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Admin role required.",
      },
      request,
    );
  }

  const { searchParams } = new URL(request.url);
  const action = searchParams.get("action") ?? undefined;
  const actor_id = searchParams.get("actor_id") ?? undefined;
  const from = searchParams.get("from") ?? undefined;
  const to = searchParams.get("to") ?? undefined;
  const limit = searchParams.get("limit");
  const offset = searchParams.get("offset");

  try {
    const result = listAuditEntries({
      action,
      actor_id,
      from,
      to,
      limit: limit ? Number(limit) : undefined,
      offset: offset ? Number(offset) : undefined,
    });

    return hal(
      {
        count: result.count,
        limit: result.limit,
        offset: result.offset,
        items: result.items,
      },
      {
        self: { href: "/api/v1/audit" },
      },
      {
        headers: {
          "cache-control": "no-store",
        },
      },
    );
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to load audit log.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/auth/__tests__/auth-session.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";

import { GET as getMe } from "../../me/route";
import { POST as postLogin } from "../login/route";
import { POST as postLogout } from "../logout/route";
import { POST as postRegister } from "../register/route";
import { runCli } from "../../../../../cli/run-cli";
import { CliIo } from "../../../../../cli/types";

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-api-auth-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const runWithDb = async (argv: string[], dbPath: string): Promise<number> => {
  const { io } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return exitCode;
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

afterEach(async () => {
  delete process.env.APPCTL_DB_FILE;
  delete process.env.APPCTL_ENV;
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("api/v1 auth/session", () => {
  it("registers user and logs in with secure session cookie semantics", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const registerResponse = await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "sprint8@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(registerResponse.status).toBe(201);

    const loginResponse = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "sprint8@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(loginResponse.status).toBe(200);
    const setCookie = loginResponse.headers.get("set-cookie") ?? "";
    expect(setCookie).toContain("lms_session=");
    expect(setCookie).toContain("HttpOnly");
    expect(setCookie).toContain("SameSite=Lax");
    expect(setCookie).not.toContain("Secure");
  });

  it("sets Secure cookie in prod", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "prod";

    await postRegister(
      new Request("https://example.com/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "https://example.com",
        },
        body: JSON.stringify({
          email: "prod@example.com",
          password: "Password123!",
        }),
      }),
    );

    const loginResponse = await postLogin(
      new Request("https://example.com/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "https://example.com",
        },
        body: JSON.stringify({
          email: "prod@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(loginResponse.status).toBe(200);
    expect(loginResponse.headers.get("set-cookie")).toContain("Secure");
  });

  it("returns me profile with role-aware links from active session", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "adminish@example.com",
          password: "Password123!",
        }),
      }),
    );

    const db = new Database(dbPath);
    const user = db
      .prepare("SELECT id FROM users WHERE email = ?")
      .get("adminish@example.com") as { id: string };
    const adminRole = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
    db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(user.id, adminRole.id);
    db.close();

    const loginResponse = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "adminish@example.com",
          password: "Password123!",
        }),
      }),
    );

    const cookieHeader = loginResponse.headers.get("set-cookie") ?? "";
    const sessionCookie = cookieHeader.split(";")[0];

    const meResponse = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        method: "GET",
        headers: {
          cookie: sessionCookie,
        },
      }),
    );

    expect(meResponse.status).toBe(200);
    const meBody = await meResponse.json();
    expect(meBody.email).toBe("adminish@example.com");
    expect(meBody.roles).toContain("ADMIN");
    expect(meBody._links).toMatchObject({
      self: { href: "/api/v1/me" },
      logout: { href: "/api/v1/auth/logout" },
      users: { href: "/api/v1/users" },
    });
  });

  it("rejects missing session and supports logout invalidation", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const anonymousMe = await getMe(new Request("http://localhost:3000/api/v1/me"));
    expect(anonymousMe.status).toBe(401);
    const errorBody = await anonymousMe.json();
    expect(errorBody).toMatchObject({
      title: "Unauthorized",
      status: 401,
    });
    expect(errorBody.request_id).toBeTruthy();

    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "logout@example.com",
          password: "Password123!",
        }),
      }),
    );

    const loginResponse = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "logout@example.com",
          password: "Password123!",
        }),
      }),
    );
    const sessionCookie = (loginResponse.headers.get("set-cookie") ?? "").split(";")[0];

    const logoutResponse = await postLogout(
      new Request("http://localhost:3000/api/v1/auth/logout", {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: sessionCookie,
        },
      }),
    );

    expect(logoutResponse.status).toBe(200);
    expect(logoutResponse.headers.get("set-cookie")).toContain("Max-Age=0");

    const afterLogout = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        headers: {
          cookie: sessionCookie,
        },
      }),
    );
    expect(afterLogout.status).toBe(401);
  });
});


===== FILE: src/app/api/v1/auth/login/route.ts =====
import {
  buildSessionCookie,
  getAuthContext,
  isSameOriginMutation,
  loginUser,
} from "../../../../../lib/api/auth";
import { hal, problem } from "../../../../../lib/api/response";
import { consumeRateLimit } from "../../../../../lib/api/rate-limit";

export async function POST(request: Request) {
  const rateLimit = consumeRateLimit(request, "auth:login", 5, 60_000);
  if (!rateLimit.allowed) {
    return problem(
      {
        type: "https://lms-219.dev/problems/rate-limited",
        title: "Too Many Requests",
        status: 429,
        detail: "Rate limit exceeded for login.",
      },
      request,
      {
        headers: {
          "retry-after": String(rateLimit.retryAfterSeconds),
          "cache-control": "no-store",
        },
      },
    );
  }

  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  let payload: { email?: string; password?: string };
  try {
    payload = (await request.json()) as { email?: string; password?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.email || !payload.password) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "Email and password are required.",
      },
      request,
    );
  }

  try {
    const context = getAuthContext();
    const login = await loginUser(payload.email, payload.password, crypto.randomUUID());

    return hal(
      {
        id: login.user.id,
        email: login.user.email,
        status: login.user.status,
        roles: login.user.roles,
      },
      {
        self: { href: "/api/v1/me" },
        logout: { href: "/api/v1/auth/logout" },
      },
      {
        headers: {
          "set-cookie": buildSessionCookie(login.sessionToken, context.env),
          "cache-control": "no-store",
        },
      },
    );
  } catch (error) {
    if (error instanceof Error && error.message === "email_unverified") {
      return problem(
        {
          type: "https://lms-219.dev/problems/email-unverified",
          title: "Forbidden",
          status: 403,
          detail: "Email verification required before login.",
        },
        request,
        {
          headers: {
            "cache-control": "no-store",
          },
        },
      );
    }

    if (error instanceof Error && error.message === "invalid_credentials") {
      return problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Invalid credentials.",
        },
        request,
        {
          headers: {
            "cache-control": "no-store",
          },
        },
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to login.",
      },
        request,
        {
          headers: {
            "cache-control": "no-store",
          },
        },
    );
  }
}


===== FILE: src/app/api/v1/auth/logout/route.ts =====
import {
  buildSessionClearCookie,
  getAuthContext,
  isSameOriginMutation,
  logoutUser,
  parseSessionTokenFromCookie,
} from "../../../../../lib/api/auth";
import { hal, problem } from "../../../../../lib/api/response";

export async function POST(request: Request) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const context = getAuthContext();
  const sessionToken = parseSessionTokenFromCookie(request.headers.get("cookie"));

  if (sessionToken) {
    logoutUser(sessionToken, crypto.randomUUID());
  }

  return hal(
    {
      logged_out: true,
    },
    {
      login: { href: "/api/v1/auth/login" },
      register: { href: "/api/v1/auth/register" },
    },
    {
      headers: {
        "set-cookie": buildSessionClearCookie(context.env),
      },
    },
  );
}


===== FILE: src/app/api/v1/auth/password-reset/confirm/route.ts =====
import { hal, problem } from "../../../../../../lib/api/response";
import { confirmPasswordReset, isSameOriginMutation } from "../../../../../../lib/api/auth";

export async function POST(request: Request) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  let payload: { token?: string; password?: string };
  try {
    payload = (await request.json()) as { token?: string; password?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.token || !payload.password) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "token and password are required.",
      },
      request,
    );
  }

  try {
    await confirmPasswordReset(payload.token, payload.password, crypto.randomUUID());
    return hal(
      {
        reset: true,
      },
      {
        self: { href: "/api/v1/auth/password-reset/confirm" },
        login: { href: "/api/v1/auth/login" },
      },
      {
        headers: {
          "cache-control": "no-store",
        },
      },
    );
  } catch (error) {
    if (error instanceof Error && error.message === "invalid_reset_payload") {
      return problem(
        {
          type: "https://lms-219.dev/problems/invalid-input",
          title: "Bad Request",
          status: 400,
          detail: "token and password are required.",
        },
        request,
      );
    }

    if (error instanceof Error && error.message === "reset_token_invalid") {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Reset token not found.",
        },
        request,
      );
    }

    if (error instanceof Error && error.message === "reset_token_expired") {
      return problem(
        {
          type: "https://lms-219.dev/problems/precondition-failed",
          title: "Precondition Failed",
          status: 412,
          detail: "Reset token is expired.",
        },
        request,
      );
    }

    if (error instanceof Error && error.message === "reset_token_used") {
      return problem(
        {
          type: "https://lms-219.dev/problems/conflict",
          title: "Conflict",
          status: 409,
          detail: "Reset token already used.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to reset password.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/auth/password-reset/request/route.ts =====
import { consumeRateLimit } from "../../../../../../lib/api/rate-limit";
import { hal, problem } from "../../../../../../lib/api/response";
import { isSameOriginMutation, requestPasswordReset } from "../../../../../../lib/api/auth";

export async function POST(request: Request) {
  const rateLimit = consumeRateLimit(request, "auth:password-reset-request", 5, 60_000);
  if (!rateLimit.allowed) {
    return problem(
      {
        type: "https://lms-219.dev/problems/rate-limited",
        title: "Too Many Requests",
        status: 429,
        detail: "Rate limit exceeded for password reset requests.",
      },
      request,
      {
        headers: {
          "retry-after": String(rateLimit.retryAfterSeconds),
          "cache-control": "no-store",
        },
      },
    );
  }

  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  let payload: { email?: string };
  try {
    payload = (await request.json()) as { email?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.email) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "email is required.",
      },
      request,
    );
  }

  try {
    const result = requestPasswordReset(payload.email, crypto.randomUUID());
    return hal(
      {
        accepted: true,
        ...(result.token ? { reset_token: result.token } : {}),
      },
      {
        self: { href: "/api/v1/auth/password-reset/request" },
        confirm: { href: "/api/v1/auth/password-reset/confirm" },
      },
      {
        status: 202,
        headers: {
          "cache-control": "no-store",
        },
      },
    );
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to process password reset request.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/auth/register/route.ts =====
import { hal, problem } from "../../../../../lib/api/response";
import { isSameOriginMutation, registerUser } from "../../../../../lib/api/auth";
import { consumeRateLimit } from "../../../../../lib/api/rate-limit";

export async function POST(request: Request) {
  const rateLimit = consumeRateLimit(request, "auth:register", 5, 60_000);
  if (!rateLimit.allowed) {
    return problem(
      {
        type: "https://lms-219.dev/problems/rate-limited",
        title: "Too Many Requests",
        status: 429,
        detail: "Rate limit exceeded for register.",
      },
      request,
      {
        headers: {
          "retry-after": String(rateLimit.retryAfterSeconds),
          "cache-control": "no-store",
        },
      },
    );
  }

  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  let payload: { email?: string; password?: string; terms_accepted?: boolean };
  try {
    payload = (await request.json()) as { email?: string; password?: string; terms_accepted?: boolean };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.email || !payload.password) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "Email and password are required.",
      },
      request,
    );
  }

  if (payload.terms_accepted === false) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "Terms and Privacy acknowledgment is required.",
      },
      request,
    );
  }

  try {
    const created = await registerUser(
      payload.email,
      payload.password,
      payload.terms_accepted,
      crypto.randomUUID(),
    );
    return hal(
      {
        id: created.id,
        email: created.email,
        status: created.status,
        roles: created.roles,
      },
      {
        self: { href: "/api/v1/me" },
        login: { href: "/api/v1/auth/login" },
      },
      {
        status: 201,
        headers: {
          "cache-control": "no-store",
        },
      },
    );
  } catch (error) {
    if (error instanceof Error && error.message.includes("UNIQUE constraint failed: users.email")) {
      return problem(
        {
          type: "https://lms-219.dev/problems/conflict",
          title: "Conflict",
          status: 409,
          detail: "Email is already registered.",
        },
        request,
        {
          headers: {
            "cache-control": "no-store",
          },
        },
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to register user.",
      },
        request,
        {
          headers: {
            "cache-control": "no-store",
          },
        },
    );
  }
}


===== FILE: src/app/api/v1/auth/verify/confirm/route.ts =====
import { confirmEmailVerification, isSameOriginMutation } from "../../../../../../lib/api/auth";
import { hal, problem } from "../../../../../../lib/api/response";

export async function POST(request: Request) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  let payload: { token?: string };
  try {
    payload = (await request.json()) as { token?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.token) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "token is required.",
      },
      request,
    );
  }

  try {
    await confirmEmailVerification(payload.token, crypto.randomUUID());
    return hal(
      { verified: true },
      {
        self: { href: "/api/v1/auth/verify/confirm" },
        login: { href: "/api/v1/auth/login" },
      },
      {
        headers: {
          "cache-control": "no-store",
        },
      },
    );
  } catch (error) {
    if (error instanceof Error && error.message === "invalid_verify_token") {
      return problem(
        {
          type: "https://lms-219.dev/problems/invalid-input",
          title: "Bad Request",
          status: 400,
          detail: "token is required.",
        },
        request,
      );
    }

    if (error instanceof Error && error.message === "verify_token_invalid") {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Verification token not found.",
        },
        request,
      );
    }

    if (error instanceof Error && error.message === "verify_token_expired") {
      return problem(
        {
          type: "https://lms-219.dev/problems/precondition-failed",
          title: "Precondition Failed",
          status: 412,
          detail: "Verification token is expired.",
        },
        request,
      );
    }

    if (error instanceof Error && error.message === "verify_token_used") {
      return problem(
        {
          type: "https://lms-219.dev/problems/conflict",
          title: "Conflict",
          status: 409,
          detail: "Verification token already used.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to verify email.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/auth/verify/request/route.ts =====
import { consumeRateLimit } from "../../../../../../lib/api/rate-limit";
import { hal, problem } from "../../../../../../lib/api/response";
import { isSameOriginMutation, requestEmailVerification } from "../../../../../../lib/api/auth";

export async function POST(request: Request) {
  const rateLimit = consumeRateLimit(request, "auth:verify-request", 5, 60_000);
  if (!rateLimit.allowed) {
    return problem(
      {
        type: "https://lms-219.dev/problems/rate-limited",
        title: "Too Many Requests",
        status: 429,
        detail: "Rate limit exceeded for verification requests.",
      },
      request,
      {
        headers: {
          "retry-after": String(rateLimit.retryAfterSeconds),
          "cache-control": "no-store",
        },
      },
    );
  }

  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  let payload: { email?: string };
  try {
    payload = (await request.json()) as { email?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.email) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "email is required.",
      },
      request,
    );
  }

  const result = requestEmailVerification(payload.email, crypto.randomUUID());
  return hal(
    {
      accepted: true,
      ...(result.token ? { verification_token: result.token } : {}),
    },
    {
      self: { href: "/api/v1/auth/verify/request" },
      confirm: { href: "/api/v1/auth/verify/confirm" },
    },
    {
      status: 202,
      headers: {
        "cache-control": "no-store",
      },
    },
  );
}


===== FILE: src/app/api/v1/docs/route.ts =====
import { openApiDocument } from "../../../../lib/api/openapi";

export async function GET() {
  return Response.json(openApiDocument, {
    headers: {
      "content-type": "application/json; charset=utf-8",
    },
  });
}


===== FILE: src/app/api/v1/events/__tests__/events-api.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";

import { GET as getEvents, POST as postEvents } from "../route";
import { GET as getEventBySlug, PATCH as patchEventBySlug } from "../[slug]/route";
import { POST as postPublishEvent } from "../[slug]/publish/route";
import { POST as postCancelEvent } from "../[slug]/cancel/route";
import { POST as postLogin } from "../../auth/login/route";
import { POST as postRegister } from "../../auth/register/route";
import { runCli } from "../../../../../cli/run-cli";
import { CliIo } from "../../../../../cli/types";

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-api-events-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const runWithDb = async (argv: string[], dbPath: string): Promise<number> => {
  const { io } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return exitCode;
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

const registerAndLoginAdmin = async (dbPath: string, email: string): Promise<string> => {
  await postRegister(
    new Request("http://localhost:3000/api/v1/auth/register", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  const db = new Database(dbPath);
  const user = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  const role = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
  db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(user.id, role.id);
  db.close();

  const login = await postLogin(
    new Request("http://localhost:3000/api/v1/auth/login", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  return (login.headers.get("set-cookie") ?? "").split(";")[0];
};

afterEach(async () => {
  delete process.env.APPCTL_DB_FILE;
  delete process.env.APPCTL_ENV;
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("api/v1 events", () => {
  it("creates and updates event with admin session", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLoginAdmin(dbPath, "event-admin@example.com");

    const create = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          slug: "spring-demo",
          title: "Spring Demo",
          start: "2026-03-10T10:00:00.000Z",
          end: "2026-03-10T11:00:00.000Z",
          timezone: "UTC",
          capacity: 10,
        }),
      }),
    );

    expect(create.status).toBe(201);
    const createdBody = await create.json();
    expect(createdBody.slug).toBe("spring-demo");
    expect(createdBody.status).toBe("DRAFT");
    expect(createdBody._links["app:publish"]).toBeTruthy();

    const update = await patchEventBySlug(
      new Request("http://localhost:3000/api/v1/events/spring-demo", {
        method: "PATCH",
        headers: {
          "content-type": "application/json",
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ title: "Spring Demo Updated", capacity: 20 }),
      }),
      { params: Promise.resolve({ slug: "spring-demo" }) },
    );

    expect(update.status).toBe(200);
    const updatedBody = await update.json();
    expect(updatedBody.title).toBe("Spring Demo Updated");
    expect(updatedBody.capacity).toBe(20);
  });

  it("enforces state-based publish/cancel HATEOAS links", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLoginAdmin(dbPath, "state-admin@example.com");

    await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          slug: "stateful",
          title: "Stateful Event",
          start: "2026-03-11T10:00:00.000Z",
          end: "2026-03-11T11:00:00.000Z",
          timezone: "UTC",
        }),
      }),
    );

    const draftView = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/stateful", {
        headers: { cookie: adminCookie },
      }),
      { params: Promise.resolve({ slug: "stateful" }) },
    );
    const draftBody = await draftView.json();
    expect(draftBody._links["app:publish"]).toBeTruthy();
    expect(draftBody._links["app:cancel"]).toBeFalsy();

    const publish = await postPublishEvent(
      new Request("http://localhost:3000/api/v1/events/stateful/publish", {
        method: "POST",
        headers: {
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
      }),
      { params: Promise.resolve({ slug: "stateful" }) },
    );
    expect(publish.status).toBe(200);

    const publishedView = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/stateful", {
        headers: { cookie: adminCookie },
      }),
      { params: Promise.resolve({ slug: "stateful" }) },
    );
    const publishedBody = await publishedView.json();
    expect(publishedBody.status).toBe("PUBLISHED");
    expect(publishedBody._links["app:publish"]).toBeFalsy();
    expect(publishedBody._links["app:cancel"]).toBeTruthy();

    const cancel = await postCancelEvent(
      new Request("http://localhost:3000/api/v1/events/stateful/cancel", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ reason: "Weather risk" }),
      }),
      { params: Promise.resolve({ slug: "stateful" }) },
    );

    expect(cancel.status).toBe(200);
    const cancelledBody = await cancel.json();
    expect(cancelledBody.status).toBe("CANCELLED");
    expect(cancelledBody._links["app:publish"]).toBeFalsy();
    expect(cancelledBody._links["app:cancel"]).toBeFalsy();
  });

  it("supports list filters and paging metadata", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLoginAdmin(dbPath, "list-admin@example.com");

    await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          slug: "list-a",
          title: "List A",
          start: "2026-03-12T10:00:00.000Z",
          end: "2026-03-12T11:00:00.000Z",
          timezone: "UTC",
        }),
      }),
    );

    await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          slug: "list-b",
          title: "List B",
          start: "2026-03-13T10:00:00.000Z",
          end: "2026-03-13T11:00:00.000Z",
          timezone: "UTC",
        }),
      }),
    );

    await postPublishEvent(
      new Request("http://localhost:3000/api/v1/events/list-b/publish", {
        method: "POST",
        headers: {
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
      }),
      { params: Promise.resolve({ slug: "list-b" }) },
    );

    const list = await getEvents(new Request("http://localhost:3000/api/v1/events?status=PUBLISHED&limit=1&offset=0"));
    expect(list.status).toBe(200);
    const body = await list.json();
    expect(body.limit).toBe(1);
    expect(body.offset).toBe(0);
    expect(body.items).toHaveLength(1);
    expect(body.items[0].status).toBe("PUBLISHED");
  });
});


===== FILE: src/app/api/v1/events/__tests__/registrations-api.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";

import { POST as postEvents } from "../route";
import { GET as getRegistrations, POST as postRegistration } from "../[slug]/registrations/route";
import { DELETE as deleteRegistration } from "../[slug]/registrations/[userId]/route";
import { POST as postCheckin } from "../[slug]/checkins/route";
import { GET as getExport } from "../[slug]/export/route";
import { POST as postLogin } from "../../auth/login/route";
import { POST as postRegister } from "../../auth/register/route";
import { runCli } from "../../../../../cli/run-cli";
import { CliIo } from "../../../../../cli/types";
import { resetRateLimits } from "../../../../../lib/api/rate-limit";

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-api-reg-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const runWithDb = async (argv: string[], dbPath: string): Promise<number> => {
  const { io } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return exitCode;
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

const registerAndLogin = async (email: string): Promise<string> => {
  await postRegister(
    new Request("http://localhost:3000/api/v1/auth/register", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  const login = await postLogin(
    new Request("http://localhost:3000/api/v1/auth/login", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  return (login.headers.get("set-cookie") ?? "").split(";")[0];
};

const addAdminRole = (dbPath: string, email: string) => {
  const db = new Database(dbPath);
  const user = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  const role = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
  db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(user.id, role.id);
  db.close();
};

const createEventAsAdmin = async (adminCookie: string, slug: string, capacity = 1) => {
  const create = await postEvents(
    new Request("http://localhost:3000/api/v1/events", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
        cookie: adminCookie,
      },
      body: JSON.stringify({
        slug,
        title: slug,
        start: "2026-04-01T10:00:00.000Z",
        end: "2026-04-01T11:00:00.000Z",
        timezone: "UTC",
        capacity,
      }),
    }),
  );
  expect(create.status).toBe(201);
};

afterEach(async () => {
  delete process.env.APPCTL_DB_FILE;
  delete process.env.APPCTL_ENV;
  resetRateLimits();
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("api/v1 registrations/checkin/export", () => {
  it("adds registrations with capacity waitlist behavior", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("reg-admin@example.com");
    addAdminRole(dbPath, "reg-admin@example.com");
    await createEventAsAdmin(adminCookie, "waitlist-event", 1);

    await registerAndLogin("user1@example.com");
    await registerAndLogin("user2@example.com");

    const db = new Database(dbPath);
    const user1 = db.prepare("SELECT id FROM users WHERE email = 'user1@example.com'").get() as { id: string };
    const user2 = db.prepare("SELECT id FROM users WHERE email = 'user2@example.com'").get() as { id: string };
    db.close();

    const addOne = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/waitlist-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ user_id: user1.id }),
      }),
      { params: Promise.resolve({ slug: "waitlist-event" }) },
    );

    const addTwo = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/waitlist-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ user_id: user2.id }),
      }),
      { params: Promise.resolve({ slug: "waitlist-event" }) },
    );

    expect((await addOne.json()).status).toBe("REGISTERED");
    expect((await addTwo.json()).status).toBe("WAITLISTED");
  });

  it("removes as CANCELLED state transition and supports check-in", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("checkin-admin@example.com");
    addAdminRole(dbPath, "checkin-admin@example.com");
    await createEventAsAdmin(adminCookie, "checkin-event", 5);

    await registerAndLogin("checkin-user@example.com");
    const db = new Database(dbPath);
    const user = db.prepare("SELECT id FROM users WHERE email = 'checkin-user@example.com'").get() as {
      id: string;
    };
    db.close();

    await postRegistration(
      new Request("http://localhost:3000/api/v1/events/checkin-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ user_id: user.id }),
      }),
      { params: Promise.resolve({ slug: "checkin-event" }) },
    );

    const checkedIn = await postCheckin(
      new Request("http://localhost:3000/api/v1/events/checkin-event/checkins", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ user_id: user.id }),
      }),
      { params: Promise.resolve({ slug: "checkin-event" }) },
    );
    expect((await checkedIn.json()).status).toBe("CHECKED_IN");

    const removed = await deleteRegistration(
      new Request(`http://localhost:3000/api/v1/events/checkin-event/registrations/${user.id}`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "checkin-event", userId: user.id }) },
    );
    expect((await removed.json()).status).toBe("CANCELLED");

    const checkinAfterCancel = await postCheckin(
      new Request("http://localhost:3000/api/v1/events/checkin-event/checkins", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ user_id: user.id }),
      }),
      { params: Promise.resolve({ slug: "checkin-event" }) },
    );
    expect(checkinAfterCancel.status).toBe(412);
  });

  it("exports json/csv and enforces include_email governance", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("export-admin@example.com");
    addAdminRole(dbPath, "export-admin@example.com");
    await createEventAsAdmin(adminCookie, "export-event", 5);

    await registerAndLogin("export-user@example.com");
    const db = new Database(dbPath);
    const user = db.prepare("SELECT id FROM users WHERE email = 'export-user@example.com'").get() as {
      id: string;
    };
    db.close();

    await postRegistration(
      new Request("http://localhost:3000/api/v1/events/export-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ user_id: user.id }),
      }),
      { params: Promise.resolve({ slug: "export-event" }) },
    );

    const exportJson = await getExport(
      new Request("http://localhost:3000/api/v1/events/export-event/export?format=json&include_email=true", {
        headers: { cookie: adminCookie },
      }),
      { params: Promise.resolve({ slug: "export-event" }) },
    );
    expect(exportJson.status).toBe(200);
    expect(exportJson.headers.get("content-type")).toContain("application/json");

    const exportCsv = await getExport(
      new Request("http://localhost:3000/api/v1/events/export-event/export?format=csv", {
        headers: { cookie: adminCookie },
      }),
      { params: Promise.resolve({ slug: "export-event" }) },
    );
    expect(exportCsv.status).toBe(200);
    expect(exportCsv.headers.get("content-type")).toContain("text/csv");

    process.env.APPCTL_ENV = "prod";
    const blocked = await getExport(
      new Request("https://example.com/api/v1/events/export-event/export?format=json&include_email=true", {
        headers: { cookie: adminCookie },
      }),
      { params: Promise.resolve({ slug: "export-event" }) },
    );
    expect(blocked.status).toBe(403);
  });

  it("lists registrations with optional status filter", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("list-reg-admin@example.com");
    addAdminRole(dbPath, "list-reg-admin@example.com");
    await createEventAsAdmin(adminCookie, "list-reg-event", 10);

    await registerAndLogin("list-reg-user@example.com");
    const db = new Database(dbPath);
    const user = db.prepare("SELECT id FROM users WHERE email = 'list-reg-user@example.com'").get() as {
      id: string;
    };
    db.close();

    await postRegistration(
      new Request("http://localhost:3000/api/v1/events/list-reg-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ user_id: user.id }),
      }),
      { params: Promise.resolve({ slug: "list-reg-event" }) },
    );

    const listAll = await getRegistrations(
      new Request("http://localhost:3000/api/v1/events/list-reg-event/registrations", {
        headers: { cookie: adminCookie },
      }),
      { params: Promise.resolve({ slug: "list-reg-event" }) },
    );
    const listFiltered = await getRegistrations(
      new Request("http://localhost:3000/api/v1/events/list-reg-event/registrations?status=REGISTERED", {
        headers: { cookie: adminCookie },
      }),
      { params: Promise.resolve({ slug: "list-reg-event" }) },
    );

    expect(listAll.status).toBe(200);
    expect(listFiltered.status).toBe(200);
    expect((await listFiltered.json()).items).toHaveLength(1);
  });
});


===== FILE: src/app/api/v1/events/__tests__/self-registration.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";

import { POST as postEvents } from "../route";
import { DELETE as deleteRegistration } from "../[slug]/registrations/[userId]/route";
import { POST as postRegistration } from "../[slug]/registrations/route";
import { POST as postLogin } from "../../auth/login/route";
import { POST as postRegister } from "../../auth/register/route";
import { runCli } from "../../../../../cli/run-cli";
import { CliIo } from "../../../../../cli/types";

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-api-self-reg-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const runWithDb = async (argv: string[], dbPath: string): Promise<number> => {
  const { io } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return exitCode;
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

const registerAndLogin = async (email: string): Promise<string> => {
  await postRegister(
    new Request("http://localhost:3000/api/v1/auth/register", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  const login = await postLogin(
    new Request("http://localhost:3000/api/v1/auth/login", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  return (login.headers.get("set-cookie") ?? "").split(";")[0];
};

afterEach(async () => {
  delete process.env.APPCTL_DB_FILE;
  delete process.env.APPCTL_ENV;
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("self registration API", () => {
  it("allows authenticated user to register and cancel themselves", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("self-admin@example.com");
    const userCookie = await registerAndLogin("self-user@example.com");

    const db = new Database(dbPath);
    const admin = db.prepare("SELECT id FROM users WHERE email = 'self-admin@example.com'").get() as { id: string };
    const user = db.prepare("SELECT id FROM users WHERE email = 'self-user@example.com'").get() as { id: string };
    const adminRole = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
    db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(admin.id, adminRole.id);
    db.close();

    const createEvent = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({
          slug: "self-reg-event",
          title: "Self Registration Event",
          start: "2026-06-01T10:00:00.000Z",
          end: "2026-06-01T11:00:00.000Z",
          timezone: "UTC",
          capacity: 1,
        }),
      }),
    );
    expect(createEvent.status).toBe(201);

    const addSelf = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/self-reg-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: userCookie,
        },
        body: JSON.stringify({ user_id: user.id }),
      }),
      { params: Promise.resolve({ slug: "self-reg-event" }) },
    );
    expect(addSelf.status).toBe(200);
    expect((await addSelf.json()).status).toBe("REGISTERED");

    const removeSelf = await deleteRegistration(
      new Request(`http://localhost:3000/api/v1/events/self-reg-event/registrations/${user.id}`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: userCookie,
        },
      }),
      { params: Promise.resolve({ slug: "self-reg-event", userId: user.id }) },
    );

    expect(removeSelf.status).toBe(200);
    expect((await removeSelf.json()).status).toBe("CANCELLED");
  });

  it("prevents non-admin users from managing other users registrations", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("self-admin-2@example.com");
    const userCookie = await registerAndLogin("self-user-2@example.com");
    await registerAndLogin("other-user@example.com");

    const db = new Database(dbPath);
    const admin = db.prepare("SELECT id FROM users WHERE email = 'self-admin-2@example.com'").get() as { id: string };
    const user = db.prepare("SELECT id FROM users WHERE email = 'self-user-2@example.com'").get() as { id: string };
    const other = db.prepare("SELECT id FROM users WHERE email = 'other-user@example.com'").get() as { id: string };
    const adminRole = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
    db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(admin.id, adminRole.id);
    db.close();

    await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({
          slug: "forbidden-self-reg",
          title: "Forbidden Self Registration",
          start: "2026-06-02T10:00:00.000Z",
          end: "2026-06-02T11:00:00.000Z",
          timezone: "UTC",
          capacity: 2,
        }),
      }),
    );

    const addOther = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/forbidden-self-reg/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: userCookie,
        },
        body: JSON.stringify({ user_id: other.id }),
      }),
      { params: Promise.resolve({ slug: "forbidden-self-reg" }) },
    );

    expect(addOther.status).toBe(403);

    const removeOther = await deleteRegistration(
      new Request(`http://localhost:3000/api/v1/events/forbidden-self-reg/registrations/${other.id}`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: userCookie,
        },
      }),
      { params: Promise.resolve({ slug: "forbidden-self-reg", userId: other.id }) },
    );

    expect(removeOther.status).toBe(403);

    const removeSelfWithoutRegistration = await deleteRegistration(
      new Request(`http://localhost:3000/api/v1/events/forbidden-self-reg/registrations/${user.id}`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: userCookie,
        },
      }),
      { params: Promise.resolve({ slug: "forbidden-self-reg", userId: user.id }) },
    );

    expect(removeSelfWithoutRegistration.status).toBe(404);
  });
});


===== FILE: src/app/api/v1/events/[slug]/cancel/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../../lib/api/auth";
import { hal, problem } from "../../../../../../lib/api/response";
import { cancelEvent, eventLinksForState } from "../../../../../../lib/api/events";

type RouteContext = {
  params: Promise<{ slug: string }>;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function POST(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { slug } = await context.params;

  let payload: { reason?: string };
  try {
    payload = (await request.json()) as { reason?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.reason) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "reason is required.",
      },
      request,
    );
  }

  try {
    const cancelled = cancelEvent(slug, payload.reason, auth.user.id, crypto.randomUUID());
    return hal({ ...cancelled }, eventLinksForState(cancelled.slug, cancelled.status));
  } catch (error) {
    if (error instanceof Error && error.message === "cancel_reason_required") {
      return problem(
        {
          type: "https://lms-219.dev/problems/invalid-input",
          title: "Bad Request",
          status: 400,
          detail: "reason is required.",
        },
        request,
      );
    }

    if (error instanceof Error && error.message === "event_not_found") {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Event not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to cancel event.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/events/[slug]/checkins/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../../lib/api/auth";
import { hal, problem } from "../../../../../../lib/api/response";
import { checkinRegistration } from "../../../../../../lib/api/registrations";

type RouteContext = {
  params: Promise<{ slug: string }>;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function POST(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { slug } = await context.params;

  let payload: { user_id?: string; user_email?: string };
  try {
    payload = (await request.json()) as { user_id?: string; user_email?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  const identifier = payload.user_id ?? payload.user_email;
  if (!identifier) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "user_id or user_email is required.",
      },
      request,
    );
  }

  try {
    const checkedIn = checkinRegistration(slug, identifier, auth.user.id, crypto.randomUUID());
    return hal(
      { ...checkedIn },
      {
        self: { href: `/api/v1/events/${slug}/checkins` },
        registration: { href: `/api/v1/events/${slug}/registrations/${checkedIn.user_id}` },
      },
    );
  } catch (error) {
    if (error instanceof Error && error.message === "registration_cancelled") {
      return problem(
        {
          type: "https://lms-219.dev/problems/precondition-failed",
          title: "Precondition Failed",
          status: 412,
          detail: "Cannot check in a cancelled registration.",
        },
        request,
      );
    }

    if (
      error instanceof Error &&
      (error.message === "event_not_found" ||
        error.message === "user_not_found" ||
        error.message === "registration_not_found")
    ) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Registration not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to check in registration.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/events/[slug]/export/route.ts =====
import { getSessionUserFromRequest } from "../../../../../../lib/api/auth";
import { problem } from "../../../../../../lib/api/response";
import { exportEventData } from "../../../../../../lib/api/registrations";
import { resolveConfig } from "../../../../../../cli/config";
import { consumeRateLimit } from "../../../../../../lib/api/rate-limit";

type RouteContext = {
  params: Promise<{ slug: string }>;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

const toBool = (value: string | null): boolean => {
  if (!value) {
    return false;
  }
  return ["1", "true", "yes"].includes(value.toLowerCase());
};

export async function GET(request: Request, context: RouteContext) {
  const rateLimit = consumeRateLimit(request, "event:export", 5, 60_000);
  if (!rateLimit.allowed) {
    return problem(
      {
        type: "https://lms-219.dev/problems/rate-limited",
        title: "Too Many Requests",
        status: 429,
        detail: "Rate limit exceeded for export.",
      },
      request,
      {
        headers: {
          "retry-after": String(rateLimit.retryAfterSeconds),
          "cache-control": "no-store",
        },
      },
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { slug } = await context.params;
  const url = new URL(request.url);
  const format = url.searchParams.get("format")?.toLowerCase() ?? "json";
  const includeEmail = toBool(url.searchParams.get("include_email"));

  if (format !== "json" && format !== "csv") {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "format must be csv or json.",
      },
      request,
    );
  }

  const config = resolveConfig({ envVars: process.env });
  if (includeEmail && config.env !== "local") {
    return problem(
      {
        type: "https://lms-219.dev/problems/forbidden",
        title: "Forbidden",
        status: 403,
        detail: "include_email is restricted outside local environment.",
      },
      request,
    );
  }

  try {
    const exported = exportEventData({
      slug,
      format,
      includeEmail,
      actorId: auth.user.id,
      requestId: crypto.randomUUID(),
    });

    return new Response(exported.body, {
      status: 200,
      headers: {
        "content-type":
          exported.format === "csv" ? "text/csv; charset=utf-8" : "application/json; charset=utf-8",
        "cache-control": "no-store",
      },
    });
  } catch (error) {
    if (error instanceof Error && error.message === "event_not_found") {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Event not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to export event data.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/events/[slug]/ics/route.ts =====
import { getEventBySlug } from "../../../../../../lib/api/events";
import { problem } from "../../../../../../lib/api/response";

type RouteContext = {
  params: Promise<{ slug: string }>;
};

const formatUtcIcs = (iso: string) => {
  return iso.replace(/[-:]/g, "").replace(/\.\d{3}Z$/, "Z");
};

const toIcs = (event: {
  slug: string;
  title: string;
  start_at: string;
  end_at: string;
}) => {
  const uid = `${event.slug}@lms-219`;
  const now = formatUtcIcs(new Date().toISOString());
  const start = formatUtcIcs(event.start_at);
  const end = formatUtcIcs(event.end_at);

  return [
    "BEGIN:VCALENDAR",
    "VERSION:2.0",
    "PRODID:-//LMS 219//Events//EN",
    "CALSCALE:GREGORIAN",
    "METHOD:PUBLISH",
    "BEGIN:VEVENT",
    `UID:${uid}`,
    `DTSTAMP:${now}`,
    `DTSTART:${start}`,
    `DTEND:${end}`,
    `SUMMARY:${event.title}`,
    `DESCRIPTION:Event ${event.slug}`,
    "END:VEVENT",
    "END:VCALENDAR",
  ].join("\r\n");
};

export async function GET(request: Request, context: RouteContext) {
  const { slug } = await context.params;

  try {
    const event = getEventBySlug(slug);
    const body = toIcs(event);

    return new Response(body, {
      status: 200,
      headers: {
        "content-type": "text/calendar; charset=utf-8",
        "cache-control": "no-store",
        "content-disposition": `attachment; filename=\"${slug}.ics\"`,
      },
    });
  } catch (error) {
    if (error instanceof Error && error.message === "event_not_found") {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Event not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to export event calendar.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/events/[slug]/publish/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../../lib/api/auth";
import { hal, problem } from "../../../../../../lib/api/response";
import { eventLinksForState, publishEvent } from "../../../../../../lib/api/events";

type RouteContext = {
  params: Promise<{ slug: string }>;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function POST(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { slug } = await context.params;

  try {
    const published = publishEvent(slug, auth.user.id, crypto.randomUUID());
    return hal({ ...published }, eventLinksForState(published.slug, published.status));
  } catch (error) {
    if (error instanceof Error && error.message === "event_not_found") {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Event not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to publish event.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/events/[slug]/registrations/[userId]/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../../../lib/api/auth";
import { hal, problem } from "../../../../../../../lib/api/response";
import { removeRegistration } from "../../../../../../../lib/api/registrations";

type RouteContext = {
  params: Promise<{ slug: string; userId: string }>;
};

const requireSession = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  return { user };
};

const isAdmin = (roles: string[]): boolean => {
  return roles.includes("ADMIN") || roles.includes("SUPER_ADMIN");
};

export async function DELETE(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireSession(request);
  if (auth.error) {
    return auth.error;
  }

  const { slug, userId } = await context.params;

  if (!isAdmin(auth.user.roles) && userId !== auth.user.id) {
    return problem(
      {
        type: "https://lms-219.dev/problems/forbidden",
        title: "Forbidden",
        status: 403,
        detail: "You can only cancel your own registration.",
      },
      request,
    );
  }

  try {
    const removed = removeRegistration(slug, userId, auth.user.id, crypto.randomUUID());
    return hal(
      { ...removed },
      {
        self: { href: `/api/v1/events/${slug}/registrations/${userId}` },
        collection: { href: `/api/v1/events/${slug}/registrations` },
      },
    );
  } catch (error) {
    if (
      error instanceof Error &&
      (error.message === "event_not_found" ||
        error.message === "user_not_found" ||
        error.message === "registration_not_found")
    ) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Registration not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to remove registration.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/events/[slug]/registrations/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../../lib/api/auth";
import { hal, problem } from "../../../../../../lib/api/response";
import { addRegistration, listRegistrations } from "../../../../../../lib/api/registrations";

type RouteContext = {
  params: Promise<{ slug: string }>;
};

const requireSession = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  return { user };
};

const isAdmin = (roles: string[]): boolean => {
  return roles.includes("ADMIN") || roles.includes("SUPER_ADMIN");
};

export async function GET(request: Request, context: RouteContext) {
  const auth = requireSession(request);
  if (auth.error) {
    return auth.error;
  }

  const { slug } = await context.params;
  const status = new URL(request.url).searchParams.get("status") ?? undefined;

  try {
    const items = listRegistrations(slug, status);
    const visibleItems = isAdmin(auth.user.roles)
      ? items
      : items.filter((item) => item.user_id === auth.user.id);

    return hal(
      {
        count: visibleItems.length,
        items: visibleItems,
      },
      {
        self: { href: `/api/v1/events/${slug}/registrations` },
        event: { href: `/api/v1/events/${slug}` },
      },
    );
  } catch (error) {
    if (error instanceof Error && error.message === "event_not_found") {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Event not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to list registrations.",
      },
      request,
    );
  }
}

export async function POST(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireSession(request);
  if (auth.error) {
    return auth.error;
  }

  const { slug } = await context.params;
  let payload: { user_id?: string; user_email?: string };

  try {
    payload = (await request.json()) as { user_id?: string; user_email?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  const identifier = payload.user_id ?? payload.user_email ?? auth.user.id;

  if (!isAdmin(auth.user.roles)) {
    const isSelfById = payload.user_id ? payload.user_id === auth.user.id : true;
    const isSelfByEmail = payload.user_email
      ? payload.user_email.toLowerCase() === auth.user.email.toLowerCase()
      : true;

    if (!isSelfById || !isSelfByEmail) {
      return problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "You can only create your own registration.",
        },
        request,
      );
    }
  }

  try {
    const added = addRegistration(slug, identifier, auth.user.id, crypto.randomUUID());
    return hal(
      { ...added },
      {
        self: { href: `/api/v1/events/${slug}/registrations/${added.user_id}` },
        collection: { href: `/api/v1/events/${slug}/registrations` },
      },
    );
  } catch (error) {
    if (
      error instanceof Error &&
      (error.message === "event_not_found" || error.message === "user_not_found")
    ) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Event or user not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to add registration.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/events/[slug]/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../lib/api/auth";
import { hal, problem } from "../../../../../lib/api/response";
import { eventLinksForState, getEventBySlug, updateEvent } from "../../../../../lib/api/events";

type RouteContext = {
  params: Promise<{ slug: string }>;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function GET(request: Request, context: RouteContext) {
  const { slug } = await context.params;

  try {
    const found = getEventBySlug(slug);
    return hal({ ...found }, eventLinksForState(found.slug, found.status));
  } catch (error) {
    if (error instanceof Error && error.message === "event_not_found") {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Event not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to load event.",
      },
      request,
    );
  }
}

export async function PATCH(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { slug } = await context.params;
  let payload: { title?: string; start?: string; end?: string; capacity?: number };

  try {
    payload = (await request.json()) as {
      title?: string;
      start?: string;
      end?: string;
      capacity?: number;
    };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  try {
    const updated = updateEvent(slug, payload, auth.user.id, crypto.randomUUID());
    return hal({ ...updated }, eventLinksForState(updated.slug, updated.status));
  } catch (error) {
    if (error instanceof Error && error.message === "event_not_found") {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Event not found.",
        },
        request,
      );
    }

    if (error instanceof Error && error.message.startsWith("invalid_")) {
      return problem(
        {
          type: "https://lms-219.dev/problems/invalid-input",
          title: "Bad Request",
          status: 400,
          detail: "Invalid event update payload.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to update event.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/events/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../lib/api/auth";
import { hal, problem } from "../../../../lib/api/response";
import { createEvent, eventLinksForState, listEvents } from "../../../../lib/api/events";

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const status = searchParams.get("status") ?? undefined;
  const q = searchParams.get("q") ?? undefined;
  const from = searchParams.get("from") ?? undefined;
  const to = searchParams.get("to") ?? undefined;
  const limit = searchParams.get("limit");
  const offset = searchParams.get("offset");

  try {
    const result = listEvents({
      status,
      q,
      from,
      to,
      limit: limit ? Number(limit) : undefined,
      offset: offset ? Number(offset) : undefined,
    });

    return hal(
      {
        count: result.count,
        limit: result.limit,
        offset: result.offset,
        items: result.items.map((item) => ({
          ...item,
          _links: eventLinksForState(item.slug, item.status),
        })),
      },
      {
        self: { href: "/api/v1/events" },
      },
    );
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "Invalid event filter input.",
      },
      request,
    );
  }
}

export async function POST(request: Request) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  let payload: {
    slug?: string;
    title?: string;
    start?: string;
    end?: string;
    timezone?: string;
    capacity?: number;
  };

  try {
    payload = (await request.json()) as {
      slug?: string;
      title?: string;
      start?: string;
      end?: string;
      timezone?: string;
      capacity?: number;
    };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.slug || !payload.title || !payload.start || !payload.end || !payload.timezone) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "slug, title, start, end, timezone are required.",
      },
      request,
    );
  }

  try {
    const created = createEvent(
      {
        slug: payload.slug,
        title: payload.title,
        start: payload.start,
        end: payload.end,
        timezone: payload.timezone,
        capacity: payload.capacity,
      },
      auth.user.id,
      crypto.randomUUID(),
    );

    return hal(
      { ...created },
      eventLinksForState(created.slug, created.status),
      {
        status: 201,
      },
    );
  } catch (error) {
    if (error instanceof Error && error.message === "event_conflict") {
      return problem(
        {
          type: "https://lms-219.dev/problems/conflict",
          title: "Conflict",
          status: 409,
          detail: "Event already exists for slug.",
        },
        request,
      );
    }

    if (error instanceof Error && error.message.startsWith("invalid_")) {
      return problem(
        {
          type: "https://lms-219.dev/problems/invalid-input",
          title: "Bad Request",
          status: 400,
          detail: "Invalid event payload.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to create event.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/me/route.ts =====
import { getUserFromSession, parseSessionTokenFromCookie } from "../../../../lib/api/auth";
import { hal, problem } from "../../../../lib/api/response";

export async function GET(request: Request) {
  const sessionToken = parseSessionTokenFromCookie(request.headers.get("cookie"));
  if (!sessionToken) {
    return problem(
      {
        type: "https://lms-219.dev/problems/unauthorized",
        title: "Unauthorized",
        status: 401,
        detail: "Active session required.",
      },
      request,
    );
  }

  const user = getUserFromSession(sessionToken);
  if (!user) {
    return problem(
      {
        type: "https://lms-219.dev/problems/unauthorized",
        title: "Unauthorized",
        status: 401,
        detail: "Session is invalid or expired.",
      },
      request,
    );
  }

  const links: Record<string, { href: string }> = {
    self: { href: "/api/v1/me" },
    logout: { href: "/api/v1/auth/logout" },
    events: { href: "/api/v1/events" },
    terms: { href: "/terms" },
    privacy: { href: "/privacy" },
    account_delete: { href: "/api/v1/account/delete" },
  };

  if (user.roles.includes("ADMIN") || user.roles.includes("SUPER_ADMIN")) {
    links.users = { href: "/api/v1/users" };
  }

  return hal(
    {
      id: user.id,
      email: user.email,
      status: user.status,
      roles: user.roles,
    },
    links,
  );
}


===== FILE: src/app/api/v1/route.ts =====
import { hal } from "../../../lib/api/response";

export async function GET() {
  return hal(
    {
      name: "lms_219_api",
      version: "v1",
    },
    {
      self: { href: "/api/v1" },
      docs: { href: "/api/v1/docs" },
      terms: { href: "/terms" },
      privacy: { href: "/privacy" },
      auth_register: { href: "/api/v1/auth/register" },
      auth_login: { href: "/api/v1/auth/login" },
      me: { href: "/api/v1/me" },
      account_delete: { href: "/api/v1/account/delete" },
      events: { href: "/api/v1/events" },
    },
  );
}


===== FILE: src/app/api/v1/users/__tests__/users-api.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";

import { GET as getUsers } from "../route";
import { GET as getUserById, PATCH as patchUserById } from "../[id]/route";
import { POST as postUserRole } from "../[id]/roles/route";
import { DELETE as deleteUserRole } from "../[id]/roles/[role]/route";
import { POST as postLogin } from "../../auth/login/route";
import { POST as postRegister } from "../../auth/register/route";
import { runCli } from "../../../../../cli/run-cli";
import { CliIo } from "../../../../../cli/types";
import { resetRateLimits } from "../../../../../lib/api/rate-limit";

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-api-users-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const runWithDb = async (argv: string[], dbPath: string): Promise<number> => {
  const { io } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return exitCode;
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

const registerAndLogin = async (email: string, password: string): Promise<string> => {
  await postRegister(
    new Request("http://localhost:3000/api/v1/auth/register", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password }),
    }),
  );

  const login = await postLogin(
    new Request("http://localhost:3000/api/v1/auth/login", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password }),
    }),
  );

  return (login.headers.get("set-cookie") ?? "").split(";")[0];
};

afterEach(async () => {
  delete process.env.APPCTL_DB_FILE;
  delete process.env.APPCTL_ENV;
  resetRateLimits();
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("api/v1 users", () => {
  it("requires ADMIN role for user listing", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const userCookie = await registerAndLogin("basic-user@example.com", "Password123!");
    const denied = await getUsers(
      new Request("http://localhost:3000/api/v1/users", {
        headers: { cookie: userCookie },
      }),
    );

    expect(denied.status).toBe(403);
    expect((await denied.json()).title).toBe("Forbidden");
  });

  it("supports list and detail retrieval for admin session", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("admin@example.com", "Password123!");
    const db = new Database(dbPath);
    const admin = db.prepare("SELECT id FROM users WHERE email = ?").get("admin@example.com") as {
      id: string;
    };
    const adminRole = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
    db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(admin.id, adminRole.id);
    db.close();

    const listResponse = await getUsers(
      new Request("http://localhost:3000/api/v1/users", {
        headers: { cookie: adminCookie },
      }),
    );
    const listBody = await listResponse.json();

    expect(listResponse.status).toBe(200);
    expect(listBody.count).toBeGreaterThan(0);
    expect(listBody._links.self.href).toBe("/api/v1/users");

    const detailResponse = await getUserById(
      new Request(`http://localhost:3000/api/v1/users/${admin.id}`, {
        headers: { cookie: adminCookie },
      }),
      { params: Promise.resolve({ id: admin.id }) },
    );
    const detailBody = await detailResponse.json();

    expect(detailResponse.status).toBe(200);
    expect(detailBody.id).toBe(admin.id);
    expect(detailBody.roles).toContain("ADMIN");
  });

  it("updates user status and writes audit entry", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("patch-admin@example.com", "Password123!");
    const targetCookie = await registerAndLogin("target-user@example.com", "Password123!");
    expect(targetCookie).toContain("lms_session=");

    const db = new Database(dbPath);
    const admin = db.prepare("SELECT id FROM users WHERE email = ?").get("patch-admin@example.com") as {
      id: string;
    };
    const target = db.prepare("SELECT id FROM users WHERE email = ?").get("target-user@example.com") as {
      id: string;
    };
    const adminRole = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
    db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(admin.id, adminRole.id);
    db.close();

    const patchResponse = await patchUserById(
      new Request(`http://localhost:3000/api/v1/users/${target.id}`, {
        method: "PATCH",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ status: "DISABLED" }),
      }),
      { params: Promise.resolve({ id: target.id }) },
    );

    expect(patchResponse.status).toBe(200);
    const patchBody = await patchResponse.json();
    expect(patchBody.status).toBe("DISABLED");

    const dbAfter = new Database(dbPath);
    const auditCount = dbAfter
      .prepare("SELECT COUNT(*) as count FROM audit_log WHERE action = 'api.user.update'")
      .get() as { count: number };
    dbAfter.close();

    expect(auditCount.count).toBeGreaterThan(0);
  });

  it("adds/removes roles idempotently and blocks SUPER_ADMIN changes", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("roles-admin@example.com", "Password123!");
    await registerAndLogin("roles-target@example.com", "Password123!");

    const db = new Database(dbPath);
    const admin = db.prepare("SELECT id FROM users WHERE email = ?").get("roles-admin@example.com") as {
      id: string;
    };
    const target = db.prepare("SELECT id FROM users WHERE email = ?").get("roles-target@example.com") as {
      id: string;
    };
    const adminRole = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
    db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(admin.id, adminRole.id);
    db.close();

    const addOne = await postUserRole(
      new Request(`http://localhost:3000/api/v1/users/${target.id}/roles`, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ role: "ADMIN" }),
      }),
      { params: Promise.resolve({ id: target.id }) },
    );
    const addTwo = await postUserRole(
      new Request(`http://localhost:3000/api/v1/users/${target.id}/roles`, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ role: "ADMIN" }),
      }),
      { params: Promise.resolve({ id: target.id }) },
    );

    expect(addOne.status).toBe(200);
    expect(addTwo.status).toBe(200);

    const removeOne = await deleteUserRole(
      new Request(`http://localhost:3000/api/v1/users/${target.id}/roles/ADMIN`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
      }),
      { params: Promise.resolve({ id: target.id, role: "ADMIN" }) },
    );
    const removeTwo = await deleteUserRole(
      new Request(`http://localhost:3000/api/v1/users/${target.id}/roles/ADMIN`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
      }),
      { params: Promise.resolve({ id: target.id, role: "ADMIN" }) },
    );

    expect(removeOne.status).toBe(200);
    expect(removeTwo.status).toBe(200);

    const blockedAdd = await postUserRole(
      new Request(`http://localhost:3000/api/v1/users/${target.id}/roles`, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ role: "SUPER_ADMIN" }),
      }),
      { params: Promise.resolve({ id: target.id }) },
    );

    const blockedRemove = await deleteUserRole(
      new Request(`http://localhost:3000/api/v1/users/${target.id}/roles/SUPER_ADMIN`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
      }),
      { params: Promise.resolve({ id: target.id, role: "SUPER_ADMIN" }) },
    );

    expect(blockedAdd.status).toBe(403);
    expect(blockedRemove.status).toBe(403);
  });
});


===== FILE: src/app/api/v1/users/[id]/roles/[role]/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../../../lib/api/auth";
import { hal, problem } from "../../../../../../../lib/api/response";
import { removeUserRole } from "../../../../../../../lib/api/users";

type RouteContext = {
  params: Promise<{ id: string; role: string }>;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function DELETE(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { id, role } = await context.params;

  try {
    const result = removeUserRole(id, role, auth.user.id, crypto.randomUUID());
    return hal(
      {
        user_id: id,
        role: result.role,
        changed: result.changed,
      },
      {
        self: { href: `/api/v1/users/${id}/roles/${role.toUpperCase()}` },
        user: { href: `/api/v1/users/${id}` },
      },
    );
  } catch (error) {
    if (error instanceof Error && error.message === "super_admin_forbidden") {
      return problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "SUPER_ADMIN role changes are CLI-only.",
        },
        request,
      );
    }

    if (error instanceof Error && error.message === "user_not_found") {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "User not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to remove role.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/users/[id]/roles/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../../lib/api/auth";
import { hal, problem } from "../../../../../../lib/api/response";
import { addUserRole } from "../../../../../../lib/api/users";

type RouteContext = {
  params: Promise<{ id: string }>;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function POST(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { id } = await context.params;
  let payload: { role?: string };

  try {
    payload = (await request.json()) as { role?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.role) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "role is required.",
      },
      request,
    );
  }

  try {
    const result = addUserRole(id, payload.role, auth.user.id, crypto.randomUUID());
    return hal(
      {
        user_id: id,
        role: result.role,
        changed: result.changed,
      },
      {
        self: { href: `/api/v1/users/${id}/roles` },
        user: { href: `/api/v1/users/${id}` },
      },
    );
  } catch (error) {
    if (error instanceof Error && error.message === "super_admin_forbidden") {
      return problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "SUPER_ADMIN role changes are CLI-only.",
        },
        request,
      );
    }

    if (error instanceof Error && error.message === "user_not_found") {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "User not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to add role.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/users/[id]/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../lib/api/auth";
import { hal, problem } from "../../../../../lib/api/response";
import { getUserById, updateUserStatus } from "../../../../../lib/api/users";

type RouteContext = {
  params: Promise<{ id: string }>;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function GET(request: Request, context: RouteContext) {
  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { id } = await context.params;

  try {
    const found = getUserById(id);
    return hal(found, {
      self: { href: `/api/v1/users/${id}` },
      roles: { href: `/api/v1/users/${id}/roles` },
    });
  } catch (error) {
    if (error instanceof Error && error.message === "user_not_found") {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "User not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to load user.",
      },
      request,
    );
  }
}

export async function PATCH(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { id } = await context.params;
  let payload: { status?: string };

  try {
    payload = (await request.json()) as { status?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.status) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "status is required.",
      },
      request,
    );
  }

  try {
    const updated = updateUserStatus(id, payload.status, auth.user.id, crypto.randomUUID());
    return hal(updated, {
      self: { href: `/api/v1/users/${id}` },
      roles: { href: `/api/v1/users/${id}/roles` },
    });
  } catch (error) {
    if (error instanceof Error && error.message === "invalid_status") {
      return problem(
        {
          type: "https://lms-219.dev/problems/invalid-input",
          title: "Bad Request",
          status: 400,
          detail: "Invalid status. Allowed: ACTIVE, DISABLED, PENDING.",
        },
        request,
      );
    }

    if (error instanceof Error && error.message === "user_not_found") {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "User not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to update user.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/users/route.ts =====
import { getSessionUserFromRequest } from "../../../../lib/api/auth";
import { hal, problem } from "../../../../lib/api/response";
import { listUsers } from "../../../../lib/api/users";

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function GET(request: Request) {
  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { searchParams } = new URL(request.url);
  const role = searchParams.get("role") ?? undefined;
  const status = searchParams.get("status") ?? undefined;
  const search = searchParams.get("search") ?? undefined;
  const limit = searchParams.get("limit");
  const offset = searchParams.get("offset");

  const result = listUsers({
    role,
    status,
    search,
    limit: limit ? Number(limit) : undefined,
    offset: offset ? Number(offset) : undefined,
  });

  return hal(
    {
      count: result.count,
      limit: result.limit,
      offset: result.offset,
      items: result.items,
    },
    {
      self: { href: "/api/v1/users" },
    },
    {
      headers: {
        "cache-control": "no-store",
      },
    },
  );
}


===== FILE: src/app/events/[slug]/page.tsx =====
"use client";

import { useEffect, useState } from "react";
import { useParams } from "next/navigation";
import Link from "next/link";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { follow, getRoot, requestHal, type HalResource, type ProblemDetails } from "@/lib/hal-client";

type EventResource = {
  id: string;
  slug: string;
  title: string;
  status: string;
  timezone: string;
  start_at: string;
  end_at: string;
  _links: Record<string, { href: string }>;
};

type EventListPayload = {
  items: Array<{
    slug: string;
    _links?: Record<string, { href: string }>;
  }>;
};

type MeResponse = {
  id: string;
  email: string;
  _links: Record<string, { href: string }>;
};

type RegistrationsList = {
  items: Array<{
    user_id: string;
    status: "REGISTERED" | "WAITLISTED" | "CANCELLED" | "CHECKED_IN";
  }>;
};

export default function EventDetailPage() {
  const params = useParams<{ slug: string }>();
  const [event, setEvent] = useState<EventResource | null>(null);
  const [me, setMe] = useState<MeResponse | null>(null);
  const [registrationStatus, setRegistrationStatus] = useState<string | null>(null);
  const [actionPending, setActionPending] = useState(false);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);
  const [loading, setLoading] = useState(true);

  const loadRegistrationStatus = async (eventSelfHref: string, userId: string) => {
    const result = await requestHal<RegistrationsList>(`${eventSelfHref}/registrations`);
    if (!result.ok) {
      if (result.problem.status === 404) {
        setRegistrationStatus(null);
        return;
      }
      setProblem(result.problem);
      return;
    }

    const mine = result.data.items.find((item) => item.user_id === userId);
    setRegistrationStatus(mine?.status ?? null);
  };

  useEffect(() => {
    const load = async () => {
      setLoading(true);
      setProblem(null);

      const slug = params.slug;
      if (!slug) {
        setLoading(false);
        return;
      }
      const rootResult = await getRoot();
      if (!rootResult.ok) {
        setProblem(rootResult.problem);
        setLoading(false);
        return;
      }

      const eventsLink = follow(rootResult.data as HalResource, "events");
      if (!eventsLink) {
        setProblem({
          type: "about:blank",
          title: "Events Link Missing",
          status: 500,
          detail: "API root did not provide events affordance.",
        });
        setLoading(false);
        return;
      }

      const collectionResult = await requestHal<EventListPayload>(eventsLink.href);
      let detailHref = `${eventsLink.href}/${slug}`;

      if (collectionResult.ok) {
        const found = collectionResult.data.items?.find((item) => item.slug === slug);
        if (found?._links?.self?.href) {
          detailHref = found._links.self.href;
        }
      }

      const detailResult = await requestHal<EventResource>(detailHref);
      if (!detailResult.ok) {
        setProblem(detailResult.problem);
        setLoading(false);
        return;
      }

      setEvent(detailResult.data);

      const meResult = await requestHal<MeResponse>("/api/v1/me");
      if (meResult.ok) {
        setMe(meResult.data);
        const eventSelfHref = detailResult.data._links.self?.href ?? detailHref;
        await loadRegistrationStatus(eventSelfHref, meResult.data.id);
      } else {
        setMe(null);
        if (meResult.problem.status !== 401) {
          setProblem(meResult.problem);
        }
      }

      setLoading(false);
    };

    void load();
  }, [params.slug]);

  const onRegister = async () => {
    if (!event || !me) {
      return;
    }

    setActionPending(true);
    setProblem(null);

    const endpoint = `${event._links.self?.href ?? `/api/v1/events/${event.slug}`}/registrations`;
    const result = await requestHal<{ status: string }>(endpoint, {
      method: "POST",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify({ user_id: me.id }),
    });

    if (!result.ok) {
      setProblem(result.problem);
      setActionPending(false);
      return;
    }

    setRegistrationStatus(result.data.status);
    setActionPending(false);
  };

  const onCancel = async () => {
    if (!event || !me) {
      return;
    }

    setActionPending(true);
    setProblem(null);

    const endpoint = `${event._links.self?.href ?? `/api/v1/events/${event.slug}`}/registrations/${me.id}`;
    const result = await requestHal<{ status: string }>(endpoint, {
      method: "DELETE",
    });

    if (!result.ok) {
      setProblem(result.problem);
      setActionPending(false);
      return;
    }

    setRegistrationStatus(result.data.status);
    setActionPending(false);
  };

  return (
    <main className="mx-auto max-w-4xl p-6">
      {loading ? <p className="text-sm">Loading event...</p> : null}
      {problem ? <ProblemDetailsPanel problem={problem} /> : null}
      {event ? (
        <article className="space-y-3 rounded-md border p-4">
          <h1 className="text-2xl font-semibold">{event.title}</h1>
          <p className="text-sm">Status: {event.status}</p>
          <p className="text-sm">
            {event.start_at}  {event.end_at} ({event.timezone})
          </p>
          {event._links["app:ics"] ? (
            <p className="text-sm">
              <a href={event._links["app:ics"].href} className="underline">
                Download calendar (.ics)
              </a>
            </p>
          ) : null}

          <div className="rounded-md border p-3">
            <h2 className="text-sm font-medium">Your registration</h2>
            {!me ? (
              <p className="mt-1 text-sm">
                <Link href="/login" className="underline">
                  Login
                </Link>{" "}
                to register.
              </p>
            ) : (
              <div className="mt-2 space-y-2">
                <p className="text-sm">
                  Status: <span className="font-medium">{registrationStatus ?? "NOT_REGISTERED"}</span>
                </p>
                <div className="flex gap-2">
                  {registrationStatus === null || registrationStatus === "CANCELLED" ? (
                    <button
                      type="button"
                      disabled={actionPending}
                      onClick={() => void onRegister()}
                      className="rounded border px-3 py-2 text-sm"
                    >
                      {actionPending ? "Working..." : "Register"}
                    </button>
                  ) : (
                    <button
                      type="button"
                      disabled={actionPending}
                      onClick={() => void onCancel()}
                      className="rounded border px-3 py-2 text-sm"
                    >
                      {actionPending ? "Working..." : "Cancel registration"}
                    </button>
                  )}
                </div>
              </div>
            )}
          </div>

          <div>
            <h2 className="text-sm font-medium">Available actions</h2>
            <ul className="mt-1 list-disc pl-5 text-sm">
              {Object.keys(event._links)
                .filter((rel) => rel.startsWith("app:"))
                .map((rel) => (
                  <li key={rel}>{rel}</li>
                ))}
              {Object.keys(event._links).filter((rel) => rel.startsWith("app:")).length === 0 ? (
                <li>No action links available.</li>
              ) : null}
            </ul>
          </div>
        </article>
      ) : null}
    </main>
  );
}


===== FILE: src/app/events/page.tsx =====
"use client";

import Link from "next/link";
import { useEffect, useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { follow, getRoot, requestHal, type HalResource, type ProblemDetails } from "@/lib/hal-client";

type EventItem = {
  slug: string;
  title: string;
  status: string;
  _links: Record<string, { href: string }>;
};

type EventsPayload = {
  count: number;
  items: EventItem[];
};

export default function EventsPage() {
  const [page, setPage] = useState(1);
  const [searchQuery, setSearchQuery] = useState("");
  const [events, setEvents] = useState<EventItem[]>([]);
  const [queryInput, setQueryInput] = useState("");
  const [loading, setLoading] = useState(true);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  useEffect(() => {
    const syncFromUrl = () => {
      const params = new URLSearchParams(window.location.search);
      const nextPage = Math.max(Number(params.get("page") ?? "1") || 1, 1);
      const nextQuery = params.get("q") ?? "";
      setPage(nextPage);
      setSearchQuery(nextQuery);
      setQueryInput(nextQuery);
    };

    syncFromUrl();
    window.addEventListener("popstate", syncFromUrl);
    return () => {
      window.removeEventListener("popstate", syncFromUrl);
    };
  }, []);

  const updateUrlState = (next: { q?: string; page?: string }) => {
    if (typeof window === "undefined") {
      return;
    }

    const params = new URLSearchParams(window.location.search);

    if (next.q !== undefined) {
      const q = next.q.trim();
      if (q.length > 0) {
        params.set("q", q);
      } else {
        params.delete("q");
      }
    }

    if (next.page !== undefined) {
      params.set("page", next.page);
    }

    const query = params.toString();
    const nextUrl = query.length > 0 ? `${window.location.pathname}?${query}` : window.location.pathname;
    window.history.pushState(null, "", nextUrl);
    const updated = new URLSearchParams(window.location.search);
    setPage(Math.max(Number(updated.get("page") ?? "1") || 1, 1));
    setSearchQuery(updated.get("q") ?? "");
  };

  useEffect(() => {
    const load = async () => {
      setLoading(true);
      setProblem(null);

      const rootResult = await getRoot();
      if (!rootResult.ok) {
        setProblem(rootResult.problem);
        setLoading(false);
        return;
      }

      const eventsLink = follow(rootResult.data as HalResource, "events");
      if (!eventsLink) {
        setProblem({
          type: "about:blank",
          title: "Events Link Missing",
          status: 500,
          detail: "API root did not provide events affordance.",
        });
        setLoading(false);
        return;
      }

      const limit = 5;
      const offset = (page - 1) * limit;
      const query = new URLSearchParams({
        limit: String(limit),
        offset: String(offset),
      });
      if (searchQuery.trim().length > 0) {
        query.set("q", searchQuery.trim());
      }

      const eventsResult = await requestHal<EventsPayload>(`${eventsLink.href}?${query.toString()}`);
      if (!eventsResult.ok) {
        setProblem(eventsResult.problem);
        setLoading(false);
        return;
      }

      setEvents(eventsResult.data.items ?? []);
      setLoading(false);
    };

    void load();
  }, [page, searchQuery]);

  return (
    <main className="mx-auto max-w-4xl p-6">
      <h1 className="text-2xl font-semibold">Events</h1>
      <form
        className="mt-4 flex gap-2"
        onSubmit={(event) => {
          event.preventDefault();
          updateUrlState({ q: queryInput, page: "1" });
        }}
      >
        <input
          value={queryInput}
          onChange={(event) => setQueryInput(event.target.value)}
          placeholder="Search title"
          className="w-full rounded border px-3 py-2 text-sm"
        />
        <button type="submit" className="rounded border px-3 py-2 text-sm">
          Search
        </button>
      </form>
      {loading ? <p className="mt-4 text-sm">Loading events...</p> : null}
      {problem ? <div className="mt-4"><ProblemDetailsPanel problem={problem} /></div> : null}
      {!loading && !problem ? (
        <>
          <ul className="mt-4 space-y-3">
            {events.map((event) => (
              <li key={event.slug} className="rounded-md border p-4">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="font-medium">{event.title}</p>
                    <p className="text-sm">Status: {event.status}</p>
                  </div>
                  <Link href={`/events/${event.slug}`} className="text-sm underline">
                    View
                  </Link>
                </div>
              </li>
            ))}
          </ul>
          <div className="mt-4 flex items-center gap-2 text-sm">
            <button
              type="button"
              className="rounded border px-3 py-2"
              disabled={page <= 1}
              onClick={() => updateUrlState({ page: String(page - 1) })}
            >
              Previous
            </button>
            <span>Page {page}</span>
            <button
              type="button"
              className="rounded border px-3 py-2"
              disabled={events.length < 5}
              onClick={() => updateUrlState({ page: String(page + 1) })}
            >
              Next
            </button>
          </div>
        </>
      ) : null}
    </main>
  );
}


===== FILE: src/app/favicon.ico =====
         (  F          (  n  00     (-             F  (                                                           $   ]         ]   $                                                                                       8                                 8                                                                                                               #         OOOggg            #   Y         555            Y               kkk                              			                  Y               JJJkkk                  Y   #               			                  #                      111DDD                                                                                   8                                 8                                                                                       $   ]         ]   $                                                                                                                                                                                                                                                                                    (       @                                                                               ,   U               U   ,                                                                                      *                                       *                                                                                                                                                                             Q                                                         Q                                               r                                                               r                                       r                                                                     r                               O                                                                           O                                                                                                                                                                                                                           (                                                                                       '                             888___                                                 SSS                           +                        hhh                           +   T                        ,,,                           T                              GGG                                                                                                                              +++jjj                                                                                                         T                                 III                                    T   +                                    hhh                                    +                                       ,,,                                                                                  GGG                                                  '                                                                              (                                                   333___                                                                                                                                                                  O                                                                           O                               r                                                                     r                                       r                                                               r                                               Q                                                         Q                                                                                                                                                                             *                                       *                                                                                      ,   U               U   ,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               (   0   `           -                                                                                             	   (   L   j               j   K   (   	                                                                                                                                          V                                             U                                                                                                                      %                                                               &                                                                                                                                                                                                                                                                     Q                                                                                 R                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         P                                                                                                                     O                                                                                                                                                                                                                                                                                                                                       #                                                                                                                                 #                                                                                                                                                                                                 $$$hhheeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeePPP                                         U                              sss                                 U                                            eee                                        	                                    HHH                                       	   (                                       EEE                                          (   K                                          ,,,                                          L   j                                          )))                                             j                                                                                                                                             iii                                                                                                   eee                                                                                                   HHH                                                      j                                                   EEE                                                      j   L                                                      ,,,                                                      K   (                                                      )))                                                         (   	                                                                                                                  	                                                             iii                                                                    U                                                         eee                                                         U                                                                    HHH                                                                                                                                    EEE                                                                               #                                                            ,,,                                                            #                                                                                222}}}                                                                                                                                                                                                                                                 O                                                                                                                     P                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         R                                                                                 Q                                                                                                                                                                                                                                                                     &                                                               %                                                                                                                      U                                             V                                                                                                                                          	   (   K   j               j   L   (   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        PNG

   IHDR         \rf   sRGB    8eXIfMM *    i                              D"8s  IDATx]	n]<QVAh$	N13*qdIDL2((2G	q_@x{oU{}O;9d(Dg8	N ]@hx?v N3=`;6.&u  6P@R PiZq^DNwpXhHg@
:|5` p"@'s{p*2 d |(0
0 >K
xX6 IJ C|?$KEN}|h $	2 |/ . Nz #We
5;y  gsh^  I DL(;8HjgcH|x1R"a G@9`/`%0H@j~,K
,t).IDTO)~Vu$b U%7 _$b 8AJ3` 510wQ?vr:2K@ v*{%#AZ^(=g \W!:,`6643:@c.Fu?<'_vp: 8Q
Ip{3kHGc<62&
2uCT3
;d/~m.X@{w.d]G {lKEb(PRuMTCd])_Lm==@bKGUk^U)1gTm`9\Q@6:^wED 	5F,
X"dm<nB~@ttx;f>I88C1$Be+jlEZ& S::6m\G1`!nll^Q`@OcS@eqbpS@upFD@2@#L3 A$H2 _hFH#rq(ODrunGOWab &SgD3EDto*9k~),$ xR1vK 9DU(w&LES)3Y8x8 $.i(KYa]4	c@3f4 /*b $!I~7B*-1`	o  	$DL J"OQ)2@#x4"$e I8Oi8" G8[xt<.7&m&R^tq .Y-2 d *_&d|j\Wb G*g F4"I/ b1qNYDp9p}w\ 1 j`OxK=H A1#
D:U8jt$b bA||UQ26%)1 _!~D +b >A:]E$50GDhRtwR)P n$ 3@bSNu,Yj:;@`|-[)'OVsFxn}7~:QJ_UKj8q0x;v4 =[hW=		&!e58hEw]6_iW}SZ?	/`;vl}2 <h" AX,m+V(<w#F^;aHc )S*{apc89(^4&EoW/u=^*?{k^_Ezg UI-{WU*
:p9.to(/us>3'^RgGI_D~~ {?N07S.~?}/y]nA;2 ]FOB2C?_I[::=#OzK- %?jIP{N-hUt: ,GK-hUchP7 @n?\-k.2: `F=-V_GV }0 WIFsMrZ8pJQ*@OK8
rZa, w SW^y.5at7Tv#~7nA"+WpM/hK8gF/^M{e R|)q7t?8'KP~\r>Uk eP|^x
/V/v*pv ]J}k8(GOmq,Xoe.^ Qxpt4^_N{y2 s -sgsivZ8
!~PJ?c|] {zR1pnztlp9frvjTz4*OL~34~~r;mxY+3 r;mx4:7]qL4)U!r1u6$78w3|5>?\zO ,E32[2Wu:E^p.H1cJt]}BuSOuIcO%  AZkD?5 @Q3w+"TSU13?5 M'>pZj~fjn> i5D[bf ~a'`Xc -1kIkQ|kM(92@tX-LaN4q'$f0@@VnAYL9:|/^s 	)0`jT\wuZ-\	@:ct{-Rb1% I,Y%T~r1C,$*f<0zhF |8Z-CRTg HRfglYs-p'+m_gC{ 	3g-GR|7`G0U_ZD)\>z N@~~-P{rs@<|.]|m|g_yWKD1bM%s\r1n\"- `.4~%3I}[0A$= ->BH"G^r<EBGi %9@^~~@1@ t-[{%@C$mAg5k/OlB@.XupO6x9MPn`o_^n`t
(\rsAyT@h
E0l0;tkNYjU
S#|^- |pN.`^{zL64 be]&"ds9UU0!*nP*`ovi8Ghhms={JU0wZ8bEz,YD![C>}7:knof >jvR?#bX(FATFi[{zv>Ca+[0B2D=G~(
LO\s>"8|`[)
&Lp8'4 oGe#l_\D2Zli9t9f -=Yyn?uQ}XsAi >=1=R+ +.2 KC20h %535@MA%j[9; _(0~r\{mPx#TT9n?N#&} )
TVL!j`p 8@RrUAVA=-pLH`@n*1U?}w ]H2@iV[%5 8)
T`|rZbZ-.!da+@ Zgf[0p  Igr$o%P_rCyV|"mY-[ lk xA 9][pIpPk FegHEdnAm"Z$5}z82rX| SwrJsJ~Tfz{  xj?jQEn js|Gx<dXt(QE.p47 );ys_VD-XTi? ~ `Q=V?^
.]|X
mB~?J D~h rERAB~wq}<[5d-`5 ?Kq~l40@)/I(n9Y4!C2*w9GKs&res?68J |(uwOd&K)nA?Rn@7,8=renM69kM7JR]en9Z /?o>rzr `V{u4448Vrap QRZ<{dK.F9#~Ts.N%* u8G&/W:*x%{}@ lNc#AIi*?0}gC"p4(b8_QY r7'` j 6 *3Wg"l1:Sg}% 	P?1`Y "D0b@ 9[tF1p`k\U`RA#W81 e`)RZM [uF0	rq. #^=C"9P'R~f 
pnzdC"e?\K@&$b }jz3 x/{1 Ra#|UK= &^TMn295)?s{O'DDo [kMoK0x Td_@]b r G; DD1gaR`'`0 >\/f!fnZ|bU.tr9+	b rnEDk= 8!b RClPE`K'~@}*!`@6 L;	$b@D?#gF
V1v;EsQ=4b@Tn!3q0^V c 1[M=8I1@@Cu`No WJ WeI nNm_d(4`EI "1 *3+\E \M)g	r
8>p?vI 0~!b$'%"IRi1 0? S~& r{ n_L?Te7C"rOQ~"qI O 8?$b r#@_vJ/3'd/W[o'Nl-2 @jO~02` H@+pOB uO(lS9~c:x/Xd.d Vy@F $H2 +M*il8O@F $H2 24& rPO7NYS Y1`;JS3n g['@W@"la`32n?'HB2p
hmmu j@F@VZ!xIHy)>Z!6 a`dDV$9f	pM6I!LG:\LdrwPy~P%L37TKAmmo|6	3-h J3?67 yr"g4. $1_[*&S/dqCh 3>6%\#RZq=lK|XXWSe j5 /$:v@8d1(z2~F)3lC#=.\Lt? % N$9b%:2u	 1|-	ldt $b@?@ Fc^Dd[9z:
H@ P2v )~@z5|R|`#W39<"-0\<duoGLz 1Gped .jH@jF3@ c{s<J&	@bw   nv< ,M;*p>p!0hH{=x]I DLh<'h8@V #Jf I HnW}Nt[u$ @ 2 	]&) #3,	=%Tk&  II [8		L]]tTg6-@b2 UOV: A?} .i|	xCrvw; #>i 8_b82 WP  {'n8z;ys @Po|Sih $3@j    IENDB`

===== FILE: src/app/globals.css =====
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}


===== FILE: src/app/layout.tsx =====
import type { Metadata } from "next";
import Link from "next/link";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "LMS 219",
  description: "LMS 219 UI consuming /api/v1 HAL APIs",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <header className="border-b">
          <nav className="mx-auto flex max-w-4xl items-center gap-4 p-4 text-sm">
            <Link href="/">Home</Link>
            <Link href="/events">Events</Link>
            <Link href="/admin">Admin</Link>
          </nav>
        </header>
        {children}
      </body>
    </html>
  );
}


===== FILE: src/app/login/page.tsx =====
"use client";

import Link from "next/link";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { follow, getRoot, requestHal, type HalResource, type ProblemDetails } from "@/lib/hal-client";
import { loginSchema, type LoginFormValues } from "@/lib/auth-forms";

export default function LoginPage() {
  const router = useRouter();
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<LoginFormValues>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: "",
      password: "",
    },
  });

  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  const onSubmit = async (values: LoginFormValues) => {
    setProblem(null);

    const root = await getRoot();
    if (!root.ok) {
      setProblem(root.problem);
      return;
    }

    const loginLink = follow(root.data as HalResource, "auth_login");
    if (!loginLink) {
      setProblem({
        type: "about:blank",
        title: "Login Link Missing",
        status: 500,
        detail: "API root did not include auth_login link.",
      });
      return;
    }

    const result = await requestHal<unknown>(loginLink.href, {
      method: "POST",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify(values),
    });

    if (!result.ok) {
      setProblem(result.problem);
      return;
    }

    router.push("/account");
  };

  return (
    <main className="mx-auto max-w-md p-6">
      <h1 className="text-2xl font-semibold">Login</h1>
      <p className="mt-2 text-sm">Use your account credentials to sign in.</p>

      <form className="mt-4 space-y-3" onSubmit={(event) => void handleSubmit(onSubmit)(event)}>
        <div>
          <label htmlFor="email" className="text-sm font-medium">
            Email
          </label>
          <input id="email" type="email" className="mt-1 w-full rounded border px-3 py-2" {...register("email")} />
          {errors.email ? <p className="mt-1 text-xs text-red-600">{errors.email.message}</p> : null}
        </div>

        <div>
          <label htmlFor="password" className="text-sm font-medium">
            Password
          </label>
          <input
            id="password"
            type="password"
            className="mt-1 w-full rounded border px-3 py-2"
            {...register("password")}
          />
          {errors.password ? <p className="mt-1 text-xs text-red-600">{errors.password.message}</p> : null}
        </div>

        <button type="submit" disabled={isSubmitting} className="rounded border px-3 py-2 text-sm">
          {isSubmitting ? "Signing in..." : "Sign in"}
        </button>
      </form>

      {problem ? (
        <div className="mt-4">
          <ProblemDetailsPanel problem={problem} />
        </div>
      ) : null}

      <p className="mt-4 text-sm">
        Need an account? <Link className="underline" href="/register">Register</Link>
      </p>
      <p className="mt-2 text-xs">
        <Link className="underline" href="/terms">Terms</Link>  <Link className="underline" href="/privacy">Privacy</Link>
      </p>
    </main>
  );
}


===== FILE: src/app/page.tsx =====
import Link from "next/link";

export default function Home() {
  return (
    <main className="mx-auto max-w-4xl p-6">
      <h1 className="text-2xl font-semibold">LMS 219 UI</h1>
      <p className="mt-2 text-sm">Public events are now available through HAL-driven UI screens.</p>
      <div className="mt-4 flex gap-3">
        <Link href="/events" className="rounded-md border px-3 py-2 text-sm">
          Browse Events
        </Link>
      </div>
      <p className="mt-4 text-xs text-zinc-500">Admin pages will be delivered in upcoming sprints.</p>
    </main>
  );
}


===== FILE: src/app/privacy/page.tsx =====
export default function PrivacyPage() {
  return (
    <main className="mx-auto max-w-3xl p-6">
      <h1 className="text-2xl font-semibold">Privacy Policy</h1>
      <p className="mt-3 text-sm">
        LMS 219 processes account and event participation data for service operation and keeps deletion records for retention compliance.
      </p>
    </main>
  );
}


===== FILE: src/app/register/page.tsx =====
"use client";

import Link from "next/link";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { follow, getRoot, requestHal, type HalResource, type ProblemDetails } from "@/lib/hal-client";
import { registerSchema, type RegisterFormValues } from "@/lib/auth-forms";

export default function RegisterPage() {
  const router = useRouter();
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<RegisterFormValues>({
    resolver: zodResolver(registerSchema),
    defaultValues: {
      email: "",
      password: "",
      confirmPassword: "",
      termsAccepted: false,
    },
  });

  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  const onSubmit = async (values: RegisterFormValues) => {
    setProblem(null);

    const root = await getRoot();
    if (!root.ok) {
      setProblem(root.problem);
      return;
    }

    const registerLink = follow(root.data as HalResource, "auth_register");
    if (!registerLink) {
      setProblem({
        type: "about:blank",
        title: "Register Link Missing",
        status: 500,
        detail: "API root did not include auth_register link.",
      });
      return;
    }

    const result = await requestHal<unknown>(registerLink.href, {
      method: "POST",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify({
        email: values.email,
        password: values.password,
        terms_accepted: values.termsAccepted,
      }),
    });

    if (!result.ok) {
      setProblem(result.problem);
      return;
    }

    router.push("/login");
  };

  return (
    <main className="mx-auto max-w-md p-6">
      <h1 className="text-2xl font-semibold">Register</h1>
      <p className="mt-2 text-sm">Create a new account.</p>

      <form className="mt-4 space-y-3" onSubmit={(event) => void handleSubmit(onSubmit)(event)}>
        <div>
          <label htmlFor="email" className="text-sm font-medium">
            Email
          </label>
          <input id="email" type="email" className="mt-1 w-full rounded border px-3 py-2" {...register("email")} />
          {errors.email ? <p className="mt-1 text-xs text-red-600">{errors.email.message}</p> : null}
        </div>

        <div>
          <label htmlFor="password" className="text-sm font-medium">
            Password
          </label>
          <input
            id="password"
            type="password"
            className="mt-1 w-full rounded border px-3 py-2"
            {...register("password")}
          />
          {errors.password ? <p className="mt-1 text-xs text-red-600">{errors.password.message}</p> : null}
        </div>

        <div>
          <label className="inline-flex items-center gap-2 text-sm">
            <input type="checkbox" {...register("termsAccepted")} />
            <span>
              I agree to the <Link className="underline" href="/terms">Terms</Link> and <Link className="underline" href="/privacy">Privacy</Link>.
            </span>
          </label>
          {errors.termsAccepted ? <p className="mt-1 text-xs text-red-600">{errors.termsAccepted.message}</p> : null}
        </div>

        <div>
          <label htmlFor="confirmPassword" className="text-sm font-medium">
            Confirm password
          </label>
          <input
            id="confirmPassword"
            type="password"
            className="mt-1 w-full rounded border px-3 py-2"
            {...register("confirmPassword")}
          />
          {errors.confirmPassword ? <p className="mt-1 text-xs text-red-600">{errors.confirmPassword.message}</p> : null}
        </div>

        <button type="submit" disabled={isSubmitting} className="rounded border px-3 py-2 text-sm">
          {isSubmitting ? "Creating account..." : "Create account"}
        </button>
      </form>

      {problem ? (
        <div className="mt-4">
          <ProblemDetailsPanel problem={problem} />
        </div>
      ) : null}

      <p className="mt-4 text-sm">
        Already have an account? <Link className="underline" href="/login">Login</Link>
      </p>
    </main>
  );
}


===== FILE: src/app/terms/page.tsx =====
export default function TermsPage() {
  return (
    <main className="mx-auto max-w-3xl p-6">
      <h1 className="text-2xl font-semibold">Terms of Service</h1>
      <p className="mt-3 text-sm">
        By using LMS 219, you agree to lawful use, account security responsibilities, and service abuse restrictions.
      </p>
    </main>
  );
}


===== FILE: src/cli/__tests__/__snapshots__/run-cli.test.ts.snap =====
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`appctl foundation > matches help snapshot 1`] = `
"Usage: appctl [options] [command]

Super Admin Control Plane CLI

Options:
  --json             emit strict JSON output
  --quiet            reduce human-readable output
  --no-color         disable ANSI colors
  --trace            show stack traces for errors
  --dry-run          validate request without mutating state
  --yes              skip interactive confirmations
  --token <token>    super-admin service token override
  --env <env>        runtime environment (choices: "local", "staging", "prod")
  -h, --help         display help for command

Commands:
  doctor             Validate config and runtime prerequisites
  db                 Database lifecycle commands
  auth               Authentication and service tokens
  user               User management commands
  event              Event lifecycle commands
  reg                Event registration commands
  checkin [options]  Check in a registered user
  help [command]     display help for command
"
`;


===== FILE: src/cli/__tests__/auth-user.test.ts =====
import { createHash } from "node:crypto";
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";
import { runCli } from "../run-cli";
import { CliIo } from "../types";

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-auth-user-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const runWithDb = async (
  argv: string[],
  dbPath: string,
): Promise<{ exitCode: number; stdout: string; stderr: string }> => {
  const { io, stdout, stderr } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return {
    exitCode,
    stdout: stdout.join(""),
    stderr: stderr.join(""),
  };
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

afterEach(async () => {
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("appctl auth/user", () => {
  it("token create shows token once and stores hash only", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    const create = await runWithDb(["--json", "auth", "token", "create", "--name", "sprint3"], dbPath);
    expect(create.exitCode).toBe(0);

    const payload = JSON.parse(create.stdout);
    const token = payload.data.token as string;
    const tokenId = payload.data.id as string;

    const db = new Database(dbPath);
    const stored = db
      .prepare("SELECT token_hash FROM service_tokens WHERE id = ?")
      .get(tokenId) as { token_hash: string };
    db.close();

    const expectedHash = createHash("sha256").update(token).digest("hex");
    expect(token).not.toBe(stored.token_hash);
    expect(stored.token_hash).toBe(expectedHash);
  });

  it("staging write requires token and revoked token is rejected", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    const unauthorized = await runWithDb(
      ["user", "create", "--email", "no-token@example.com", "--env", "staging"],
      dbPath,
    );
    expect(unauthorized.exitCode).toBe(3);

    const created = await runWithDb(["--json", "auth", "token", "create", "--name", "api"], dbPath);
    const createdPayload = JSON.parse(created.stdout);
    const token = createdPayload.data.token as string;
    const tokenId = createdPayload.data.id as string;

    const withToken = await runWithDb(
      [
        "user",
        "create",
        "--email",
        "with-token@example.com",
        "--status",
        "ACTIVE",
        "--env",
        "staging",
        "--token",
        token,
      ],
      dbPath,
    );
    expect(withToken.exitCode).toBe(0);

    const revoke = await runWithDb(["auth", "token", "revoke", "--id", tokenId], dbPath);
    expect(revoke.exitCode).toBe(0);

    const afterRevoke = await runWithDb(
      ["user", "create", "--email", "revoked@example.com", "--env", "staging", "--token", token],
      dbPath,
    );
    expect(afterRevoke.exitCode).toBe(3);
  });

  it("user create enforces unique email conflict", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    const first = await runWithDb(["user", "create", "--email", "dup@example.com"], dbPath);
    const second = await runWithDb(["user", "create", "--email", "dup@example.com"], dbPath);

    expect(first.exitCode).toBe(0);
    expect(second.exitCode).toBe(5);
  });

  it("role add/remove are idempotent and audited", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    const createUser = await runWithDb(
      ["--json", "user", "create", "--email", "role-user@example.com", "--status", "ACTIVE"],
      dbPath,
    );
    const userId = JSON.parse(createUser.stdout).data.id as string;

    const addOne = await runWithDb(["user", "role", "add", "--id", userId, "--role", "ADMIN"], dbPath);
    const addTwo = await runWithDb(["user", "role", "add", "--id", userId, "--role", "ADMIN"], dbPath);
    const removeOne = await runWithDb(["user", "role", "remove", "--id", userId, "--role", "ADMIN"], dbPath);
    const removeTwo = await runWithDb(["user", "role", "remove", "--id", userId, "--role", "ADMIN"], dbPath);

    expect(addOne.exitCode).toBe(0);
    expect(addTwo.exitCode).toBe(0);
    expect(removeOne.exitCode).toBe(0);
    expect(removeTwo.exitCode).toBe(0);

    const db = new Database(dbPath);
    const userRoleCount = db
      .prepare("SELECT COUNT(*) AS count FROM user_roles WHERE user_id = ?")
      .get(userId) as { count: number };
    const addAuditCount = db
      .prepare("SELECT COUNT(*) AS count FROM audit_log WHERE action = 'user.role.add'")
      .get() as { count: number };
    const removeAuditCount = db
      .prepare("SELECT COUNT(*) AS count FROM audit_log WHERE action = 'user.role.remove'")
      .get() as { count: number };
    db.close();

    expect(userRoleCount.count).toBe(0);
    expect(addAuditCount.count).toBe(2);
    expect(removeAuditCount.count).toBe(2);
  });

  it("returns not-found exit code 4 for missing user", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    const missing = await runWithDb(["user", "disable", "--id", "missing-user-id"], dbPath);
    expect(missing.exitCode).toBe(4);
  });
});


===== FILE: src/cli/__tests__/backup-restore.test.ts =====
import { mkdtemp, rm, stat } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import { afterEach, describe, expect, it } from "vitest";
import { runCli } from "../run-cli";
import { CliIo } from "../types";

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-backup-restore-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const runWithDb = async (
  argv: string[],
  dbPath: string,
): Promise<{ exitCode: number; stdout: string; stderr: string }> => {
  const { io, stdout, stderr } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return {
    exitCode,
    stdout: stdout.join(""),
    stderr: stderr.join(""),
  };
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

afterEach(async () => {
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("appctl backup/restore", () => {
  it("creates backup artifact and restores round-trip locally", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    await runWithDb(["user", "create", "--email", "first@example.com", "--status", "ACTIVE"], dbPath);

    const outDir = await mkdtemp(join(tmpdir(), "appctl-backup-out-"));
    tempDirs.push(outDir);
    const backupPath = join(outDir, "backup.db");

    const backup = await runWithDb(["db", "backup", "--out", backupPath], dbPath);
    expect(backup.exitCode).toBe(0);

    const backupStat = await stat(backupPath);
    expect(backupStat.size).toBeGreaterThan(0);

    await runWithDb(["user", "create", "--email", "second@example.com", "--status", "ACTIVE"], dbPath);

    const restoreWithoutYes = await runWithDb(["db", "restore", "--from", backupPath], dbPath);
    expect(restoreWithoutYes.exitCode).toBe(6);

    const restore = await runWithDb(["db", "restore", "--from", backupPath, "--yes"], dbPath);
    expect(restore.exitCode).toBe(0);

    const users = await runWithDb(["--json", "user", "list"], dbPath);
    const payload = JSON.parse(users.stdout);
    const emails = payload.data.map((user: { email: string }) => user.email);

    expect(emails).toContain("first@example.com");
    expect(emails).not.toContain("second@example.com");
  });

  it("enforces prod dangerous-op guardrails for backup and restore", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    const outDir = await mkdtemp(join(tmpdir(), "appctl-prod-guard-"));
    tempDirs.push(outDir);
    const backupPath = join(outDir, "backup.db");

    const prodBackupNoForce = await runWithDb(
      ["db", "backup", "--out", backupPath, "--env", "prod", "--yes"],
      dbPath,
    );
    expect(prodBackupNoForce.exitCode).toBe(6);

    const prodBackupNoToken = await runWithDb(
      ["db", "backup", "--out", backupPath, "--env", "prod", "--yes", "--force-prod"],
      dbPath,
    );
    expect(prodBackupNoToken.exitCode).toBe(3);

    const tokenCreate = await runWithDb(["--json", "auth", "token", "create", "--name", "prod-guard"], dbPath);
    const token = JSON.parse(tokenCreate.stdout).data.token as string;

    const prodBackupWithToken = await runWithDb(
      [
        "db",
        "backup",
        "--out",
        backupPath,
        "--env",
        "prod",
        "--yes",
        "--force-prod",
        "--token",
        token,
      ],
      dbPath,
    );
    expect(prodBackupWithToken.exitCode).toBe(0);

    const prodRestoreNoForce = await runWithDb(
      ["db", "restore", "--from", backupPath, "--env", "prod", "--yes", "--token", token],
      dbPath,
    );
    expect(prodRestoreNoForce.exitCode).toBe(6);

    const prodRestoreNoToken = await runWithDb(
      ["db", "restore", "--from", backupPath, "--env", "prod", "--yes", "--force-prod"],
      dbPath,
    );
    expect(prodRestoreNoToken.exitCode).toBe(3);

    const prodRestoreWithToken = await runWithDb(
      [
        "db",
        "restore",
        "--from",
        backupPath,
        "--env",
        "prod",
        "--yes",
        "--force-prod",
        "--token",
        token,
      ],
      dbPath,
    );
    expect(prodRestoreWithToken.exitCode).toBe(0);
  });
});


===== FILE: src/cli/__tests__/db-core.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";
import { runCli } from "../run-cli";
import { CliIo } from "../types";

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-db-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const runWithDb = async (
  argv: string[],
  dbPath: string,
): Promise<{ exitCode: number; stdout: string; stderr: string }> => {
  const { io, stdout, stderr } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return {
    exitCode,
    stdout: stdout.join(""),
    stderr: stderr.join(""),
  };
};

afterEach(async () => {
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("appctl db core", () => {
  it("migrate is idempotent", async () => {
    const dbPath = await createDbPath();

    const first = await runWithDb(["--json", "db", "migrate"], dbPath);
    const second = await runWithDb(["--json", "db", "migrate"], dbPath);
    const status = await runWithDb(["--json", "db", "status"], dbPath);

    expect(first.exitCode).toBe(0);
    expect(second.exitCode).toBe(0);

    const secondPayload = JSON.parse(second.stdout);
    expect(secondPayload.data.applied).toEqual([]);

    const statusPayload = JSON.parse(status.stdout);
    expect(statusPayload.data.pendingCount).toBe(0);
  });

  it("seed is idempotent", async () => {
    const dbPath = await createDbPath();
    await runWithDb(["db", "migrate"], dbPath);

    const first = await runWithDb(["--json", "db", "seed"], dbPath);
    const second = await runWithDb(["--json", "db", "seed"], dbPath);

    expect(first.exitCode).toBe(0);
    expect(second.exitCode).toBe(0);

    const db = new Database(dbPath);
    const count = db.prepare("SELECT COUNT(*) AS count FROM roles").get() as { count: number };
    db.close();

    expect(count.count).toBe(3);
  });

  it("seed fails with precondition when migrations are pending", async () => {
    const dbPath = await createDbPath();

    const result = await runWithDb(["db", "seed"], dbPath);

    expect(result.exitCode).toBe(6);
    expect(result.stderr).toContain("Migrations are pending");
  });

  it("doctor fails when schema is not current", async () => {
    const dbPath = await createDbPath();

    const result = await runWithDb(["doctor"], dbPath);

    expect(result.exitCode).toBe(6);
    expect(result.stderr).toContain("Schema is not up to date");
  });

  it("doctor detects invalid sqlite pragmas", async () => {
    const dbPath = await createDbPath();
    await runWithDb(["db", "migrate"], dbPath);

    const db = new Database(dbPath);
    db.pragma("journal_mode = DELETE");
    db.close();

    const result = await runWithDb(["doctor"], dbPath);

    expect(result.exitCode).toBe(6);
    expect(result.stderr).toContain("SQLite pragmas invalid");
  });

  it("seed fails closed when audit insert fails and roles are rolled back", async () => {
    const dbPath = await createDbPath();
    await runWithDb(["db", "migrate"], dbPath);

    const db = new Database(dbPath);
    db.exec("DROP TABLE audit_log");
    db.close();

    const result = await runWithDb(["db", "seed"], dbPath);
    expect(result.exitCode).toBe(1);

    const check = new Database(dbPath);
    const roles = check.prepare("SELECT COUNT(*) AS count FROM roles").get() as { count: number };
    check.close();

    expect(roles.count).toBe(0);
  });
});


===== FILE: src/cli/__tests__/event.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";
import { runCli } from "../run-cli";
import { CliIo } from "../types";

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-event-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const runWithDb = async (
  argv: string[],
  dbPath: string,
): Promise<{ exitCode: number; stdout: string; stderr: string }> => {
  const { io, stdout, stderr } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return {
    exitCode,
    stdout: stdout.join(""),
    stderr: stderr.join(""),
  };
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

afterEach(async () => {
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("appctl event lifecycle", () => {
  it("event create validates ISO inputs and enforces unique slug", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    const bad = await runWithDb(
      [
        "event",
        "create",
        "--slug",
        "spring-launch",
        "--title",
        "Spring Launch",
        "--start",
        "invalid-date",
        "--end",
        "2026-04-01T15:00:00Z",
        "--tz",
        "UTC",
      ],
      dbPath,
    );

    const first = await runWithDb(
      [
        "event",
        "create",
        "--slug",
        "spring-launch",
        "--title",
        "Spring Launch",
        "--start",
        "2026-04-01T14:00:00Z",
        "--end",
        "2026-04-01T15:00:00Z",
        "--tz",
        "UTC",
      ],
      dbPath,
    );

    const duplicate = await runWithDb(
      [
        "event",
        "create",
        "--slug",
        "spring-launch",
        "--title",
        "Duplicate",
        "--start",
        "2026-04-01T14:00:00Z",
        "--end",
        "2026-04-01T15:00:00Z",
        "--tz",
        "UTC",
      ],
      dbPath,
    );

    expect(bad.exitCode).toBe(2);
    expect(first.exitCode).toBe(0);
    expect(duplicate.exitCode).toBe(5);
  });

  it("event update changes only provided fields", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    await runWithDb(
      [
        "event",
        "create",
        "--slug",
        "update-test",
        "--title",
        "Before",
        "--start",
        "2026-04-01T14:00:00Z",
        "--end",
        "2026-04-01T15:00:00Z",
        "--tz",
        "UTC",
      ],
      dbPath,
    );

    const update = await runWithDb(
      ["--json", "event", "update", "--slug", "update-test", "--title", "After"],
      dbPath,
    );

    expect(update.exitCode).toBe(0);
    const payload = JSON.parse(update.stdout);
    expect(payload.data.title).toBe("After");
    expect(payload.data.start_at).toBe("2026-04-01T14:00:00.000Z");
    expect(payload.data.end_at).toBe("2026-04-01T15:00:00.000Z");
  });

  it("event publish is idempotent and audited", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    await runWithDb(
      [
        "event",
        "create",
        "--slug",
        "publish-test",
        "--title",
        "Publish Test",
        "--start",
        "2026-04-01T14:00:00Z",
        "--end",
        "2026-04-01T15:00:00Z",
        "--tz",
        "UTC",
      ],
      dbPath,
    );

    const first = await runWithDb(["event", "publish", "--slug", "publish-test"], dbPath);
    const second = await runWithDb(["event", "publish", "--slug", "publish-test"], dbPath);

    expect(first.exitCode).toBe(0);
    expect(second.exitCode).toBe(0);

    const db = new Database(dbPath);
    const eventRow = db.prepare("SELECT status FROM events WHERE slug = 'publish-test'").get() as {
      status: string;
    };
    const auditCount = db
      .prepare("SELECT COUNT(*) AS count FROM audit_log WHERE action = 'event.publish'")
      .get() as { count: number };
    db.close();

    expect(eventRow.status).toBe("PUBLISHED");
    expect(auditCount.count).toBe(2);
  });

  it("event cancel sets CANCELLED and stores reason metadata", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    await runWithDb(
      [
        "event",
        "create",
        "--slug",
        "cancel-test",
        "--title",
        "Cancel Test",
        "--start",
        "2026-04-01T14:00:00Z",
        "--end",
        "2026-04-01T15:00:00Z",
        "--tz",
        "UTC",
      ],
      dbPath,
    );

    const cancel = await runWithDb(
      ["event", "cancel", "--slug", "cancel-test", "--reason", "verification"],
      dbPath,
    );

    expect(cancel.exitCode).toBe(0);

    const db = new Database(dbPath);
    const eventRow = db.prepare("SELECT status FROM events WHERE slug = 'cancel-test'").get() as {
      status: string;
    };
    const auditMeta = db
      .prepare("SELECT metadata FROM audit_log WHERE action = 'event.cancel' ORDER BY created_at DESC LIMIT 1")
      .get() as { metadata: string };
    db.close();

    expect(eventRow.status).toBe("CANCELLED");
    expect(JSON.parse(auditMeta.metadata).reason).toBe("verification");
  });

  it("event list supports status and date filters", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    await runWithDb(
      [
        "event",
        "create",
        "--slug",
        "list-one",
        "--title",
        "List One",
        "--start",
        "2026-04-01T14:00:00Z",
        "--end",
        "2026-04-01T15:00:00Z",
        "--tz",
        "UTC",
      ],
      dbPath,
    );
    await runWithDb(
      [
        "event",
        "create",
        "--slug",
        "list-two",
        "--title",
        "List Two",
        "--start",
        "2026-05-01T14:00:00Z",
        "--end",
        "2026-05-01T15:00:00Z",
        "--tz",
        "UTC",
      ],
      dbPath,
    );

    await runWithDb(["event", "cancel", "--slug", "list-two", "--reason", "verification"], dbPath);

    const filtered = await runWithDb(
      ["--json", "event", "list", "--status", "CANCELLED", "--from", "2026-04-15T00:00:00Z"],
      dbPath,
    );

    expect(filtered.exitCode).toBe(0);
    const payload = JSON.parse(filtered.stdout);
    expect(payload.data).toHaveLength(1);
    expect(payload.data[0].slug).toBe("list-two");
    expect(payload.data[0].status).toBe("CANCELLED");
  });
});


===== FILE: src/cli/__tests__/registration-export.test.ts =====
import { mkdtemp, readFile, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";
import { runCli } from "../run-cli";
import { CliIo } from "../types";

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-reg-export-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const runWithDb = async (
  argv: string[],
  dbPath: string,
): Promise<{ exitCode: number; stdout: string; stderr: string }> => {
  const { io, stdout, stderr } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return {
    exitCode,
    stdout: stdout.join(""),
    stderr: stderr.join(""),
  };
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

const setupUsersAndEvent = async (dbPath: string): Promise<void> => {
  await runWithDb(["user", "create", "--email", "admin@example.com", "--status", "ACTIVE"], dbPath);
  await runWithDb(["user", "create", "--email", "guest@example.com", "--status", "ACTIVE"], dbPath);
  await runWithDb(
    [
      "event",
      "create",
      "--slug",
      "spring-launch",
      "--title",
      "Spring Launch",
      "--start",
      "2026-04-01T14:00:00Z",
      "--end",
      "2026-04-01T15:00:00Z",
      "--tz",
      "UTC",
      "--capacity",
      "1",
    ],
    dbPath,
  );
};

afterEach(async () => {
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("appctl registration/export", () => {
  it("full events place new registrations in WAITLISTED", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    await setupUsersAndEvent(dbPath);

    const first = await runWithDb(["--json", "reg", "add", "--event", "spring-launch", "--user", "admin@example.com"], dbPath);
    const second = await runWithDb(["--json", "reg", "add", "--event", "spring-launch", "--user", "guest@example.com"], dbPath);

    expect(first.exitCode).toBe(0);
    expect(second.exitCode).toBe(0);

    expect(JSON.parse(first.stdout).data.status).toBe("REGISTERED");
    expect(JSON.parse(second.stdout).data.status).toBe("WAITLISTED");
  });

  it("reg remove transitions to CANCELLED without hard delete", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    await setupUsersAndEvent(dbPath);

    await runWithDb(["reg", "add", "--event", "spring-launch", "--user", "admin@example.com"], dbPath);
    const removed = await runWithDb(
      ["--json", "reg", "remove", "--event", "spring-launch", "--user", "admin@example.com", "--reason", "test"],
      dbPath,
    );

    expect(removed.exitCode).toBe(0);
    expect(JSON.parse(removed.stdout).data.status).toBe("CANCELLED");

    const db = new Database(dbPath);
    const count = db.prepare("SELECT COUNT(*) AS count FROM event_registrations").get() as { count: number };
    db.close();

    expect(count.count).toBe(1);
  });

  it("checkin transitions registration to CHECKED_IN", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    await setupUsersAndEvent(dbPath);

    await runWithDb(["reg", "add", "--event", "spring-launch", "--user", "admin@example.com"], dbPath);
    const checkedIn = await runWithDb(
      ["--json", "checkin", "--event", "spring-launch", "--user", "admin@example.com"],
      dbPath,
    );

    expect(checkedIn.exitCode).toBe(0);
    expect(JSON.parse(checkedIn.stdout).data.status).toBe("CHECKED_IN");
  });

  it("event export writes csv and json files", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    await setupUsersAndEvent(dbPath);

    await runWithDb(["reg", "add", "--event", "spring-launch", "--user", "admin@example.com"], dbPath);

    const outDir = await mkdtemp(join(tmpdir(), "appctl-export-out-"));
    tempDirs.push(outDir);
    const csvOut = join(outDir, "spring-launch.csv");
    const jsonOut = join(outDir, "spring-launch.json");

    const csv = await runWithDb(
      ["event", "export", "--slug", "spring-launch", "--format", "csv", "--out", csvOut],
      dbPath,
    );
    const json = await runWithDb(
      ["event", "export", "--slug", "spring-launch", "--format", "json", "--out", jsonOut],
      dbPath,
    );

    expect(csv.exitCode).toBe(0);
    expect(json.exitCode).toBe(0);

    const csvContent = await readFile(csvOut, "utf8");
    const jsonContent = await readFile(jsonOut, "utf8");

    expect(csvContent).toContain("id,status,user_id");
    expect(JSON.parse(jsonContent)).toHaveLength(1);
  });

  it("include-email requires token outside local and mutations are audited", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    await setupUsersAndEvent(dbPath);

    await runWithDb(["reg", "add", "--event", "spring-launch", "--user", "admin@example.com"], dbPath);

    const outDir = await mkdtemp(join(tmpdir(), "appctl-export-sec-"));
    tempDirs.push(outDir);
    const secureOut = join(outDir, "secure.json");

    const withoutToken = await runWithDb(
      [
        "event",
        "export",
        "--slug",
        "spring-launch",
        "--format",
        "json",
        "--out",
        secureOut,
        "--include-email",
        "--env",
        "staging",
      ],
      dbPath,
    );
    expect(withoutToken.exitCode).toBe(3);

    const created = await runWithDb(["--json", "auth", "token", "create", "--name", "exp"], dbPath);
    const token = JSON.parse(created.stdout).data.token as string;

    const withToken = await runWithDb(
      [
        "event",
        "export",
        "--slug",
        "spring-launch",
        "--format",
        "json",
        "--out",
        secureOut,
        "--include-email",
        "--env",
        "staging",
        "--token",
        token,
      ],
      dbPath,
    );

    expect(withToken.exitCode).toBe(0);
    const exported = JSON.parse(await readFile(secureOut, "utf8"));
    expect(exported[0].user_email).toBe("admin@example.com");

    const checkin = await runWithDb(["checkin", "--event", "spring-launch", "--user", "admin@example.com"], dbPath);
    expect(checkin.exitCode).toBe(0);

    const db = new Database(dbPath);
    const addAudit = db
      .prepare("SELECT COUNT(*) AS count FROM audit_log WHERE action = 'registration.add'")
      .get() as { count: number };
    const checkinAudit = db
      .prepare("SELECT COUNT(*) AS count FROM audit_log WHERE action = 'registration.checkin'")
      .get() as { count: number };
    const exportAudit = db
      .prepare("SELECT COUNT(*) AS count FROM audit_log WHERE action = 'event.export'")
      .get() as { count: number };
    db.close();

    expect(addAudit.count).toBeGreaterThan(0);
    expect(checkinAudit.count).toBeGreaterThan(0);
    expect(exportAudit.count).toBeGreaterThan(0);
  });
});


===== FILE: src/cli/__tests__/run-cli.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import { afterEach, describe, expect, it } from "vitest";
import { resolveConfig } from "../config";
import { mapErrorToExitCode, runCli } from "../run-cli";
import { CliIo } from "../types";

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const runWithDb = async (
  argv: string[],
  dbPath: string,
): Promise<{ exitCode: number; stdout: string; stderr: string }> => {
  const { io, stdout, stderr } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return {
    exitCode,
    stdout: stdout.join(""),
    stderr: stderr.join(""),
  };
};

afterEach(async () => {
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("appctl foundation", () => {
  it("matches help snapshot", async () => {
    const { io, stdout } = createIo();
    const exitCode = await runCli(["--help"], io);

    expect(exitCode).toBe(0);
    expect(stdout.join("")).toMatchSnapshot();
  });

  it("returns JSON envelope for doctor", async () => {
    const dbPath = await createDbPath();
    await runWithDb(["db", "migrate"], dbPath);

    const { exitCode, stdout } = await runWithDb(["--json", "--env", "local", "doctor"], dbPath);

    expect(exitCode).toBe(0);

    const payload = JSON.parse(stdout);
    expect(payload).toMatchObject({
      ok: true,
      command: "doctor",
      env: "local",
      warnings: [],
      errors: [],
    });
    expect(typeof payload.request_id).toBe("string");
  });

  it("applies config precedence flags > env > file > defaults", () => {
    const config = resolveConfig({
      fileConfig: {
        env: "staging",
        output: {
          defaultFormat: "text",
        },
      },
      envVars: {
        APPCTL_ENV: "prod",
        APPCTL_OUTPUT_FORMAT: "text",
      },
      flags: {
        env: "local",
        json: true,
      },
    });

    expect(config.env).toBe("local");
    expect(config.output.defaultFormat).toBe("json");
  });

  it("returns usage error exit code 2 for invalid env", async () => {
    const { io } = createIo();
    const exitCode = await runCli(["--env", "qa", "doctor"], io);

    expect(exitCode).toBe(2);
  });

  it("maps unexpected errors to exit code 1", () => {
    expect(mapErrorToExitCode(new Error("boom"))).toBe(1);
  });
});



===== FILE: src/cli/auth-users.ts =====
import { createHash, randomUUID } from "node:crypto";
import { mkdirSync } from "node:fs";
import { dirname, resolve } from "node:path";
import Database from "better-sqlite3";
import { dbStatus } from "./db";
import { authError, conflictError, notFoundError, preconditionError, usageError } from "./errors";
import { AppConfig } from "./types";

const openDb = (config: AppConfig): Database.Database => {
  const dbPath = resolve(config.db.file);
  mkdirSync(dirname(dbPath), { recursive: true });

  const db = new Database(dbPath);
  db.pragma(`busy_timeout = ${config.db.busyTimeoutMs}`);
  db.pragma("foreign_keys = ON");
  db.pragma("journal_mode = WAL");
  return db;
};

const hashToken = (token: string): string => createHash("sha256").update(token).digest("hex");

const requireSchemaCurrent = (config: AppConfig): void => {
  const status = dbStatus(config);
  if (status.pendingCount > 0) {
    throw preconditionError("Migrations are pending. Run `appctl db migrate` first.");
  }
};

const ensureUserExists = (db: Database.Database, userId: string): void => {
  const found = db.prepare("SELECT id FROM users WHERE id = ?").get(userId) as { id: string } | undefined;
  if (!found) {
    throw notFoundError(`User not found: ${userId}`);
  }
};

const appendAudit = (
  db: Database.Database,
  action: string,
  requestId: string,
  metadata?: Record<string, unknown>,
): void => {
  db.prepare(
    `
INSERT INTO audit_log (
  id,
  actor_type,
  actor_id,
  action,
  target_type,
  target_id,
  metadata,
  created_at,
  request_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
  ).run(
    randomUUID(),
    "SERVICE",
    null,
    action,
    "system",
    null,
    metadata ? JSON.stringify(metadata) : null,
    new Date().toISOString(),
    requestId,
  );
};

const resolveToken = (config: AppConfig, token: string): { id: string } | undefined => {
  const db = openDb(config);
  try {
    const tokenHash = hashToken(token);
    return db
      .prepare("SELECT id FROM service_tokens WHERE token_hash = ? AND revoked_at IS NULL")
      .get(tokenHash) as { id: string } | undefined;
  } finally {
    db.close();
  }
};

const requireWriteAuth = (config: AppConfig, providedToken?: string): void => {
  if (config.env === "local") {
    return;
  }

  if (!providedToken) {
    throw authError("A valid super-admin token is required for write commands in staging/prod.");
  }

  const token = resolveToken(config, providedToken);
  if (!token) {
    throw authError("Invalid or revoked token.");
  }
};

export interface CreateTokenResult {
  id: string;
  name: string;
  token: string;
}

export const authTokenCreate = (
  config: AppConfig,
  requestId: string,
  name: string,
  ttlDays?: number,
): CreateTokenResult => {
  requireSchemaCurrent(config);

  if (!name.trim()) {
    throw usageError("Token name is required.");
  }

  const token = `sat_${randomUUID().replace(/-/g, "")}`;
  const tokenHash = hashToken(token);
  const db = openDb(config);

  try {
    const id = randomUUID();

    const run = db.transaction(() => {
      db.prepare(
        "INSERT INTO service_tokens (id, name, token_hash, created_at, revoked_at, last_used_at) VALUES (?, ?, ?, ?, NULL, NULL)",
      ).run(id, name, tokenHash, new Date().toISOString());

      appendAudit(db, "auth.token.create", requestId, {
        tokenId: id,
        name,
        ttlDays: ttlDays ?? null,
      });
    });

    run();

    return {
      id,
      name,
      token,
    };
  } finally {
    db.close();
  }
};

export interface RevokeTokenResult {
  id: string;
  revoked: boolean;
}

export const authTokenRevoke = (config: AppConfig, requestId: string, id: string): RevokeTokenResult => {
  requireSchemaCurrent(config);

  const db = openDb(config);

  try {
    const run = db.transaction(() => {
      const result = db
        .prepare("UPDATE service_tokens SET revoked_at = ? WHERE id = ? AND revoked_at IS NULL")
        .run(new Date().toISOString(), id);

      if (result.changes === 0) {
        throw notFoundError(`Token not found or already revoked: ${id}`);
      }

      appendAudit(db, "auth.token.revoke", requestId, {
        tokenId: id,
      });
    });

    run();

    return {
      id,
      revoked: true,
    };
  } finally {
    db.close();
  }
};

export interface UserRecord {
  id: string;
  email: string;
  status: string;
  created_at: string;
  updated_at: string;
}

const normalizeStatus = (status?: string): string => {
  if (!status) {
    return "PENDING";
  }

  const upper = status.toUpperCase();
  if (!["ACTIVE", "DISABLED", "PENDING"].includes(upper)) {
    throw usageError("Invalid status. Allowed: PENDING, ACTIVE, DISABLED.");
  }

  return upper;
};

export const userCreate = (
  config: AppConfig,
  requestId: string,
  email: string,
  status: string | undefined,
  token?: string,
): UserRecord => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const normalizedEmail = email.trim().toLowerCase();
  if (!normalizedEmail) {
    throw usageError("Email is required.");
  }

  const normalizedStatus = normalizeStatus(status);
  const db = openDb(config);

  try {
    const id = randomUUID();
    const now = new Date().toISOString();

    const run = db.transaction(() => {
      try {
        db.prepare("INSERT INTO users (id, email, status, created_at, updated_at) VALUES (?, ?, ?, ?, ?)").run(
          id,
          normalizedEmail,
          normalizedStatus,
          now,
          now,
        );
      } catch (error) {
        if (error instanceof Error && error.message.includes("UNIQUE constraint failed: users.email")) {
          throw conflictError(`User already exists for email: ${normalizedEmail}`);
        }
        throw error;
      }

      appendAudit(db, "user.create", requestId, {
        userId: id,
        email: normalizedEmail,
      });
    });

    run();

    return {
      id,
      email: normalizedEmail,
      status: normalizedStatus,
      created_at: now,
      updated_at: now,
    };
  } finally {
    db.close();
  }
};

export const userList = (
  config: AppConfig,
  filters: { role?: string; status?: string; search?: string },
): UserRecord[] => {
  requireSchemaCurrent(config);

  const db = openDb(config);
  try {
    const params: unknown[] = [];
    const clauses: string[] = [];
    const joins: string[] = [];

    if (filters.role) {
      joins.push("JOIN user_roles ur ON ur.user_id = u.id JOIN roles r ON r.id = ur.role_id");
      clauses.push("r.name = ?");
      params.push(filters.role.toUpperCase());
    }

    if (filters.status) {
      clauses.push("u.status = ?");
      params.push(filters.status.toUpperCase());
    }

    if (filters.search) {
      clauses.push("u.email LIKE ?");
      params.push(`%${filters.search}%`);
    }

    const query = `
SELECT DISTINCT u.id, u.email, u.status, u.created_at, u.updated_at
FROM users u
${joins.join(" ")}
${clauses.length ? `WHERE ${clauses.join(" AND ")}` : ""}
ORDER BY u.created_at ASC
`;

    return db.prepare(query).all(...params) as UserRecord[];
  } finally {
    db.close();
  }
};

export const userShow = (config: AppConfig, options: { id?: string; email?: string }): UserRecord => {
  requireSchemaCurrent(config);

  if (!options.id && !options.email) {
    throw usageError("Provide --id or --email.");
  }

  const db = openDb(config);
  try {
    const row = options.id
      ? (db.prepare("SELECT id, email, status, created_at, updated_at FROM users WHERE id = ?").get(options.id) as
          | UserRecord
          | undefined)
      : (db
          .prepare("SELECT id, email, status, created_at, updated_at FROM users WHERE email = ?")
          .get(options.email?.toLowerCase()) as UserRecord | undefined);

    if (!row) {
      throw notFoundError("User not found.");
    }

    return row;
  } finally {
    db.close();
  }
};

const setUserStatus = (
  config: AppConfig,
  requestId: string,
  id: string,
  status: "ACTIVE" | "DISABLED",
  action: "user.enable" | "user.disable",
  token?: string,
  reason?: string,
): UserRecord => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const db = openDb(config);
  try {
    const now = new Date().toISOString();

    const run = db.transaction(() => {
      const result = db
        .prepare("UPDATE users SET status = ?, updated_at = ? WHERE id = ?")
        .run(status, now, id);

      if (result.changes === 0) {
        throw notFoundError(`User not found: ${id}`);
      }

      appendAudit(db, action, requestId, {
        userId: id,
        reason: reason ?? null,
      });
    });

    run();

    return db.prepare("SELECT id, email, status, created_at, updated_at FROM users WHERE id = ?").get(id) as UserRecord;
  } finally {
    db.close();
  }
};

export const userDisable = (
  config: AppConfig,
  requestId: string,
  id: string,
  token?: string,
  reason?: string,
): UserRecord => setUserStatus(config, requestId, id, "DISABLED", "user.disable", token, reason);

export const userEnable = (
  config: AppConfig,
  requestId: string,
  id: string,
  token?: string,
): UserRecord => setUserStatus(config, requestId, id, "ACTIVE", "user.enable", token);

export interface UserRoleMutationResult {
  userId: string;
  role: string;
}

export const userRoleAdd = (
  config: AppConfig,
  requestId: string,
  id: string,
  role: string,
  token?: string,
): UserRoleMutationResult => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const normalizedRole = role.toUpperCase();
  const db = openDb(config);

  try {
    const run = db.transaction(() => {
      ensureUserExists(db, id);

      const roleRow = db.prepare("SELECT id FROM roles WHERE name = ?").get(normalizedRole) as
        | { id: string }
        | undefined;

      if (!roleRow) {
        throw notFoundError(`Role not found: ${normalizedRole}`);
      }

      db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(id, roleRow.id);

      appendAudit(db, "user.role.add", requestId, {
        userId: id,
        role: normalizedRole,
      });
    });

    run();

    return {
      userId: id,
      role: normalizedRole,
    };
  } finally {
    db.close();
  }
};

export const userRoleRemove = (
  config: AppConfig,
  requestId: string,
  id: string,
  role: string,
  token?: string,
): UserRoleMutationResult => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const normalizedRole = role.toUpperCase();
  const db = openDb(config);

  try {
    const run = db.transaction(() => {
      ensureUserExists(db, id);

      const roleRow = db.prepare("SELECT id FROM roles WHERE name = ?").get(normalizedRole) as
        | { id: string }
        | undefined;

      if (!roleRow) {
        throw notFoundError(`Role not found: ${normalizedRole}`);
      }

      db.prepare("DELETE FROM user_roles WHERE user_id = ? AND role_id = ?").run(id, roleRow.id);

      appendAudit(db, "user.role.remove", requestId, {
        userId: id,
        role: normalizedRole,
      });
    });

    run();

    return {
      userId: id,
      role: normalizedRole,
    };
  } finally {
    db.close();
  }
};


===== FILE: src/cli/config.ts =====
import { cosmiconfig } from "cosmiconfig";
import { z } from "zod";
import { AppConfig, GlobalOptions } from "./types";

const envSchema = z.enum(["local", "staging", "prod"]);

const configFileSchema = z.object({
  env: envSchema.optional(),
  db: z
    .object({
      mode: z.literal("sqlite").optional(),
      file: z.string().min(1).optional(),
      busyTimeoutMs: z.number().int().positive().optional(),
    })
    .optional(),
  security: z
    .object({
      requireTokenInStaging: z.boolean().optional(),
      requireTokenInProd: z.boolean().optional(),
      dangerousOpsRequireExplicitProd: z.boolean().optional(),
    })
    .optional(),
  audit: z
    .object({
      strict: z.boolean().optional(),
    })
    .optional(),
  output: z
    .object({
      defaultFormat: z.enum(["text", "json"]).optional(),
    })
    .optional(),
});

type ConfigFileShape = z.infer<typeof configFileSchema>;

export const defaultConfig: AppConfig = {
  env: "local",
  db: {
    mode: "sqlite",
    file: "./data/app.db",
    busyTimeoutMs: 5000,
  },
  security: {
    requireTokenInStaging: true,
    requireTokenInProd: true,
    dangerousOpsRequireExplicitProd: true,
  },
  audit: {
    strict: true,
  },
  output: {
    defaultFormat: "text",
  },
};

interface ResolveConfigInput {
  fileConfig?: ConfigFileShape;
  envVars?: NodeJS.ProcessEnv;
  flags?: GlobalOptions;
}

const toBool = (value: string | undefined): boolean | undefined => {
  if (value === undefined) {
    return undefined;
  }
  if (value.toLowerCase() === "true") {
    return true;
  }
  if (value.toLowerCase() === "false") {
    return false;
  }
  return undefined;
};

const parseEnv = (envVars: NodeJS.ProcessEnv): ConfigFileShape => {
  const env = envSchema.safeParse(envVars.APPCTL_ENV);
  const outputFormat = z.enum(["text", "json"]).safeParse(envVars.APPCTL_OUTPUT_FORMAT);

  return {
    env: env.success ? env.data : undefined,
    db: {
      mode: "sqlite",
      file: envVars.APPCTL_DB_FILE,
      busyTimeoutMs: envVars.APPCTL_DB_BUSY_TIMEOUT_MS
        ? Number(envVars.APPCTL_DB_BUSY_TIMEOUT_MS)
        : undefined,
    },
    security: {
      requireTokenInStaging: toBool(envVars.APPCTL_REQUIRE_TOKEN_STAGING),
      requireTokenInProd: toBool(envVars.APPCTL_REQUIRE_TOKEN_PROD),
      dangerousOpsRequireExplicitProd: toBool(envVars.APPCTL_DANGEROUS_REQUIRE_EXPLICIT_PROD),
    },
    audit: {
      strict: toBool(envVars.APPCTL_AUDIT_STRICT),
    },
    output: {
      defaultFormat: outputFormat.success ? outputFormat.data : undefined,
    },
  };
};

const mergeConfig = (base: AppConfig, incoming: ConfigFileShape): AppConfig => ({
  env: incoming.env ?? base.env,
  db: {
    mode: incoming.db?.mode ?? base.db.mode,
    file: incoming.db?.file ?? base.db.file,
    busyTimeoutMs: incoming.db?.busyTimeoutMs ?? base.db.busyTimeoutMs,
  },
  security: {
    requireTokenInStaging:
      incoming.security?.requireTokenInStaging ?? base.security.requireTokenInStaging,
    requireTokenInProd: incoming.security?.requireTokenInProd ?? base.security.requireTokenInProd,
    dangerousOpsRequireExplicitProd:
      incoming.security?.dangerousOpsRequireExplicitProd ??
      base.security.dangerousOpsRequireExplicitProd,
  },
  audit: {
    strict: incoming.audit?.strict ?? base.audit.strict,
  },
  output: {
    defaultFormat: incoming.output?.defaultFormat ?? base.output.defaultFormat,
  },
});

export const resolveConfig = ({
  fileConfig,
  envVars = process.env,
  flags,
}: ResolveConfigInput): AppConfig => {
  let resolved = mergeConfig(defaultConfig, fileConfig ?? {});
  resolved = mergeConfig(resolved, parseEnv(envVars));

  if (flags?.env) {
    resolved.env = flags.env;
  }

  if (flags?.json) {
    resolved.output.defaultFormat = "json";
  }

  return resolved;
};

const searchPlaces = [
  "appctl.config.json",
  ".appctlrc",
  ".appctlrc.json",
  ".appctlrc.yaml",
  ".appctlrc.yml",
];

export const loadConfigFromDisk = async (cwd = process.cwd()): Promise<ConfigFileShape | undefined> => {
  const explorer = cosmiconfig("appctl", {
    stopDir: cwd,
    searchPlaces,
  });

  const result = await explorer.search(cwd);
  if (!result) {
    return undefined;
  }

  return configFileSchema.parse(result.config);
};


===== FILE: src/cli/db.ts =====
import { existsSync, mkdirSync } from "node:fs";
import { dirname, resolve } from "node:path";
import { createHash, randomUUID } from "node:crypto";
import Database from "better-sqlite3";
import { authError, preconditionError } from "./errors";
import { AppConfig, RuntimeEnv } from "./types";

interface Migration {
  name: string;
  sql: string;
}

const migrations: Migration[] = [
  {
    name: "001_core_schema",
    sql: `
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  status TEXT NOT NULL,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS roles (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS user_roles (
  user_id TEXT NOT NULL,
  role_id TEXT NOT NULL,
  UNIQUE(user_id, role_id),
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (role_id) REFERENCES roles(id)
);

CREATE TABLE IF NOT EXISTS service_tokens (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  token_hash TEXT NOT NULL,
  created_at TEXT NOT NULL,
  revoked_at TEXT,
  last_used_at TEXT
);

CREATE TABLE IF NOT EXISTS events (
  id TEXT PRIMARY KEY,
  slug TEXT NOT NULL UNIQUE,
  title TEXT NOT NULL,
  start_at TEXT NOT NULL,
  end_at TEXT NOT NULL,
  timezone TEXT NOT NULL,
  status TEXT NOT NULL,
  capacity INTEGER,
  created_by TEXT,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS event_registrations (
  id TEXT PRIMARY KEY,
  event_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  status TEXT NOT NULL,
  UNIQUE(event_id, user_id),
  FOREIGN KEY (event_id) REFERENCES events(id),
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS audit_log (
  id TEXT PRIMARY KEY,
  actor_type TEXT NOT NULL,
  actor_id TEXT,
  action TEXT NOT NULL,
  target_type TEXT NOT NULL,
  target_id TEXT,
  metadata TEXT,
  created_at TEXT NOT NULL,
  request_id TEXT NOT NULL
);
`,
  },
];

const ensureMetaTable = (db: Database.Database): void => {
  db.exec(`
CREATE TABLE IF NOT EXISTS app_migrations (
  name TEXT PRIMARY KEY,
  applied_at TEXT NOT NULL
);
`);
};

const openDb = (config: AppConfig, enforcePragmas = true): Database.Database => {
  const dbPath = resolve(config.db.file);
  mkdirSync(dirname(dbPath), { recursive: true });

  const db = new Database(dbPath);
  if (enforcePragmas) {
    db.pragma(`busy_timeout = ${config.db.busyTimeoutMs}`);
    db.pragma("foreign_keys = ON");
    db.pragma("journal_mode = WAL");
  }
  return db;
};

const getAppliedMigrationNames = (db: Database.Database): string[] => {
  const hasMeta = db
    .prepare("SELECT COUNT(1) AS count FROM sqlite_master WHERE type = 'table' AND name = 'app_migrations'")
    .get() as { count: number };

  if (hasMeta.count === 0) {
    return [];
  }

  const rows = db.prepare("SELECT name FROM app_migrations ORDER BY applied_at ASC").all() as {
    name: string;
  }[];
  return rows.map((row) => row.name);
};

const appendAudit = (
  db: Database.Database,
  action: string,
  requestId: string,
  metadata?: Record<string, unknown>,
): void => {
  db.prepare(
    `
INSERT INTO audit_log (
  id,
  actor_type,
  actor_id,
  action,
  target_type,
  target_id,
  metadata,
  created_at,
  request_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
  ).run(
    randomUUID(),
    "SERVICE",
    null,
    action,
    "system",
    null,
    metadata ? JSON.stringify(metadata) : null,
    new Date().toISOString(),
    requestId,
  );
};

export interface DbStatus {
  currentMigration: string | null;
  pendingCount: number;
  appliedCount: number;
  pendingMigrations: string[];
}

const statusFromDb = (db: Database.Database): DbStatus => {
  const applied = getAppliedMigrationNames(db);
  const pending = migrations.filter((migration) => !applied.includes(migration.name));

  return {
    currentMigration: applied.length > 0 ? applied[applied.length - 1] : null,
    pendingCount: pending.length,
    appliedCount: applied.length,
    pendingMigrations: pending.map((migration) => migration.name),
  };
};

export const dbStatus = (config: AppConfig): DbStatus => {
  const db = openDb(config);
  try {
    return statusFromDb(db);
  } finally {
    db.close();
  }
};

export interface MigrateResult {
  applied: string[];
  pendingBefore: number;
}

export const dbMigrate = (config: AppConfig, requestId: string): MigrateResult => {
  const db = openDb(config);
  try {
    ensureMetaTable(db);
    const applied = getAppliedMigrationNames(db);
    const pending = migrations.filter((migration) => !applied.includes(migration.name));

    const run = db.transaction(() => {
      for (const migration of pending) {
        db.exec(migration.sql);
        db.prepare("INSERT INTO app_migrations (name, applied_at) VALUES (?, ?)").run(
          migration.name,
          new Date().toISOString(),
        );
      }

      appendAudit(db, "db.migrate", requestId, {
        appliedCount: pending.length,
        migrations: pending.map((migration) => migration.name),
      });
    });

    run();

    return {
      applied: pending.map((migration) => migration.name),
      pendingBefore: pending.length,
    };
  } finally {
    db.close();
  }
};

const hashToken = (token: string): string =>
  createHash("sha256").update(token).digest("hex");

const resolveActiveToken = (config: AppConfig, token: string): { id: string } | undefined => {
  const db = openDb(config);
  try {
    const tokenHash = hashToken(token);
    return db
      .prepare("SELECT id FROM service_tokens WHERE token_hash = ? AND revoked_at IS NULL")
      .get(tokenHash) as { id: string } | undefined;
  } finally {
    db.close();
  }
};

const requireDangerousProdGuard = (args: {
  config: AppConfig;
  operation: string;
  forceProd?: boolean;
  yes?: boolean;
  token?: string;
}): void => {
  if (args.config.env !== "prod") {
    return;
  }

  if (!args.forceProd || !args.yes) {
    throw preconditionError(
      `${args.operation} in prod requires both --force-prod and --yes.`,
    );
  }

  if (!args.token) {
    throw authError(`A valid token is required for ${args.operation} in prod.`);
  }

  const token = resolveActiveToken(args.config, args.token);
  if (!token) {
    throw authError(`Invalid or revoked token for ${args.operation} in prod.`);
  }
};

export interface DbBackupResult {
  out: string;
  env: RuntimeEnv;
}

export const dbBackup = async (
  config: AppConfig,
  requestId: string,
  out: string,
  options?: {
    forceProd?: boolean;
    yes?: boolean;
    token?: string;
  },
): Promise<DbBackupResult> => {
  const status = dbStatus(config);
  if (status.pendingCount > 0) {
    throw preconditionError("Migrations are pending. Run `appctl db migrate` first.");
  }

  requireDangerousProdGuard({
    config,
    operation: "db backup",
    forceProd: options?.forceProd,
    yes: options?.yes,
    token: options?.token,
  });

  const outputPath = resolve(out);
  mkdirSync(dirname(outputPath), { recursive: true });

  const db = openDb(config);
  try {
    await db.backup(outputPath);

    appendAudit(db, "db.backup", requestId, {
      out: outputPath,
      env: config.env,
    });

    return {
      out: outputPath,
      env: config.env,
    };
  } finally {
    db.close();
  }
};

export interface DbRestoreResult {
  from: string;
  target: string;
  env: RuntimeEnv;
}

export const dbRestore = async (
  config: AppConfig,
  requestId: string,
  from: string,
  options?: {
    forceProd?: boolean;
    yes?: boolean;
    token?: string;
  },
): Promise<DbRestoreResult> => {
  if (!options?.yes) {
    throw preconditionError("db restore requires --yes confirmation.");
  }

  requireDangerousProdGuard({
    config,
    operation: "db restore",
    forceProd: options?.forceProd,
    yes: options?.yes,
    token: options?.token,
  });

  const sourcePath = resolve(from);
  if (!existsSync(sourcePath)) {
    throw preconditionError(`Backup file not found: ${sourcePath}`);
  }

  const targetPath = resolve(config.db.file);
  mkdirSync(dirname(targetPath), { recursive: true });

  const sourceDb = new Database(sourcePath, {
    readonly: true,
    fileMustExist: true,
  });

  try {
    await sourceDb.backup(targetPath);
  } finally {
    sourceDb.close();
  }

  const restoredDb = openDb(config);
  try {
    appendAudit(restoredDb, "db.restore", requestId, {
      from: sourcePath,
      target: targetPath,
      env: config.env,
    });
  } finally {
    restoredDb.close();
  }

  return {
    from: sourcePath,
    target: targetPath,
    env: config.env,
  };
};

export interface SeedResult {
  seededRoles: number;
}

export const dbSeed = (config: AppConfig, requestId: string, fixture?: string): SeedResult => {
  const status = dbStatus(config);
  if (status.pendingCount > 0) {
    throw preconditionError("Migrations are pending. Run `appctl db migrate` first.");
  }

  const db = openDb(config);
  try {
    const roleNames = ["USER", "ADMIN", "SUPER_ADMIN"];

    const run = db.transaction(() => {
      for (const roleName of roleNames) {
        db.prepare("INSERT OR IGNORE INTO roles (id, name) VALUES (?, ?)").run(
          randomUUID(),
          roleName,
        );
      }

      appendAudit(db, "db.seed", requestId, {
        fixture: fixture ?? "default",
      });
    });

    run();

    const seededRoles = db.prepare("SELECT COUNT(*) AS count FROM roles").get() as { count: number };

    return {
      seededRoles: seededRoles.count,
    };
  } finally {
    db.close();
  }
};

export interface DoctorResult {
  dbReachable: boolean;
  schemaCurrent: boolean;
  walEnabled: boolean;
  foreignKeysEnabled: boolean;
  writable: boolean;
  dbPath: string;
}

export const doctor = (config: AppConfig): DoctorResult => {
  const dbPath = resolve(config.db.file);
  const db = openDb(config, false);

  try {
    const status = statusFromDb(db);
    const journal = db.pragma("journal_mode", { simple: true }) as string;
    const foreignKeys = db.pragma("foreign_keys", { simple: true }) as number;
    const busyTimeout = db.pragma("busy_timeout", { simple: true }) as number;

    const writeProbe = db.transaction(() => {
      db.exec("CREATE TABLE IF NOT EXISTS __appctl_write_probe (id INTEGER PRIMARY KEY)");
      db.exec("INSERT INTO __appctl_write_probe DEFAULT VALUES");
      db.exec("DELETE FROM __appctl_write_probe");
    });
    writeProbe();

    const result: DoctorResult = {
      dbReachable: true,
      schemaCurrent: status.pendingCount === 0,
      walEnabled: journal.toLowerCase() === "wal",
      foreignKeysEnabled: foreignKeys === 1,
      writable: true,
      dbPath,
    };

    if (!result.schemaCurrent) {
      throw preconditionError("Schema is not up to date. Run `appctl db migrate`.");
    }

    if (!result.walEnabled || !result.foreignKeysEnabled) {
      throw preconditionError("SQLite pragmas invalid. Require WAL mode and foreign_keys=ON.");
    }

    if (busyTimeout <= 0) {
      throw preconditionError("SQLite busy timeout invalid. Must be greater than 0.");
    }

    return result;
  } finally {
    db.close();
  }
};


===== FILE: src/cli/errors.ts =====
import { ExitCode } from "./types";

export class CliError extends Error {
  public readonly exitCode: ExitCode;

  constructor(message: string, exitCode: ExitCode) {
    super(message);
    this.name = "CliError";
    this.exitCode = exitCode;
  }
}

export const usageError = (message: string): CliError => new CliError(message, 2);
export const authError = (message: string): CliError => new CliError(message, 3);
export const notFoundError = (message: string): CliError => new CliError(message, 4);
export const conflictError = (message: string): CliError => new CliError(message, 5);
export const preconditionError = (message: string): CliError => new CliError(message, 6);


===== FILE: src/cli/events.ts =====
import { createHash, randomUUID } from "node:crypto";
import { mkdirSync } from "node:fs";
import { dirname, resolve } from "node:path";
import Database from "better-sqlite3";
import { dbStatus } from "./db";
import { authError, conflictError, notFoundError, preconditionError, usageError } from "./errors";
import { AppConfig } from "./types";

const openDb = (config: AppConfig): Database.Database => {
  const dbPath = resolve(config.db.file);
  mkdirSync(dirname(dbPath), { recursive: true });

  const db = new Database(dbPath);
  db.pragma(`busy_timeout = ${config.db.busyTimeoutMs}`);
  db.pragma("foreign_keys = ON");
  db.pragma("journal_mode = WAL");
  return db;
};

const requireSchemaCurrent = (config: AppConfig): void => {
  const status = dbStatus(config);
  if (status.pendingCount > 0) {
    throw preconditionError("Migrations are pending. Run `appctl db migrate` first.");
  }
};

const hashToken = (token: string): string => createHash("sha256").update(token).digest("hex");

const resolveToken = (config: AppConfig, token: string): { id: string } | undefined => {
  const db = openDb(config);
  try {
    const tokenHash = hashToken(token);
    return db
      .prepare("SELECT id FROM service_tokens WHERE token_hash = ? AND revoked_at IS NULL")
      .get(tokenHash) as { id: string } | undefined;
  } finally {
    db.close();
  }
};

const requireWriteAuth = (config: AppConfig, providedToken?: string): void => {
  if (config.env === "local") {
    return;
  }

  if (!providedToken) {
    throw authError("A valid super-admin token is required for write commands in staging/prod.");
  }

  const token = resolveToken(config, providedToken);
  if (!token) {
    throw authError("Invalid or revoked token.");
  }
};

const appendAudit = (
  db: Database.Database,
  action: string,
  requestId: string,
  metadata?: Record<string, unknown>,
): void => {
  db.prepare(
    `
INSERT INTO audit_log (
  id,
  actor_type,
  actor_id,
  action,
  target_type,
  target_id,
  metadata,
  created_at,
  request_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
  ).run(
    randomUUID(),
    "SERVICE",
    null,
    action,
    "event",
    null,
    metadata ? JSON.stringify(metadata) : null,
    new Date().toISOString(),
    requestId,
  );
};

const parseIso = (value: string, field: string): string => {
  const parsed = new Date(value);
  if (Number.isNaN(parsed.getTime())) {
    throw usageError(`Invalid ISO datetime for ${field}: ${value}`);
  }

  return parsed.toISOString();
};

const parseTimezone = (timezone: string): string => {
  try {
    Intl.DateTimeFormat(undefined, { timeZone: timezone });
    return timezone;
  } catch {
    throw usageError(`Invalid IANA timezone: ${timezone}`);
  }
};

const parseCapacity = (value?: number): number | null => {
  if (value === undefined) {
    return null;
  }

  if (!Number.isInteger(value) || value < 0) {
    throw usageError("Capacity must be a non-negative integer.");
  }

  return value;
};

const ensureStartBeforeEnd = (startIso: string, endIso: string): void => {
  if (new Date(startIso).getTime() >= new Date(endIso).getTime()) {
    throw usageError("Event start must be before end.");
  }
};

export interface EventRecord {
  id: string;
  slug: string;
  title: string;
  start_at: string;
  end_at: string;
  timezone: string;
  status: "DRAFT" | "PUBLISHED" | "CANCELLED";
  capacity: number | null;
  created_by: string | null;
  created_at: string;
  updated_at: string;
}

export const eventCreate = (
  config: AppConfig,
  requestId: string,
  args: {
    slug: string;
    title: string;
    start: string;
    end: string;
    timezone: string;
    capacity?: number;
  },
  token?: string,
): EventRecord => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const slug = args.slug.trim();
  const title = args.title.trim();
  if (!slug) {
    throw usageError("Slug is required.");
  }
  if (!title) {
    throw usageError("Title is required.");
  }

  const startAt = parseIso(args.start, "start");
  const endAt = parseIso(args.end, "end");
  ensureStartBeforeEnd(startAt, endAt);

  const timezone = parseTimezone(args.timezone);
  const capacity = parseCapacity(args.capacity);

  const db = openDb(config);
  try {
    const id = randomUUID();
    const now = new Date().toISOString();

    const run = db.transaction(() => {
      try {
        db.prepare(
          `
INSERT INTO events (
  id, slug, title, start_at, end_at, timezone, status, capacity, created_by, created_at, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
        ).run(id, slug, title, startAt, endAt, timezone, "DRAFT", capacity, null, now, now);
      } catch (error) {
        if (error instanceof Error && error.message.includes("UNIQUE constraint failed: events.slug")) {
          throw conflictError(`Event already exists for slug: ${slug}`);
        }
        throw error;
      }

      appendAudit(db, "event.create", requestId, {
        eventId: id,
        slug,
      });
    });

    run();

    return db.prepare("SELECT * FROM events WHERE id = ?").get(id) as EventRecord;
  } finally {
    db.close();
  }
};

export const eventUpdate = (
  config: AppConfig,
  requestId: string,
  slug: string,
  changes: {
    title?: string;
    start?: string;
    end?: string;
    capacity?: number;
  },
  token?: string,
): EventRecord => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const db = openDb(config);
  try {
    const existing = db.prepare("SELECT * FROM events WHERE slug = ?").get(slug) as EventRecord | undefined;
    if (!existing) {
      throw notFoundError(`Event not found: ${slug}`);
    }

    const title = changes.title?.trim() || existing.title;
    const startAt = changes.start ? parseIso(changes.start, "start") : existing.start_at;
    const endAt = changes.end ? parseIso(changes.end, "end") : existing.end_at;
    ensureStartBeforeEnd(startAt, endAt);

    const capacity =
      changes.capacity === undefined ? existing.capacity : parseCapacity(changes.capacity);

    const now = new Date().toISOString();

    const run = db.transaction(() => {
      db.prepare(
        `
UPDATE events
SET title = ?, start_at = ?, end_at = ?, capacity = ?, updated_at = ?
WHERE slug = ?
`,
      ).run(title, startAt, endAt, capacity, now, slug);

      appendAudit(db, "event.update", requestId, {
        slug,
      });
    });

    run();

    return db.prepare("SELECT * FROM events WHERE slug = ?").get(slug) as EventRecord;
  } finally {
    db.close();
  }
};

export const eventPublish = (
  config: AppConfig,
  requestId: string,
  slug: string,
  token?: string,
): EventRecord => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const db = openDb(config);
  try {
    const existing = db.prepare("SELECT * FROM events WHERE slug = ?").get(slug) as EventRecord | undefined;
    if (!existing) {
      throw notFoundError(`Event not found: ${slug}`);
    }

    const now = new Date().toISOString();

    const run = db.transaction(() => {
      if (existing.status !== "PUBLISHED") {
        db.prepare("UPDATE events SET status = 'PUBLISHED', updated_at = ? WHERE slug = ?").run(now, slug);
      }

      appendAudit(db, "event.publish", requestId, {
        slug,
        idempotent: existing.status === "PUBLISHED",
      });
    });

    run();

    return db.prepare("SELECT * FROM events WHERE slug = ?").get(slug) as EventRecord;
  } finally {
    db.close();
  }
};

export const eventCancel = (
  config: AppConfig,
  requestId: string,
  slug: string,
  reason: string,
  token?: string,
): EventRecord => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const trimmedReason = reason.trim();
  if (!trimmedReason) {
    throw usageError("Cancel reason is required.");
  }

  const db = openDb(config);
  try {
    const existing = db.prepare("SELECT * FROM events WHERE slug = ?").get(slug) as EventRecord | undefined;
    if (!existing) {
      throw notFoundError(`Event not found: ${slug}`);
    }

    const now = new Date().toISOString();

    const run = db.transaction(() => {
      db.prepare("UPDATE events SET status = 'CANCELLED', updated_at = ? WHERE slug = ?").run(now, slug);

      appendAudit(db, "event.cancel", requestId, {
        slug,
        reason: trimmedReason,
      });
    });

    run();

    return db.prepare("SELECT * FROM events WHERE slug = ?").get(slug) as EventRecord;
  } finally {
    db.close();
  }
};

export const eventList = (
  config: AppConfig,
  filters: { status?: string; from?: string; to?: string },
): EventRecord[] => {
  requireSchemaCurrent(config);

  const db = openDb(config);
  try {
    const params: unknown[] = [];
    const clauses: string[] = [];

    if (filters.status) {
      clauses.push("status = ?");
      params.push(filters.status.toUpperCase());
    }

    if (filters.from) {
      const fromIso = parseIso(filters.from, "from");
      clauses.push("start_at >= ?");
      params.push(fromIso);
    }

    if (filters.to) {
      const toIso = parseIso(filters.to, "to");
      clauses.push("start_at <= ?");
      params.push(toIso);
    }

    const query = `
SELECT *
FROM events
${clauses.length ? `WHERE ${clauses.join(" AND ")}` : ""}
ORDER BY start_at ASC
`;

    return db.prepare(query).all(...params) as EventRecord[];
  } finally {
    db.close();
  }
};


===== FILE: src/cli/main.ts =====
import { runCli } from "./run-cli";

const argv = process.argv.slice(2);

runCli(argv).then((exitCode) => {
  process.exitCode = exitCode;
});


===== FILE: src/cli/registrations.ts =====
import { createHash, randomUUID } from "node:crypto";
import { mkdirSync, writeFileSync } from "node:fs";
import { dirname, resolve } from "node:path";
import Database from "better-sqlite3";
import { dbStatus } from "./db";
import { authError, notFoundError, preconditionError } from "./errors";
import { AppConfig } from "./types";

const openDb = (config: AppConfig): Database.Database => {
  const dbPath = resolve(config.db.file);
  mkdirSync(dirname(dbPath), { recursive: true });

  const db = new Database(dbPath);
  db.pragma(`busy_timeout = ${config.db.busyTimeoutMs}`);
  db.pragma("foreign_keys = ON");
  db.pragma("journal_mode = WAL");
  return db;
};

const hashToken = (token: string): string => createHash("sha256").update(token).digest("hex");

const requireSchemaCurrent = (config: AppConfig): void => {
  const status = dbStatus(config);
  if (status.pendingCount > 0) {
    throw preconditionError("Migrations are pending. Run `appctl db migrate` first.");
  }
};

const resolveToken = (config: AppConfig, token: string): { id: string } | undefined => {
  const db = openDb(config);
  try {
    const tokenHash = hashToken(token);
    return db
      .prepare("SELECT id FROM service_tokens WHERE token_hash = ? AND revoked_at IS NULL")
      .get(tokenHash) as { id: string } | undefined;
  } finally {
    db.close();
  }
};

const requireWriteAuth = (config: AppConfig, providedToken?: string): void => {
  if (config.env === "local") {
    return;
  }

  if (!providedToken) {
    throw authError("A valid super-admin token is required for write commands in staging/prod.");
  }

  const token = resolveToken(config, providedToken);
  if (!token) {
    throw authError("Invalid or revoked token.");
  }
};

const appendAudit = (
  db: Database.Database,
  action: string,
  requestId: string,
  metadata?: Record<string, unknown>,
): void => {
  db.prepare(
    `
INSERT INTO audit_log (
  id,
  actor_type,
  actor_id,
  action,
  target_type,
  target_id,
  metadata,
  created_at,
  request_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
  ).run(
    randomUUID(),
    "SERVICE",
    null,
    action,
    "registration",
    null,
    metadata ? JSON.stringify(metadata) : null,
    new Date().toISOString(),
    requestId,
  );
};

interface EventRow {
  id: string;
  slug: string;
  capacity: number | null;
}

interface UserRow {
  id: string;
  email: string;
}

interface RegistrationRow {
  id: string;
  event_id: string;
  user_id: string;
  status: "REGISTERED" | "WAITLISTED" | "CANCELLED" | "CHECKED_IN";
}

const resolveEvent = (db: Database.Database, slug: string): EventRow => {
  const event = db.prepare("SELECT id, slug, capacity FROM events WHERE slug = ?").get(slug) as
    | EventRow
    | undefined;

  if (!event) {
    throw notFoundError(`Event not found: ${slug}`);
  }

  return event;
};

const resolveUser = (db: Database.Database, identifier: string): UserRow => {
  const looksLikeEmail = identifier.includes("@");

  const user = looksLikeEmail
    ? (db.prepare("SELECT id, email FROM users WHERE email = ?").get(identifier.toLowerCase()) as
        | UserRow
        | undefined)
    : (db.prepare("SELECT id, email FROM users WHERE id = ?").get(identifier) as UserRow | undefined);

  if (!user) {
    throw notFoundError(`User not found: ${identifier}`);
  }

  return user;
};

const computeRegistrationStatus = (
  db: Database.Database,
  eventId: string,
  capacity: number | null,
): "REGISTERED" | "WAITLISTED" => {
  if (capacity === null) {
    return "REGISTERED";
  }

  const activeCount = db
    .prepare(
      "SELECT COUNT(*) AS count FROM event_registrations WHERE event_id = ? AND status IN ('REGISTERED','CHECKED_IN')",
    )
    .get(eventId) as { count: number };

  return activeCount.count >= capacity ? "WAITLISTED" : "REGISTERED";
};

export const regAdd = (
  config: AppConfig,
  requestId: string,
  eventSlug: string,
  userIdentifier: string,
  token?: string,
): RegistrationRow => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const db = openDb(config);
  try {
    const event = resolveEvent(db, eventSlug);
    const user = resolveUser(db, userIdentifier);

    const run = db.transaction(() => {
      const existing = db
        .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
        .get(event.id, user.id) as RegistrationRow | undefined;

      const status = computeRegistrationStatus(db, event.id, event.capacity);

      if (!existing) {
        db.prepare("INSERT INTO event_registrations (id, event_id, user_id, status) VALUES (?, ?, ?, ?)").run(
          randomUUID(),
          event.id,
          user.id,
          status,
        );
      } else if (existing.status === "CANCELLED") {
        db.prepare("UPDATE event_registrations SET status = ? WHERE id = ?").run(status, existing.id);
      }

      appendAudit(db, "registration.add", requestId, {
        eventSlug,
        userId: user.id,
      });
    });

    run();

    return db
      .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
      .get(event.id, user.id) as RegistrationRow;
  } finally {
    db.close();
  }
};

export const regRemove = (
  config: AppConfig,
  requestId: string,
  eventSlug: string,
  userIdentifier: string,
  token?: string,
  reason?: string,
): RegistrationRow => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const db = openDb(config);
  try {
    const event = resolveEvent(db, eventSlug);
    const user = resolveUser(db, userIdentifier);

    const run = db.transaction(() => {
      const existing = db
        .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
        .get(event.id, user.id) as RegistrationRow | undefined;

      if (!existing) {
        throw notFoundError(`Registration not found for event=${eventSlug} user=${userIdentifier}`);
      }

      db.prepare("UPDATE event_registrations SET status = 'CANCELLED' WHERE id = ?").run(existing.id);

      appendAudit(db, "registration.cancel", requestId, {
        eventSlug,
        userId: user.id,
        reason: reason ?? null,
      });
    });

    run();

    return db
      .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
      .get(event.id, user.id) as RegistrationRow;
  } finally {
    db.close();
  }
};

export interface RegistrationListRow {
  id: string;
  event_slug: string;
  user_id: string;
  user_email: string;
  status: "REGISTERED" | "WAITLISTED" | "CANCELLED" | "CHECKED_IN";
}

export const regList = (
  config: AppConfig,
  eventSlug: string,
  status?: string,
): RegistrationListRow[] => {
  requireSchemaCurrent(config);

  const db = openDb(config);
  try {
    const event = resolveEvent(db, eventSlug);
    const params: unknown[] = [event.id];
    const clauses = ["r.event_id = ?"];

    if (status) {
      clauses.push("r.status = ?");
      params.push(status.toUpperCase());
    }

    return db
      .prepare(
        `
SELECT r.id, e.slug AS event_slug, u.id AS user_id, u.email AS user_email, r.status
FROM event_registrations r
JOIN events e ON e.id = r.event_id
JOIN users u ON u.id = r.user_id
WHERE ${clauses.join(" AND ")}
ORDER BY u.email ASC
`,
      )
      .all(...params) as RegistrationListRow[];
  } finally {
    db.close();
  }
};

export const regCheckin = (
  config: AppConfig,
  requestId: string,
  eventSlug: string,
  userIdentifier: string,
  token?: string,
): RegistrationRow => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const db = openDb(config);
  try {
    const event = resolveEvent(db, eventSlug);
    const user = resolveUser(db, userIdentifier);

    const run = db.transaction(() => {
      const existing = db
        .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
        .get(event.id, user.id) as RegistrationRow | undefined;

      if (!existing) {
        throw notFoundError(`Registration not found for event=${eventSlug} user=${userIdentifier}`);
      }

      if (existing.status === "CANCELLED") {
        throw preconditionError("Cannot check in a cancelled registration.");
      }

      db.prepare("UPDATE event_registrations SET status = 'CHECKED_IN' WHERE id = ?").run(existing.id);

      appendAudit(db, "registration.checkin", requestId, {
        eventSlug,
        userId: user.id,
      });
    });

    run();

    return db
      .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
      .get(event.id, user.id) as RegistrationRow;
  } finally {
    db.close();
  }
};

export interface ExportResult {
  slug: string;
  format: "csv" | "json";
  out: string;
  count: number;
  includeEmail: boolean;
}

export const eventExport = (
  config: AppConfig,
  requestId: string,
  args: {
    slug: string;
    format: "csv" | "json";
    out: string;
    includeEmail: boolean;
  },
  token?: string,
): ExportResult => {
  requireSchemaCurrent(config);

  if (args.includeEmail && config.env !== "local") {
    requireWriteAuth(config, token);
  }

  const db = openDb(config);
  try {
    const event = resolveEvent(db, args.slug);
    const rows = db
      .prepare(
        `
SELECT r.id, r.status, u.id AS user_id, u.email AS user_email
FROM event_registrations r
JOIN users u ON u.id = r.user_id
WHERE r.event_id = ?
ORDER BY u.email ASC
`,
      )
      .all(event.id) as Array<{ id: string; status: string; user_id: string; user_email: string }>;

    const includeEmail = args.includeEmail;

    const serializable = rows.map((row) =>
      includeEmail
        ? {
            id: row.id,
            status: row.status,
            user_id: row.user_id,
            user_email: row.user_email,
          }
        : {
            id: row.id,
            status: row.status,
            user_id: row.user_id,
          },
    );

    const outputPath = resolve(args.out);
    mkdirSync(dirname(outputPath), { recursive: true });

    if (args.format === "json") {
      writeFileSync(outputPath, `${JSON.stringify(serializable, null, 2)}\n`, "utf8");
    } else {
      const headers = includeEmail ? ["id", "status", "user_id", "user_email"] : ["id", "status", "user_id"];
      const body = serializable
        .map((row) => headers.map((header) => JSON.stringify((row as Record<string, string>)[header] ?? "")).join(","))
        .join("\n");
      const csv = `${headers.join(",")}\n${body}${body ? "\n" : ""}`;
      writeFileSync(outputPath, csv, "utf8");
    }

    appendAudit(db, "event.export", requestId, {
      slug: args.slug,
      format: args.format,
      out: outputPath,
      includeEmail,
      count: rows.length,
    });

    return {
      slug: args.slug,
      format: args.format,
      out: outputPath,
      count: rows.length,
      includeEmail,
    };
  } finally {
    db.close();
  }
};


===== FILE: src/cli/run-cli.ts =====
import { randomUUID } from "node:crypto";
import { Command, CommanderError, Option } from "commander";
import pino from "pino";
import {
  authTokenCreate,
  authTokenRevoke,
  userCreate,
  userDisable,
  userEnable,
  userList,
  userRoleAdd,
  userRoleRemove,
  userShow,
} from "./auth-users";
import { loadConfigFromDisk, resolveConfig } from "./config";
import { dbBackup, dbMigrate, dbRestore, dbSeed, dbStatus, doctor } from "./db";
import { eventCancel, eventCreate, eventList, eventPublish, eventUpdate } from "./events";
import { CliError } from "./errors";
import { eventExport, regAdd, regCheckin, regList, regRemove } from "./registrations";
import { CliIo, ExitCode, GlobalOptions, JsonEnvelope, RuntimeEnv } from "./types";

const logger = pino({ enabled: false });

const defaultIo: CliIo = {
  writeStdout: (message: string) => {
    process.stdout.write(message);
  },
  writeStderr: (message: string) => {
    process.stderr.write(message);
  },
};

const usageErrorCodes = new Set([
  "commander.invalidArgument",
  "commander.unknownOption",
  "commander.unknownCommand",
  "commander.excessArguments",
  "commander.missingMandatoryOptionValue",
  "commander.optionMissingArgument",
]);

const isUsageError = (error: CommanderError): boolean => usageErrorCodes.has(error.code);

export const mapErrorToExitCode = (error: unknown): ExitCode => {
  if (error instanceof CliError) {
    return error.exitCode;
  }

  if (error instanceof CommanderError) {
    if (error.code === "commander.helpDisplayed") {
      return 0;
    }
    if (isUsageError(error)) {
      return 2;
    }
  }

  return 1;
};

const writeJsonEnvelope = (io: CliIo, envelope: JsonEnvelope): void => {
  io.writeStdout(`${JSON.stringify(envelope)}\n`);
};

const writeDoctorText = (io: CliIo, env: RuntimeEnv): void => {
  io.writeStdout(`doctor ok (env=${env})\n`);
};

const writeText = (io: CliIo, message: string): void => {
  io.writeStdout(`${message}\n`);
};

const normalizeOptions = (raw: Record<string, unknown>): GlobalOptions => ({
  env: raw.env as RuntimeEnv | undefined,
  json: Boolean(raw.json),
  quiet: Boolean(raw.quiet),
  color: Boolean(raw.color),
  trace: Boolean(raw.trace),
  dryRun: Boolean(raw.dryRun),
  yes: Boolean(raw.yes),
  token: typeof raw.token === "string" ? raw.token : undefined,
});

const createProgram = (io: CliIo): Command => {
  const program = new Command();

  program
    .name("appctl")
    .description("Super Admin Control Plane CLI")
    .option("--json", "emit strict JSON output")
    .option("--quiet", "reduce human-readable output")
    .option("--no-color", "disable ANSI colors")
    .option("--trace", "show stack traces for errors")
    .option("--dry-run", "validate request without mutating state")
    .option("--yes", "skip interactive confirmations")
    .option("--token <token>", "super-admin service token override")
    .showHelpAfterError()
    .exitOverride();

  program.addOption(
    new Option("--env <env>", "runtime environment").choices(["local", "staging", "prod"]),
  );

  program.configureOutput({
    writeOut: io.writeStdout,
    writeErr: io.writeStderr,
  });

  const resolveRuntimeConfig = async (): Promise<ReturnType<typeof resolveConfig>> => {
    const options = normalizeOptions(program.opts<Record<string, unknown>>());
    const fileConfig = await loadConfigFromDisk();
    return resolveConfig({ fileConfig, flags: options });
  };

  const outputResult = (
    commandName: string,
    env: RuntimeEnv,
    data: unknown,
    textSummary: string,
    outputAsJson: boolean,
  ): void => {
    if (outputAsJson) {
      const envelope: JsonEnvelope = {
        ok: true,
        command: commandName,
        env,
        data,
        warnings: [],
        errors: [],
        request_id: randomUUID(),
      };
      writeJsonEnvelope(io, envelope);
      return;
    }

    writeText(io, textSummary);
  };

  program
    .command("doctor")
    .description("Validate config and runtime prerequisites")
    .action(async () => {
      const config = await resolveRuntimeConfig();
      const result = doctor(config);

      logger.debug({ command: "doctor" }, "doctor command executed");

      if (config.output.defaultFormat === "json") {
        outputResult(
          "doctor",
          config.env,
          {
            status: "ok",
            config: {
              env: config.env,
              db: config.db,
            },
            checks: result,
          },
          "doctor ok",
          true,
        );
        return;
      }

      writeDoctorText(io, config.env);
    });

  const dbCommand = program.command("db").description("Database lifecycle commands");

  dbCommand
    .command("status")
    .description("Show current migration status")
    .action(async () => {
      const config = await resolveRuntimeConfig();
      const status = dbStatus(config);

      outputResult(
        "db.status",
        config.env,
        status,
        `db status: applied=${status.appliedCount}, pending=${status.pendingCount}`,
        config.output.defaultFormat === "json",
      );
    });

  dbCommand
    .command("migrate")
    .description("Apply pending migrations")
    .action(async () => {
      const config = await resolveRuntimeConfig();
      const result = dbMigrate(config, randomUUID());

      outputResult(
        "db.migrate",
        config.env,
        result,
        `db migrate: applied=${result.applied.length}`,
        config.output.defaultFormat === "json",
      );
    });

  dbCommand
    .command("seed")
    .description("Seed baseline data")
    .option("--fixture <name>", "optional fixture name")
    .action(async (args: { fixture?: string }) => {
      const config = await resolveRuntimeConfig();
      const result = dbSeed(config, randomUUID(), args.fixture);

      outputResult(
        "db.seed",
        config.env,
        result,
        `db seed: roles=${result.seededRoles}`,
        config.output.defaultFormat === "json",
      );
    });

  dbCommand
    .command("backup")
    .description("Create a consistent DB backup artifact")
    .requiredOption("--out <file>", "backup output file")
    .option("--force-prod", "allow dangerous operation in prod")
    .action(async (args: { out: string; forceProd?: boolean }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = await dbBackup(config, randomUUID(), args.out, {
        forceProd: Boolean(args.forceProd),
        yes: options.yes,
        token: options.token,
      });

      outputResult(
        "db.backup",
        config.env,
        result,
        `db backup: out=${result.out}`,
        config.output.defaultFormat === "json",
      );
    });

  dbCommand
    .command("restore")
    .description("Restore DB from backup artifact")
    .requiredOption("--from <file>", "backup file to restore from")
    .option("--force-prod", "allow dangerous operation in prod")
    .action(async (args: { from: string; forceProd?: boolean }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = await dbRestore(config, randomUUID(), args.from, {
        forceProd: Boolean(args.forceProd),
        yes: options.yes,
        token: options.token,
      });

      outputResult(
        "db.restore",
        config.env,
        result,
        `db restore: from=${result.from} target=${result.target}`,
        config.output.defaultFormat === "json",
      );
    });

  const authCommand = program.command("auth").description("Authentication and service tokens");
  const authTokenCommand = authCommand.command("token").description("Service token commands");

  authTokenCommand
    .command("create")
    .description("Create a service token")
    .requiredOption("--name <label>", "token label")
    .option("--ttl-days <n>", "optional token ttl in days")
    .action(async (args: { name: string; ttlDays?: string }) => {
      const config = await resolveRuntimeConfig();
      const ttlDays = args.ttlDays ? Number(args.ttlDays) : undefined;

      const result = authTokenCreate(config, randomUUID(), args.name, ttlDays);

      outputResult(
        "auth.token.create",
        config.env,
        result,
        `token created: id=${result.id} token=${result.token}`,
        config.output.defaultFormat === "json",
      );
    });

  authTokenCommand
    .command("revoke")
    .description("Revoke a service token")
    .requiredOption("--id <tokenId>", "token id")
    .action(async (args: { id: string }) => {
      const config = await resolveRuntimeConfig();
      const result = authTokenRevoke(config, randomUUID(), args.id);

      outputResult(
        "auth.token.revoke",
        config.env,
        result,
        `token revoked: id=${result.id}`,
        config.output.defaultFormat === "json",
      );
    });

  const userCommand = program.command("user").description("User management commands");

  userCommand
    .command("create")
    .description("Create a user")
    .requiredOption("--email <email>", "user email")
    .option("--status <status>", "PENDING|ACTIVE|DISABLED")
    .action(async (args: { email: string; status?: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = userCreate(config, randomUUID(), args.email, args.status, options.token);

      outputResult(
        "user.create",
        config.env,
        result,
        `user created: id=${result.id} email=${result.email} status=${result.status}`,
        config.output.defaultFormat === "json",
      );
    });

  userCommand
    .command("list")
    .description("List users")
    .option("--role <role>", "filter by role")
    .option("--status <status>", "filter by status")
    .option("--search <q>", "filter by email search")
    .action(async (args: { role?: string; status?: string; search?: string }) => {
      const config = await resolveRuntimeConfig();
      const users = userList(config, {
        role: args.role,
        status: args.status,
        search: args.search,
      });

      outputResult(
        "user.list",
        config.env,
        users,
        `users: count=${users.length}`,
        config.output.defaultFormat === "json",
      );
    });

  userCommand
    .command("show")
    .description("Show a user by id or email")
    .option("--id <id>", "user id")
    .option("--email <email>", "user email")
    .action(async (args: { id?: string; email?: string }) => {
      const config = await resolveRuntimeConfig();
      const result = userShow(config, {
        id: args.id,
        email: args.email,
      });

      outputResult(
        "user.show",
        config.env,
        result,
        `user: id=${result.id} email=${result.email} status=${result.status}`,
        config.output.defaultFormat === "json",
      );
    });

  userCommand
    .command("disable")
    .description("Disable a user")
    .requiredOption("--id <id>", "user id")
    .option("--reason <text>", "optional reason")
    .action(async (args: { id: string; reason?: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = userDisable(config, randomUUID(), args.id, options.token, args.reason);

      outputResult(
        "user.disable",
        config.env,
        result,
        `user disabled: id=${result.id}`,
        config.output.defaultFormat === "json",
      );
    });

  userCommand
    .command("enable")
    .description("Enable a user")
    .requiredOption("--id <id>", "user id")
    .action(async (args: { id: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = userEnable(config, randomUUID(), args.id, options.token);

      outputResult(
        "user.enable",
        config.env,
        result,
        `user enabled: id=${result.id}`,
        config.output.defaultFormat === "json",
      );
    });

  const roleCommand = userCommand.command("role").description("User role operations");

  roleCommand
    .command("add")
    .description("Add role to user")
    .requiredOption("--id <id>", "user id")
    .requiredOption("--role <role>", "role name")
    .action(async (args: { id: string; role: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = userRoleAdd(config, randomUUID(), args.id, args.role, options.token);

      outputResult(
        "user.role.add",
        config.env,
        result,
        `role added: user=${result.userId} role=${result.role}`,
        config.output.defaultFormat === "json",
      );
    });

  roleCommand
    .command("remove")
    .description("Remove role from user")
    .requiredOption("--id <id>", "user id")
    .requiredOption("--role <role>", "role name")
    .action(async (args: { id: string; role: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = userRoleRemove(config, randomUUID(), args.id, args.role, options.token);

      outputResult(
        "user.role.remove",
        config.env,
        result,
        `role removed: user=${result.userId} role=${result.role}`,
        config.output.defaultFormat === "json",
      );
    });

  const eventCommand = program.command("event").description("Event lifecycle commands");

  eventCommand
    .command("create")
    .description("Create an event in DRAFT status")
    .requiredOption("--slug <slug>", "event slug")
    .requiredOption("--title <title>", "event title")
    .requiredOption("--start <iso>", "start datetime ISO")
    .requiredOption("--end <iso>", "end datetime ISO")
    .requiredOption("--tz <iana>", "IANA timezone")
    .option("--capacity <n>", "optional capacity")
    .action(
      async (args: {
        slug: string;
        title: string;
        start: string;
        end: string;
        tz: string;
        capacity?: string;
      }) => {
        const config = await resolveRuntimeConfig();
        const options = normalizeOptions(program.opts<Record<string, unknown>>());
        const capacity = args.capacity === undefined ? undefined : Number(args.capacity);
        const result = eventCreate(
          config,
          randomUUID(),
          {
            slug: args.slug,
            title: args.title,
            start: args.start,
            end: args.end,
            timezone: args.tz,
            capacity,
          },
          options.token,
        );

        outputResult(
          "event.create",
          config.env,
          result,
          `event created: slug=${result.slug} status=${result.status}`,
          config.output.defaultFormat === "json",
        );
      },
    );

  eventCommand
    .command("update")
    .description("Update mutable event fields")
    .requiredOption("--slug <slug>", "event slug")
    .option("--title <title>", "new title")
    .option("--start <iso>", "new start datetime ISO")
    .option("--end <iso>", "new end datetime ISO")
    .option("--capacity <n>", "new capacity")
    .action(
      async (args: { slug: string; title?: string; start?: string; end?: string; capacity?: string }) => {
        const config = await resolveRuntimeConfig();
        const options = normalizeOptions(program.opts<Record<string, unknown>>());
        const result = eventUpdate(
          config,
          randomUUID(),
          args.slug,
          {
            title: args.title,
            start: args.start,
            end: args.end,
            capacity: args.capacity === undefined ? undefined : Number(args.capacity),
          },
          options.token,
        );

        outputResult(
          "event.update",
          config.env,
          result,
          `event updated: slug=${result.slug}`,
          config.output.defaultFormat === "json",
        );
      },
    );

  eventCommand
    .command("publish")
    .description("Publish an event")
    .requiredOption("--slug <slug>", "event slug")
    .action(async (args: { slug: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = eventPublish(config, randomUUID(), args.slug, options.token);

      outputResult(
        "event.publish",
        config.env,
        result,
        `event published: slug=${result.slug} status=${result.status}`,
        config.output.defaultFormat === "json",
      );
    });

  eventCommand
    .command("cancel")
    .description("Cancel an event")
    .requiredOption("--slug <slug>", "event slug")
    .requiredOption("--reason <text>", "cancel reason")
    .action(async (args: { slug: string; reason: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = eventCancel(config, randomUUID(), args.slug, args.reason, options.token);

      outputResult(
        "event.cancel",
        config.env,
        result,
        `event cancelled: slug=${result.slug} status=${result.status}`,
        config.output.defaultFormat === "json",
      );
    });

  eventCommand
    .command("list")
    .description("List events")
    .option("--status <status>", "filter by status")
    .option("--from <iso>", "start lower bound")
    .option("--to <iso>", "start upper bound")
    .action(async (args: { status?: string; from?: string; to?: string }) => {
      const config = await resolveRuntimeConfig();
      const result = eventList(config, {
        status: args.status,
        from: args.from,
        to: args.to,
      });

      outputResult(
        "event.list",
        config.env,
        result,
        `events: count=${result.length}`,
        config.output.defaultFormat === "json",
      );
    });

  eventCommand
    .command("export")
    .description("Export registrations for an event")
    .requiredOption("--slug <slug>", "event slug")
    .requiredOption("--format <format>", "csv|json")
    .requiredOption("--out <file>", "output file path")
    .option("--include-email", "include user email in export")
    .action(async (args: { slug: string; format: string; out: string; includeEmail?: boolean }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const format = args.format.toLowerCase();
      if (format !== "csv" && format !== "json") {
        throw new CliError("Invalid format. Allowed: csv, json.", 2);
      }

      const result = eventExport(
        config,
        randomUUID(),
        {
          slug: args.slug,
          format,
          out: args.out,
          includeEmail: Boolean(args.includeEmail),
        },
        options.token,
      );

      outputResult(
        "event.export",
        config.env,
        result,
        `event export: slug=${result.slug} format=${result.format} count=${result.count} out=${result.out}`,
        config.output.defaultFormat === "json",
      );
    });

  const regCommand = program.command("reg").description("Event registration commands");

  regCommand
    .command("add")
    .description("Add registration for event/user")
    .requiredOption("--event <slug>", "event slug")
    .requiredOption("--user <emailOrId>", "user email or id")
    .action(async (args: { event: string; user: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = regAdd(config, randomUUID(), args.event, args.user, options.token);

      outputResult(
        "reg.add",
        config.env,
        result,
        `registration added: event=${args.event} user=${args.user} status=${result.status}`,
        config.output.defaultFormat === "json",
      );
    });

  regCommand
    .command("remove")
    .description("Cancel registration for event/user")
    .requiredOption("--event <slug>", "event slug")
    .requiredOption("--user <emailOrId>", "user email or id")
    .option("--reason <text>", "optional reason")
    .action(async (args: { event: string; user: string; reason?: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = regRemove(config, randomUUID(), args.event, args.user, options.token, args.reason);

      outputResult(
        "reg.remove",
        config.env,
        result,
        `registration cancelled: event=${args.event} user=${args.user} status=${result.status}`,
        config.output.defaultFormat === "json",
      );
    });

  regCommand
    .command("list")
    .description("List registrations for an event")
    .requiredOption("--event <slug>", "event slug")
    .option("--status <status>", "registration status filter")
    .action(async (args: { event: string; status?: string }) => {
      const config = await resolveRuntimeConfig();
      const result = regList(config, args.event, args.status);

      outputResult(
        "reg.list",
        config.env,
        result,
        `registrations: event=${args.event} count=${result.length}`,
        config.output.defaultFormat === "json",
      );
    });

  program
    .command("checkin")
    .description("Check in a registered user")
    .requiredOption("--event <slug>", "event slug")
    .requiredOption("--user <emailOrId>", "user email or id")
    .action(async (args: { event: string; user: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = regCheckin(config, randomUUID(), args.event, args.user, options.token);

      outputResult(
        "registration.checkin",
        config.env,
        result,
        `checkin complete: event=${args.event} user=${args.user} status=${result.status}`,
        config.output.defaultFormat === "json",
      );
    });

  return program;
};

export const runCli = async (argv: string[], io: CliIo = defaultIo): Promise<ExitCode> => {
  const program = createProgram(io);

  if (argv.length === 0) {
    program.outputHelp();
    return 2;
  }

  try {
    await program.parseAsync(argv, { from: "user" });
    return 0;
  } catch (error) {
    const exitCode = mapErrorToExitCode(error);

    if (error instanceof CommanderError) {
      return exitCode;
    }

    if (error instanceof CliError) {
      io.writeStderr(`${error.message}\n`);
      return exitCode;
    }

    const unexpectedMessage = error instanceof Error ? error.message : "Unknown error";
    io.writeStderr(`${unexpectedMessage}\n`);
    return exitCode;
  }
};


===== FILE: src/cli/types.ts =====
export type RuntimeEnv = "local" | "staging" | "prod";

export type OutputFormat = "text" | "json";

export type ExitCode = 0 | 1 | 2 | 3 | 4 | 5 | 6;

export interface GlobalOptions {
  env?: RuntimeEnv;
  json?: boolean;
  quiet?: boolean;
  color?: boolean;
  trace?: boolean;
  dryRun?: boolean;
  yes?: boolean;
  token?: string;
}

export interface DbConfig {
  mode: "sqlite";
  file: string;
  busyTimeoutMs: number;
}

export interface SecurityConfig {
  requireTokenInStaging: boolean;
  requireTokenInProd: boolean;
  dangerousOpsRequireExplicitProd: boolean;
}

export interface AuditConfig {
  strict: boolean;
}

export interface OutputConfig {
  defaultFormat: OutputFormat;
}

export interface AppConfig {
  env: RuntimeEnv;
  db: DbConfig;
  security: SecurityConfig;
  audit: AuditConfig;
  output: OutputConfig;
}

export interface JsonEnvelope<TData = unknown> {
  ok: boolean;
  command: string;
  env: RuntimeEnv;
  data: TData;
  warnings: string[];
  errors: string[];
  request_id: string;
}

export interface CliIo {
  writeStdout(message: string): void;
  writeStderr(message: string): void;
}


===== FILE: src/components/problem-details.tsx =====
"use client";

import { useState } from "react";
import type { ProblemDetails } from "@/lib/hal-client";

type ProblemDetailsProps = {
  problem: ProblemDetails;
};

export function ProblemDetailsPanel({ problem }: ProblemDetailsProps) {
  const [copied, setCopied] = useState(false);

  const onCopy = async () => {
    if (!problem.request_id) {
      return;
    }

    try {
      await navigator.clipboard.writeText(problem.request_id);
      setCopied(true);
      window.setTimeout(() => setCopied(false), 1200);
    } catch {
      setCopied(false);
    }
  };

  return (
    <div className="rounded-md border p-4">
      <h2 className="text-lg font-semibold">{problem.title}</h2>
      <p className="mt-1 text-sm">Status: {problem.status}</p>
      {problem.detail ? <p className="mt-1 text-sm">{problem.detail}</p> : null}
      {Array.isArray(problem.errors) && problem.errors.length > 0 ? (
        <ul className="mt-2 list-disc pl-5 text-sm">
          {problem.errors.map((error) => (
            <li key={error}>{error}</li>
          ))}
        </ul>
      ) : null}
      {problem.request_id ? (
        <div className="mt-2 flex items-center gap-2 text-xs">
          <p>request_id: {problem.request_id}</p>
          <button
            type="button"
            onClick={() => void onCopy()}
            className="rounded border px-2 py-1"
          >
            {copied ? "Copied" : "Copy"}
          </button>
        </div>
      ) : null}
    </div>
  );
}


===== FILE: src/lib/__tests__/admin-events-view.test.ts =====
import { describe, expect, it } from "vitest";

import { getEventActionHrefs, toEventCreatePayload } from "../admin-events-view";

describe("admin events view helpers", () => {
  it("extracts publish/cancel links from HAL resources", () => {
    const links = getEventActionHrefs({
      _links: {
        self: { href: "/api/v1/events/test" },
        "app:publish": { href: "/api/v1/events/test/publish" },
      },
    });

    expect(links.publish).toBe("/api/v1/events/test/publish");
    expect(links.cancel).toBeNull();
  });

  it("builds create payload and parses capacity", () => {
    const payload = toEventCreatePayload({
      slug: " test-slug ",
      title: " Test Event ",
      start: "2026-07-01T10:00:00.000Z",
      end: "2026-07-01T11:00:00.000Z",
      timezone: "UTC",
      capacity: "25",
    });

    expect(payload).toEqual({
      slug: "test-slug",
      title: "Test Event",
      start: "2026-07-01T10:00:00.000Z",
      end: "2026-07-01T11:00:00.000Z",
      timezone: "UTC",
      capacity: 25,
    });
  });
});


===== FILE: src/lib/__tests__/admin-registration-view.test.ts =====
import { describe, expect, it } from "vitest";

import {
  buildExportFileName,
  buildRegistrationPayload,
  canCancel,
  canCheckIn,
} from "../admin-registration-view";

describe("admin registration ui helpers", () => {
  it("evaluates check-in/cancel action eligibility by status", () => {
    expect(canCheckIn("REGISTERED")).toBe(true);
    expect(canCheckIn("WAITLISTED")).toBe(true);
    expect(canCheckIn("CHECKED_IN")).toBe(false);
    expect(canCheckIn("CANCELLED")).toBe(false);

    expect(canCancel("REGISTERED")).toBe(true);
    expect(canCancel("WAITLISTED")).toBe(true);
    expect(canCancel("CHECKED_IN")).toBe(true);
    expect(canCancel("CANCELLED")).toBe(false);
  });

  it("builds registration payload from user identifier", () => {
    expect(buildRegistrationPayload("person@example.com")).toEqual({
      user_email: "person@example.com",
    });
    expect(buildRegistrationPayload("abc-123")).toEqual({ user_id: "abc-123" });
    expect(buildRegistrationPayload("   ")).toEqual({});
  });

  it("builds export file names", () => {
    expect(buildExportFileName("my-event", "json")).toBe("my-event-registrations.json");
    expect(buildExportFileName("my-event", "csv")).toBe("my-event-registrations.csv");
  });
});


===== FILE: src/lib/__tests__/admin-users-ui.test.ts =====
import { describe, expect, it } from "vitest";

import {
  MUTABLE_ROLES,
  buildUsersListHref,
  canAddRole,
  canRemoveRole,
} from "../admin-users-ui";

describe("admin users ui helpers", () => {
  it("builds users list href with search, role, and status filters", () => {
    const href = buildUsersListHref({
      search: "  alice@example.com  ",
      role: "ADMIN",
      status: "ACTIVE",
    });

    expect(href).toBe("/api/v1/users?search=alice%40example.com&status=ACTIVE&role=ADMIN");
  });

  it("returns base users href when filters are empty", () => {
    const href = buildUsersListHref({
      search: "   ",
      status: "",
      role: "",
    });

    expect(href).toBe("/api/v1/users");
  });

  it("supports idempotent role actions and excludes super admin mutation", () => {
    expect(MUTABLE_ROLES).toEqual(["ADMIN"]);
    expect(canAddRole(["USER"], "ADMIN")).toBe(true);
    expect(canAddRole(["USER", "ADMIN"], "ADMIN")).toBe(false);
    expect(canRemoveRole(["USER", "ADMIN"], "ADMIN")).toBe(true);
    expect(canRemoveRole(["USER"], "ADMIN")).toBe(false);
  });
});


===== FILE: src/lib/__tests__/auth-forms.test.ts =====
import { describe, expect, it } from "vitest";

import { loginSchema, registerSchema } from "../auth-forms";

describe("auth form schemas", () => {
  it("validates login input", () => {
    const valid = loginSchema.safeParse({
      email: "person@example.com",
      password: "Password123!",
    });

    const invalid = loginSchema.safeParse({
      email: "bad-email",
      password: "short",
    });

    expect(valid.success).toBe(true);
    expect(invalid.success).toBe(false);
  });

  it("validates register input and confirm password", () => {
    const valid = registerSchema.safeParse({
      email: "person@example.com",
      password: "Password123!",
      confirmPassword: "Password123!",
      termsAccepted: true,
    });

    const invalid = registerSchema.safeParse({
      email: "person@example.com",
      password: "Password123!",
      confirmPassword: "Password123",
      termsAccepted: false,
    });

    expect(valid.success).toBe(true);
    expect(invalid.success).toBe(false);
  });
});


===== FILE: src/lib/__tests__/hal-client.test.ts =====
import { beforeEach, describe, expect, it, vi } from "vitest";

import { follow, requestHal, type HalResource } from "../hal-client";

describe("hal client", () => {
  beforeEach(() => {
    vi.restoreAllMocks();
  });

  it("follows relations from HAL links", () => {
    const resource: HalResource = {
      _links: {
        self: { href: "/api/v1" },
        events: { href: "/api/v1/events" },
      },
    };

    const events = follow(resource, "events");
    expect(events?.href).toBe("/api/v1/events");
    expect(follow(resource, "missing")).toBeNull();
  });

  it("parses problem details for non-2xx responses", async () => {
    vi.spyOn(globalThis, "fetch").mockResolvedValue(
      new Response(
        JSON.stringify({
          type: "about:blank",
          title: "Unauthorized",
          status: 401,
          request_id: "req-1",
        }),
        { status: 401, headers: { "content-type": "application/problem+json" } },
      ),
    );

    const result = await requestHal<{ ok: true }>("/api/v1/me");
    expect(result.ok).toBe(false);
    if (!result.ok) {
      expect(result.problem.status).toBe(401);
      expect(result.problem.request_id).toBe("req-1");
    }
  });
});


===== FILE: src/lib/__tests__/ui-access.test.ts =====
import { describe, expect, it } from "vitest";

import { canAccessAdminFromMe } from "../ui-access";

describe("ui access", () => {
  it("allows admin when /me exposes users affordance", () => {
    const allowed = canAccessAdminFromMe({
      _links: {
        self: { href: "/api/v1/me" },
        users: { href: "/api/v1/users" },
      },
    });

    expect(allowed).toBe(true);
  });

  it("denies admin when /me lacks users affordance", () => {
    const allowed = canAccessAdminFromMe({
      _links: {
        self: { href: "/api/v1/me" },
      },
    });

    expect(allowed).toBe(false);
  });
});


===== FILE: src/lib/admin-events-view.ts =====
import type { HalResource } from "./hal-client";

export const getEventActionHrefs = (resource: HalResource) => {
  return {
    publish: resource._links["app:publish"]?.href ?? null,
    cancel: resource._links["app:cancel"]?.href ?? null,
  };
};

export const toEventCreatePayload = (input: {
  slug: string;
  title: string;
  start: string;
  end: string;
  timezone: string;
  capacity?: string;
}) => {
  const payload: Record<string, string | number> = {
    slug: input.slug.trim(),
    title: input.title.trim(),
    start: input.start.trim(),
    end: input.end.trim(),
    timezone: input.timezone.trim(),
  };

  if (input.capacity && input.capacity.trim().length > 0) {
    payload.capacity = Number(input.capacity);
  }

  return payload;
};


===== FILE: src/lib/admin-registration-view.ts =====
export type RegistrationStatus = "REGISTERED" | "WAITLISTED" | "CANCELLED" | "CHECKED_IN";

export const canCheckIn = (status: RegistrationStatus): boolean => {
  return status === "REGISTERED" || status === "WAITLISTED";
};

export const canCancel = (status: RegistrationStatus): boolean => {
  return status === "REGISTERED" || status === "WAITLISTED" || status === "CHECKED_IN";
};

export const buildRegistrationPayload = (identifier: string): { user_id?: string; user_email?: string } => {
  const value = identifier.trim();
  if (!value) {
    return {};
  }

  if (value.includes("@")) {
    return { user_email: value.toLowerCase() };
  }

  return { user_id: value };
};

export const buildExportFileName = (slug: string, format: "json" | "csv") => {
  return `${slug}-registrations.${format}`;
};


===== FILE: src/lib/admin-users-ui.ts =====
export const MUTABLE_ROLES = ["ADMIN"] as const;

type UserFilterInput = {
  search?: string;
  status?: string;
  role?: string;
};

export const buildUsersListHref = (filters: UserFilterInput) => {
  const query = new URLSearchParams();

  if (filters.search && filters.search.trim().length > 0) {
    query.set("search", filters.search.trim());
  }

  if (filters.status && filters.status.trim().length > 0) {
    query.set("status", filters.status.trim());
  }

  if (filters.role && filters.role.trim().length > 0) {
    query.set("role", filters.role.trim());
  }

  const queryString = query.toString();
  return queryString.length > 0 ? `/api/v1/users?${queryString}` : "/api/v1/users";
};

export const normalizeRoles = (roles: string[]) => {
  return roles.map((role) => role.toUpperCase());
};

export const canAddRole = (roles: string[], role: string) => {
  const current = normalizeRoles(roles);
  return !current.includes(role.toUpperCase());
};

export const canRemoveRole = (roles: string[], role: string) => {
  const current = normalizeRoles(roles);
  return current.includes(role.toUpperCase());
};


===== FILE: src/lib/api/__tests__/foundation.test.ts =====
import { describe, expect, it } from "vitest";

import { GET as getApiRoot } from "../../../app/api/v1/route";
import { GET as getApiDocs } from "../../../app/api/v1/docs/route";
import { hal, mediaTypes, problem } from "../response";

describe("API foundation response builders", () => {
  it("returns HAL payload with links and content type", async () => {
    const response = hal(
      { service: "test" },
      {
        self: { href: "/api/v1" },
      },
      { requestId: "req-hal-1" },
    );

    const body = await response.json();

    expect(response.status).toBe(200);
    expect(response.headers.get("content-type")).toContain(mediaTypes.hal);
    expect(response.headers.get("x-request-id")).toBe("req-hal-1");
    expect(body).toEqual({
      service: "test",
      _links: {
        self: { href: "/api/v1" },
      },
    });
  });

  it("returns RFC 9457 problem payload with request correlation", async () => {
    const request = new Request("http://localhost:3000/api/v1/events");
    const response = problem(
      {
        type: "https://example.com/problems/unauthorized",
        title: "Unauthorized",
        status: 401,
        detail: "Missing or invalid credentials",
      },
      request,
      { requestId: "req-problem-1" },
    );

    const body = await response.json();

    expect(response.status).toBe(401);
    expect(response.headers.get("content-type")).toContain(mediaTypes.problem);
    expect(response.headers.get("x-request-id")).toBe("req-problem-1");
    expect(body).toMatchObject({
      type: "https://example.com/problems/unauthorized",
      title: "Unauthorized",
      status: 401,
      detail: "Missing or invalid credentials",
      instance: "http://localhost:3000/api/v1/events",
      request_id: "req-problem-1",
    });
  });
});

describe("API foundation routes", () => {
  it("serves /api/v1 as HAL discoverability root", async () => {
    const response = await getApiRoot();
    const body = await response.json();

    expect(response.status).toBe(200);
    expect(response.headers.get("content-type")).toContain(mediaTypes.hal);
    expect(body._links).toMatchObject({
      self: { href: "/api/v1" },
      docs: { href: "/api/v1/docs" },
      auth_register: { href: "/api/v1/auth/register" },
      auth_login: { href: "/api/v1/auth/login" },
      me: { href: "/api/v1/me" },
      events: { href: "/api/v1/events" },
    });
  });

  it("serves /api/v1/docs as OpenAPI 3.1 JSON", async () => {
    const response = await getApiDocs();
    const body = await response.json();

    expect(response.status).toBe(200);
    expect(response.headers.get("content-type")).toContain("application/json");
    expect(body).toMatchObject({
      openapi: "3.1.0",
      info: {
        title: "LMS 219 API",
      },
    });
    expect(body.paths).toHaveProperty("/api/v1");
    expect(body.paths).toHaveProperty("/api/v1/docs");
  });
});


===== FILE: src/lib/api/audit.ts =====
import { mkdirSync } from "node:fs";
import { dirname, resolve } from "node:path";
import Database from "better-sqlite3";

import { resolveConfig } from "../../cli/config";
import { AppConfig } from "../../cli/types";

export type AuditEntry = {
  id: string;
  actor_type: string;
  actor_id: string | null;
  action: string;
  target_type: string;
  target_id: string | null;
  metadata: Record<string, unknown> | null;
  created_at: string;
  request_id: string;
};

const openDb = (config: AppConfig): Database.Database => {
  const dbPath = resolve(config.db.file);
  mkdirSync(dirname(dbPath), { recursive: true });
  const db = new Database(dbPath);
  db.pragma(`busy_timeout = ${config.db.busyTimeoutMs}`);
  db.pragma("foreign_keys = ON");
  db.pragma("journal_mode = WAL");
  return db;
};

const sensitiveKey = (key: string) => /(token|password|secret|email)/i.test(key);

const redactValue = (value: unknown): unknown => {
  if (Array.isArray(value)) {
    return value.map((item) => redactValue(item));
  }

  if (value && typeof value === "object") {
    const input = value as Record<string, unknown>;
    const output: Record<string, unknown> = {};
    for (const [key, nested] of Object.entries(input)) {
      output[key] = sensitiveKey(key) ? "[REDACTED]" : redactValue(nested);
    }
    return output;
  }

  return value;
};

const parseAndRedactMetadata = (raw: string | null): Record<string, unknown> | null => {
  if (!raw) {
    return null;
  }

  try {
    const parsed = JSON.parse(raw) as unknown;
    const redacted = redactValue(parsed);
    if (redacted && typeof redacted === "object" && !Array.isArray(redacted)) {
      return redacted as Record<string, unknown>;
    }
    return { value: redacted };
  } catch {
    return null;
  }
};

export const listAuditEntries = (filters: {
  action?: string;
  actor_id?: string;
  from?: string;
  to?: string;
  limit?: number;
  offset?: number;
}): { count: number; limit: number; offset: number; items: AuditEntry[] } => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);

  try {
    const clauses: string[] = [];
    const params: unknown[] = [];

    if (filters.action) {
      clauses.push("action = ?");
      params.push(filters.action);
    }

    if (filters.actor_id) {
      clauses.push("actor_id = ?");
      params.push(filters.actor_id);
    }

    if (filters.from) {
      clauses.push("created_at >= ?");
      params.push(filters.from);
    }

    if (filters.to) {
      clauses.push("created_at <= ?");
      params.push(filters.to);
    }

    const whereClause = clauses.length > 0 ? `WHERE ${clauses.join(" AND ")}` : "";
    const limit = Math.min(Math.max(filters.limit ?? 50, 1), 200);
    const offset = Math.max(filters.offset ?? 0, 0);

    const rows = db
      .prepare(
        `
SELECT id, actor_type, actor_id, action, target_type, target_id, metadata, created_at, request_id
FROM audit_log
${whereClause}
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`,
      )
      .all(...params, limit, offset) as Array<{
      id: string;
      actor_type: string;
      actor_id: string | null;
      action: string;
      target_type: string;
      target_id: string | null;
      metadata: string | null;
      created_at: string;
      request_id: string;
    }>;

    const items: AuditEntry[] = rows.map((row) => ({
      id: row.id,
      actor_type: row.actor_type,
      actor_id: row.actor_id,
      action: row.action,
      target_type: row.target_type,
      target_id: row.target_id,
      metadata: parseAndRedactMetadata(row.metadata),
      created_at: row.created_at,
      request_id: row.request_id,
    }));

    return {
      count: items.length,
      limit,
      offset,
      items,
    };
  } finally {
    db.close();
  }
};


===== FILE: src/lib/api/auth.ts =====
import { createHash, randomUUID } from "node:crypto";
import { mkdirSync } from "node:fs";
import { dirname, resolve } from "node:path";
import { hash, verify } from "@node-rs/argon2";
import Database from "better-sqlite3";

import { resolveConfig } from "../../cli/config";
import { AppConfig, RuntimeEnv } from "../../cli/types";

const SESSION_COOKIE = "lms_session";
const SESSION_DAYS = 7;

type Role = "USER" | "ADMIN" | "SUPER_ADMIN";

export interface SessionUser {
  id: string;
  email: string;
  status: string;
  roles: string[];
}

interface AuthContext {
  config: AppConfig;
  env: RuntimeEnv;
}

const openDb = (config: AppConfig): Database.Database => {
  const dbPath = resolve(config.db.file);
  mkdirSync(dirname(dbPath), { recursive: true });
  const db = new Database(dbPath);
  db.pragma(`busy_timeout = ${config.db.busyTimeoutMs}`);
  db.pragma("foreign_keys = ON");
  db.pragma("journal_mode = WAL");
  return db;
};

const appendAudit = (
  db: Database.Database,
  action: string,
  requestId: string,
  metadata?: Record<string, unknown>,
): void => {
  db.prepare(
    `
INSERT INTO audit_log (
  id,
  actor_type,
  actor_id,
  action,
  target_type,
  target_id,
  metadata,
  created_at,
  request_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
  ).run(
    randomUUID(),
    "USER",
    null,
    action,
    "api",
    null,
    metadata ? JSON.stringify(metadata) : null,
    new Date().toISOString(),
    requestId,
  );
};

const hashSessionToken = (token: string): string =>
  createHash("sha256").update(token).digest("hex");

const hashPasswordResetToken = (token: string): string =>
  createHash("sha256").update(token).digest("hex");

const hashEmailVerificationToken = (token: string): string =>
  createHash("sha256").update(token).digest("hex");

const isEmailVerificationRequired = (): boolean => {
  const value = process.env.APPCTL_REQUIRE_EMAIL_VERIFICATION;
  return value === "1" || value === "true" || value === "yes";
};

const ensureAuthTables = (db: Database.Database): void => {
  db.exec(`
CREATE TABLE IF NOT EXISTS api_credentials (
  user_id TEXT PRIMARY KEY,
  password_hash TEXT NOT NULL,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS api_sessions (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  session_token_hash TEXT NOT NULL UNIQUE,
  created_at TEXT NOT NULL,
  expires_at TEXT NOT NULL,
  last_seen_at TEXT,
  revoked_at TEXT,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS api_password_resets (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  token_hash TEXT NOT NULL UNIQUE,
  created_at TEXT NOT NULL,
  expires_at TEXT NOT NULL,
  used_at TEXT,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS api_email_verifications (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  token_hash TEXT NOT NULL UNIQUE,
  created_at TEXT NOT NULL,
  expires_at TEXT NOT NULL,
  used_at TEXT,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS api_policy_consents (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  policy TEXT NOT NULL,
  accepted_at TEXT NOT NULL,
  policy_version TEXT NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS api_account_deletions (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  deleted_at TEXT NOT NULL,
  retention_until TEXT NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);
`);
};

const ensureRole = (db: Database.Database, role: Role): string => {
  const found = db.prepare("SELECT id FROM roles WHERE name = ?").get(role) as
    | { id: string }
    | undefined;
  if (found) {
    return found.id;
  }

  const id = randomUUID();
  db.prepare("INSERT INTO roles (id, name) VALUES (?, ?)").run(id, role);
  return id;
};

const getRolesForUser = (db: Database.Database, userId: string): string[] => {
  const rows = db
    .prepare(
      `
SELECT r.name
FROM roles r
JOIN user_roles ur ON ur.role_id = r.id
WHERE ur.user_id = ?
ORDER BY r.name ASC
`,
    )
    .all(userId) as { name: string }[];

  return rows.map((row) => row.name);
};

const createSession = (
  db: Database.Database,
  userId: string,
  requestId: string,
): { token: string; expiresAt: string } => {
  const token = `sess_${randomUUID().replace(/-/g, "")}`;
  const id = randomUUID();
  const now = new Date();
  const expires = new Date(now);
  expires.setDate(expires.getDate() + SESSION_DAYS);

  db.prepare(
    `
INSERT INTO api_sessions (
  id,
  user_id,
  session_token_hash,
  created_at,
  expires_at,
  last_seen_at,
  revoked_at
) VALUES (?, ?, ?, ?, ?, ?, NULL)
`,
  ).run(
    id,
    userId,
    hashSessionToken(token),
    now.toISOString(),
    expires.toISOString(),
    now.toISOString(),
  );

  appendAudit(db, "api.auth.login", requestId, {
    userId,
    sessionId: id,
  });

  return {
    token,
    expiresAt: expires.toISOString(),
  };
};

export const getAuthContext = (): AuthContext => {
  const config = resolveConfig({ envVars: process.env });
  return {
    config,
    env: config.env,
  };
};

export const parseSessionTokenFromCookie = (cookieHeader: string | null): string | null => {
  if (!cookieHeader) {
    return null;
  }

  const segments = cookieHeader.split(";").map((segment) => segment.trim());
  for (const segment of segments) {
    if (segment.startsWith(`${SESSION_COOKIE}=`)) {
      return segment.substring(`${SESSION_COOKIE}=`.length);
    }
  }

  return null;
};

export const buildSessionCookie = (token: string, env: RuntimeEnv): string => {
  const parts = [
    `${SESSION_COOKIE}=${token}`,
    "Path=/",
    "HttpOnly",
    "SameSite=Lax",
    `Max-Age=${SESSION_DAYS * 24 * 60 * 60}`,
  ];

  if (env === "prod") {
    parts.push("Secure");
  }

  return parts.join("; ");
};

export const buildSessionClearCookie = (env: RuntimeEnv): string => {
  const parts = [`${SESSION_COOKIE}=`, "Path=/", "HttpOnly", "SameSite=Lax", "Max-Age=0"];
  if (env === "prod") {
    parts.push("Secure");
  }
  return parts.join("; ");
};

export const isSameOriginMutation = (request: Request): boolean => {
  const origin = request.headers.get("origin");
  if (!origin) {
    return true;
  }

  return origin === new URL(request.url).origin;
};

export const registerUser = async (
  email: string,
  password: string,
  termsAccepted = true,
  requestId: string,
): Promise<SessionUser & { verification_token?: string }> => {
  const { config } = getAuthContext();
  const db = openDb(config);

  try {
    ensureAuthTables(db);

    const normalizedEmail = email.trim().toLowerCase();
    if (!normalizedEmail || !password) {
      throw new Error("invalid_register_payload");
    }

    if (!termsAccepted) {
      throw new Error("invalid_terms_ack");
    }

    const passwordHash = await hash(password, {
      algorithm: 2,
      memoryCost: 19456,
      timeCost: 2,
      parallelism: 1,
    });

    const id = randomUUID();
    const now = new Date().toISOString();

    const run = db.transaction(() => {
      const requireVerification = isEmailVerificationRequired();
      const accountStatus = requireVerification ? "PENDING" : "ACTIVE";
      let verificationToken: string | undefined;

      db.prepare("INSERT INTO users (id, email, status, created_at, updated_at) VALUES (?, ?, ?, ?, ?)").run(
        id,
        normalizedEmail,
        accountStatus,
        now,
        now,
      );

      db.prepare(
        "INSERT INTO api_credentials (user_id, password_hash, created_at, updated_at) VALUES (?, ?, ?, ?)",
      ).run(id, passwordHash, now, now);

      const userRoleId = ensureRole(db, "USER");
      db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(id, userRoleId);

      appendAudit(db, "api.auth.register", requestId, {
        userId: id,
        email: normalizedEmail,
        verificationRequired: requireVerification,
      });

      db.prepare(
        "INSERT INTO api_policy_consents (id, user_id, policy, accepted_at, policy_version) VALUES (?, ?, ?, ?, ?)",
      ).run(randomUUID(), id, "TERMS", now, "2026-02-17");

      db.prepare(
        "INSERT INTO api_policy_consents (id, user_id, policy, accepted_at, policy_version) VALUES (?, ?, ?, ?, ?)",
      ).run(randomUUID(), id, "PRIVACY", now, "2026-02-17");

      if (requireVerification) {
        verificationToken = `verify_${randomUUID().replace(/-/g, "")}`;
        db.prepare(
          `
INSERT INTO api_email_verifications (
  id,
  user_id,
  token_hash,
  created_at,
  expires_at,
  used_at
) VALUES (?, ?, ?, ?, ?, NULL)
`,
        ).run(
          randomUUID(),
          id,
          hashEmailVerificationToken(verificationToken),
          now,
          new Date(Date.now() + 1000 * 60 * 30).toISOString(),
        );

        appendAudit(db, "api.auth.email_verification.issue", requestId, {
          userId: id,
          reason: "register",
        });
      }

      return {
        id,
        email: normalizedEmail,
        status: accountStatus,
        roles: ["USER"],
        verification_token: config.env === "local" ? verificationToken : undefined,
      };
    });

    return run();
  } finally {
    db.close();
  }
};

export const loginUser = async (
  email: string,
  password: string,
  requestId: string,
): Promise<{ sessionToken: string; user: SessionUser }> => {
  const { config } = getAuthContext();
  const db = openDb(config);

  try {
    ensureAuthTables(db);

    const normalizedEmail = email.trim().toLowerCase();
    const row = db
      .prepare(
        `
SELECT u.id, u.email, u.status, ac.password_hash
FROM users u
JOIN api_credentials ac ON ac.user_id = u.id
WHERE u.email = ?
`,
      )
      .get(normalizedEmail) as
      | {
          id: string;
          email: string;
          status: string;
          password_hash: string;
        }
      | undefined;

    if (!row) {
      throw new Error("invalid_credentials");
    }

    const verified = await verify(row.password_hash, password);
    if (!verified) {
      throw new Error("invalid_credentials");
    }

    if (row.status === "PENDING") {
      throw new Error("email_unverified");
    }

    if (row.status !== "ACTIVE") {
      throw new Error("invalid_credentials");
    }

    const result = db.transaction(() => {
      const session = createSession(db, row.id, requestId);
      const roles = getRolesForUser(db, row.id);
      return {
        session,
        user: {
          id: row.id,
          email: row.email,
          status: row.status,
          roles,
        },
      };
    })();

    return {
      sessionToken: result.session.token,
      user: result.user,
    };
  } finally {
    db.close();
  }
};

export const logoutUser = (sessionToken: string, requestId: string): void => {
  const { config } = getAuthContext();
  const db = openDb(config);

  try {
    ensureAuthTables(db);

    db.transaction(() => {
      db.prepare("UPDATE api_sessions SET revoked_at = ? WHERE session_token_hash = ? AND revoked_at IS NULL").run(
        new Date().toISOString(),
        hashSessionToken(sessionToken),
      );

      appendAudit(db, "api.auth.logout", requestId, {
        revoked: true,
      });
    })();
  } finally {
    db.close();
  }
};

export const getUserFromSession = (sessionToken: string): SessionUser | null => {
  const { config } = getAuthContext();
  const db = openDb(config);

  try {
    ensureAuthTables(db);
    const now = new Date().toISOString();

    const row = db
      .prepare(
        `
SELECT u.id, u.email, u.status
FROM api_sessions s
JOIN users u ON u.id = s.user_id
WHERE s.session_token_hash = ?
  AND s.revoked_at IS NULL
  AND s.expires_at > ?
`,
      )
      .get(hashSessionToken(sessionToken), now) as
      | {
          id: string;
          email: string;
          status: string;
        }
      | undefined;

    if (!row || row.status !== "ACTIVE") {
      return null;
    }

    const roles = getRolesForUser(db, row.id);
    return {
      id: row.id,
      email: row.email,
      status: row.status,
      roles,
    };
  } finally {
    db.close();
  }
};

export const getSessionUserFromRequest = (request: Request): SessionUser | null => {
  const sessionToken = parseSessionTokenFromCookie(request.headers.get("cookie"));
  if (!sessionToken) {
    return null;
  }

  return getUserFromSession(sessionToken);
};

export const deleteOwnAccount = (userId: string, requestId: string): { deleted: true } => {
  const { config } = getAuthContext();
  const db = openDb(config);

  try {
    ensureAuthTables(db);

    db.transaction(() => {
      const found = db.prepare("SELECT id FROM users WHERE id = ?").get(userId) as { id: string } | undefined;
      if (!found) {
        throw new Error("user_not_found");
      }

      const now = new Date();
      const nowIso = now.toISOString();
      const retentionUntil = new Date(now.getTime() + 1000 * 60 * 60 * 24 * 30).toISOString();

      db.prepare("UPDATE users SET status = 'DISABLED', email = ?, updated_at = ? WHERE id = ?").run(
        `deleted+${userId}@deleted.local`,
        nowIso,
        userId,
      );

      db.prepare("DELETE FROM user_roles WHERE user_id = ?").run(userId);

      db.prepare("UPDATE api_sessions SET revoked_at = ? WHERE user_id = ? AND revoked_at IS NULL").run(nowIso, userId);

      db.prepare(
        "UPDATE event_registrations SET status = 'CANCELLED' WHERE user_id = ? AND status IN ('REGISTERED', 'WAITLISTED', 'CHECKED_IN')",
      ).run(userId);

      db.prepare(
        "INSERT INTO api_account_deletions (id, user_id, deleted_at, retention_until) VALUES (?, ?, ?, ?)",
      ).run(randomUUID(), userId, nowIso, retentionUntil);

      appendAudit(db, "api.account.delete", requestId, {
        userId,
        retentionUntil,
      });
    })();

    return { deleted: true };
  } finally {
    db.close();
  }
};

export const requestPasswordReset = (email: string, requestId: string): { accepted: true; token?: string } => {
  const { config } = getAuthContext();
  const db = openDb(config);

  try {
    ensureAuthTables(db);

    const normalizedEmail = email.trim().toLowerCase();
    if (!normalizedEmail) {
      throw new Error("invalid_reset_email");
    }

    const token = `reset_${randomUUID().replace(/-/g, "")}`;
    const tokenHash = hashPasswordResetToken(token);
    const now = new Date();
    const expiresAt = new Date(now.getTime() + 1000 * 60 * 30).toISOString();

    db.transaction(() => {
      const user = db.prepare("SELECT id FROM users WHERE email = ?").get(normalizedEmail) as
        | { id: string }
        | undefined;

      appendAudit(db, "api.auth.password_reset.request", requestId, {
        email: normalizedEmail,
        found: Boolean(user),
      });

      if (!user) {
        return;
      }

      db.prepare(
        "UPDATE api_password_resets SET used_at = ? WHERE user_id = ? AND used_at IS NULL",
      ).run(now.toISOString(), user.id);

      db.prepare(
        `
INSERT INTO api_password_resets (
  id,
  user_id,
  token_hash,
  created_at,
  expires_at,
  used_at
) VALUES (?, ?, ?, ?, ?, NULL)
`,
      ).run(randomUUID(), user.id, tokenHash, now.toISOString(), expiresAt);
    })();

    if (config.env === "local") {
      return { accepted: true, token };
    }

    return { accepted: true };
  } finally {
    db.close();
  }
};

export const confirmPasswordReset = async (
  token: string,
  password: string,
  requestId: string,
): Promise<{ reset: true }> => {
  const { config } = getAuthContext();
  const db = openDb(config);

  try {
    ensureAuthTables(db);

    const normalizedToken = token.trim();
    if (!normalizedToken || !password) {
      throw new Error("invalid_reset_payload");
    }

    const now = new Date().toISOString();
    const found = db
      .prepare(
        `
SELECT id, user_id, expires_at, used_at
FROM api_password_resets
WHERE token_hash = ?
`,
      )
      .get(hashPasswordResetToken(normalizedToken)) as
      | {
          id: string;
          user_id: string;
          expires_at: string;
          used_at: string | null;
        }
      | undefined;

    if (!found) {
      throw new Error("reset_token_invalid");
    }

    if (found.used_at) {
      throw new Error("reset_token_used");
    }

    if (found.expires_at <= now) {
      throw new Error("reset_token_expired");
    }

    const passwordHash = await hash(password, {
      algorithm: 2,
      memoryCost: 19456,
      timeCost: 2,
      parallelism: 1,
    });

    db.transaction(() => {
      db.prepare(
        "UPDATE api_credentials SET password_hash = ?, updated_at = ? WHERE user_id = ?",
      ).run(passwordHash, now, found.user_id);

      db.prepare("UPDATE api_password_resets SET used_at = ? WHERE id = ?").run(now, found.id);

      appendAudit(db, "api.auth.password_reset.confirm", requestId, {
        userId: found.user_id,
      });
    })();

    return { reset: true };
  } finally {
    db.close();
  }
};

export const getLatestPasswordResetTokenForEmail = (email: string): string | null => {
  const { config } = getAuthContext();
  if (config.env !== "local") {
    return null;
  }

  const db = openDb(config);
  try {
    ensureAuthTables(db);

    const user = db.prepare("SELECT id FROM users WHERE email = ?").get(email.trim().toLowerCase()) as
      | { id: string }
      | undefined;

    if (!user) {
      return null;
    }

    const row = db
      .prepare(
        `
SELECT id
FROM api_password_resets
WHERE user_id = ?
ORDER BY created_at DESC
LIMIT 1
`,
      )
      .get(user.id) as { id: string } | undefined;

    if (!row) {
      return null;
    }

    return row.id;
  } finally {
    db.close();
  }
};

export const requestEmailVerification = (
  email: string,
  requestId: string,
): { accepted: true; token?: string } => {
  const { config } = getAuthContext();
  const db = openDb(config);

  try {
    ensureAuthTables(db);

    const normalizedEmail = email.trim().toLowerCase();
    if (!normalizedEmail) {
      throw new Error("invalid_verify_email");
    }

    const now = new Date();
    const nowIso = now.toISOString();
    const token = `verify_${randomUUID().replace(/-/g, "")}`;

    db.transaction(() => {
      const user = db.prepare("SELECT id, status FROM users WHERE email = ?").get(normalizedEmail) as
        | { id: string; status: string }
        | undefined;

      appendAudit(db, "api.auth.email_verification.request", requestId, {
        email: normalizedEmail,
        found: Boolean(user),
      });

      if (!user || user.status === "ACTIVE") {
        return;
      }

      db.prepare(
        "UPDATE api_email_verifications SET used_at = ? WHERE user_id = ? AND used_at IS NULL",
      ).run(nowIso, user.id);

      db.prepare(
        `
INSERT INTO api_email_verifications (
  id,
  user_id,
  token_hash,
  created_at,
  expires_at,
  used_at
) VALUES (?, ?, ?, ?, ?, NULL)
`,
      ).run(
        randomUUID(),
        user.id,
        hashEmailVerificationToken(token),
        nowIso,
        new Date(now.getTime() + 1000 * 60 * 30).toISOString(),
      );
    })();

    if (config.env === "local") {
      return { accepted: true, token };
    }

    return { accepted: true };
  } finally {
    db.close();
  }
};

export const confirmEmailVerification = (
  token: string,
  requestId: string,
): { verified: true } => {
  const { config } = getAuthContext();
  const db = openDb(config);

  try {
    ensureAuthTables(db);

    const normalizedToken = token.trim();
    if (!normalizedToken) {
      throw new Error("invalid_verify_token");
    }

    const now = new Date().toISOString();
    const row = db
      .prepare(
        `
SELECT id, user_id, expires_at, used_at
FROM api_email_verifications
WHERE token_hash = ?
`,
      )
      .get(hashEmailVerificationToken(normalizedToken)) as
      | {
          id: string;
          user_id: string;
          expires_at: string;
          used_at: string | null;
        }
      | undefined;

    if (!row) {
      throw new Error("verify_token_invalid");
    }

    if (row.used_at) {
      throw new Error("verify_token_used");
    }

    if (row.expires_at <= now) {
      throw new Error("verify_token_expired");
    }

    db.transaction(() => {
      db.prepare("UPDATE users SET status = 'ACTIVE', updated_at = ? WHERE id = ?").run(now, row.user_id);
      db.prepare("UPDATE api_email_verifications SET used_at = ? WHERE id = ?").run(now, row.id);

      appendAudit(db, "api.auth.email_verification.confirm", requestId, {
        userId: row.user_id,
      });
    })();

    return { verified: true };
  } finally {
    db.close();
  }
};


===== FILE: src/lib/api/events.ts =====
import { randomUUID } from "node:crypto";
import { mkdirSync } from "node:fs";
import { dirname, resolve } from "node:path";
import Database from "better-sqlite3";

import { resolveConfig } from "../../cli/config";
import { AppConfig } from "../../cli/types";

export type EventStatus = "DRAFT" | "PUBLISHED" | "CANCELLED";

export interface EventRecord {
  id: string;
  slug: string;
  title: string;
  start_at: string;
  end_at: string;
  timezone: string;
  status: EventStatus;
  capacity: number | null;
  created_by: string | null;
  created_at: string;
  updated_at: string;
}

const openDb = (config: AppConfig): Database.Database => {
  const dbPath = resolve(config.db.file);
  mkdirSync(dirname(dbPath), { recursive: true });
  const db = new Database(dbPath);
  db.pragma(`busy_timeout = ${config.db.busyTimeoutMs}`);
  db.pragma("foreign_keys = ON");
  db.pragma("journal_mode = WAL");
  return db;
};

const appendAudit = (
  db: Database.Database,
  action: string,
  actorId: string,
  requestId: string,
  metadata?: Record<string, unknown>,
): void => {
  db.prepare(
    `
INSERT INTO audit_log (
  id,
  actor_type,
  actor_id,
  action,
  target_type,
  target_id,
  metadata,
  created_at,
  request_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
  ).run(
    randomUUID(),
    "USER",
    actorId,
    action,
    "event",
    null,
    metadata ? JSON.stringify(metadata) : null,
    new Date().toISOString(),
    requestId,
  );
};

const parseIso = (value: string, field: string): string => {
  const parsed = new Date(value);
  if (Number.isNaN(parsed.getTime())) {
    throw new Error(`invalid_${field}`);
  }
  return parsed.toISOString();
};

const parseTimezone = (timezone: string): string => {
  try {
    Intl.DateTimeFormat(undefined, { timeZone: timezone });
    return timezone;
  } catch {
    throw new Error("invalid_timezone");
  }
};

const parseCapacity = (value?: number): number | null => {
  if (value === undefined) {
    return null;
  }

  if (!Number.isInteger(value) || value < 0) {
    throw new Error("invalid_capacity");
  }

  return value;
};

const ensureStartBeforeEnd = (startIso: string, endIso: string): void => {
  if (new Date(startIso).getTime() >= new Date(endIso).getTime()) {
    throw new Error("invalid_window");
  }
};

const baseEventLinks = (slug: string) => ({
  self: { href: `/api/v1/events/${slug}` },
  collection: { href: "/api/v1/events" },
});

export const eventLinksForState = (slug: string, status: EventStatus) => {
  const links: Record<string, { href: string }> = {
    ...baseEventLinks(slug),
  };

  if (status === "DRAFT") {
    links["app:publish"] = { href: `/api/v1/events/${slug}/publish` };
  }

  if (status === "PUBLISHED") {
    links["app:cancel"] = { href: `/api/v1/events/${slug}/cancel` };
    links["app:ics"] = { href: `/api/v1/events/${slug}/ics` };
  }

  return links;
};

const getEventBySlugInternal = (db: Database.Database, slug: string): EventRecord => {
  const found = db.prepare("SELECT * FROM events WHERE slug = ?").get(slug) as EventRecord | undefined;
  if (!found) {
    throw new Error("event_not_found");
  }
  return found;
};

export const listEvents = (filters: {
  status?: string;
  q?: string;
  from?: string;
  to?: string;
  limit?: number;
  offset?: number;
}) => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);

  try {
    const clauses: string[] = [];
    const params: unknown[] = [];

    if (filters.status) {
      clauses.push("status = ?");
      params.push(filters.status.toUpperCase());
    }

    if (filters.q) {
      clauses.push("title LIKE ?");
      params.push(`%${filters.q}%`);
    }

    if (filters.from) {
      clauses.push("start_at >= ?");
      params.push(parseIso(filters.from, "from"));
    }

    if (filters.to) {
      clauses.push("start_at <= ?");
      params.push(parseIso(filters.to, "to"));
    }

    const whereClause = clauses.length > 0 ? `WHERE ${clauses.join(" AND ")}` : "";
    const limit = Math.min(Math.max(filters.limit ?? 25, 1), 100);
    const offset = Math.max(filters.offset ?? 0, 0);

    const rows = db
      .prepare(
        `
SELECT *
FROM events
${whereClause}
ORDER BY start_at ASC
LIMIT ? OFFSET ?
`,
      )
      .all(...params, limit, offset) as EventRecord[];

    return {
      count: rows.length,
      limit,
      offset,
      items: rows,
    };
  } finally {
    db.close();
  }
};

export const getEventBySlug = (slug: string): EventRecord => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);
  try {
    return getEventBySlugInternal(db, slug);
  } finally {
    db.close();
  }
};

export const createEvent = (
  args: {
    slug: string;
    title: string;
    start: string;
    end: string;
    timezone: string;
    capacity?: number;
  },
  actorId: string,
  requestId: string,
) => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);

  try {
    const slug = args.slug.trim();
    const title = args.title.trim();
    if (!slug) {
      throw new Error("invalid_slug");
    }
    if (!title) {
      throw new Error("invalid_title");
    }

    const startAt = parseIso(args.start, "start");
    const endAt = parseIso(args.end, "end");
    ensureStartBeforeEnd(startAt, endAt);
    const timezone = parseTimezone(args.timezone);
    const capacity = parseCapacity(args.capacity);

    const id = randomUUID();
    const now = new Date().toISOString();

    const created = db.transaction(() => {
      try {
        db.prepare(
          `
INSERT INTO events (
  id,
  slug,
  title,
  start_at,
  end_at,
  timezone,
  status,
  capacity,
  created_by,
  created_at,
  updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
        ).run(id, slug, title, startAt, endAt, timezone, "DRAFT", capacity, actorId, now, now);
      } catch (error) {
        if (error instanceof Error && error.message.includes("UNIQUE constraint failed: events.slug")) {
          throw new Error("event_conflict");
        }
        throw error;
      }

      appendAudit(db, "api.event.create", actorId, requestId, {
        eventId: id,
        slug,
      });

      return getEventBySlugInternal(db, slug);
    })();

    return created;
  } finally {
    db.close();
  }
};

export const updateEvent = (
  slug: string,
  changes: { title?: string; start?: string; end?: string; capacity?: number },
  actorId: string,
  requestId: string,
) => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);

  try {
    const updated = db.transaction(() => {
      const existing = getEventBySlugInternal(db, slug);

      const title = changes.title?.trim() || existing.title;
      const startAt = changes.start ? parseIso(changes.start, "start") : existing.start_at;
      const endAt = changes.end ? parseIso(changes.end, "end") : existing.end_at;
      ensureStartBeforeEnd(startAt, endAt);
      const capacity =
        changes.capacity === undefined ? existing.capacity : parseCapacity(changes.capacity);
      const now = new Date().toISOString();

      db.prepare(
        `
UPDATE events
SET title = ?, start_at = ?, end_at = ?, capacity = ?, updated_at = ?
WHERE slug = ?
`,
      ).run(title, startAt, endAt, capacity, now, slug);

      appendAudit(db, "api.event.update", actorId, requestId, {
        slug,
      });

      return getEventBySlugInternal(db, slug);
    })();

    return updated;
  } finally {
    db.close();
  }
};

export const publishEvent = (slug: string, actorId: string, requestId: string) => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);
  try {
    const published = db.transaction(() => {
      const existing = getEventBySlugInternal(db, slug);
      const now = new Date().toISOString();

      if (existing.status !== "PUBLISHED") {
        db.prepare("UPDATE events SET status = 'PUBLISHED', updated_at = ? WHERE slug = ?").run(now, slug);
      }

      appendAudit(db, "api.event.publish", actorId, requestId, {
        slug,
        idempotent: existing.status === "PUBLISHED",
      });

      return getEventBySlugInternal(db, slug);
    })();

    return published;
  } finally {
    db.close();
  }
};

export const cancelEvent = (slug: string, reason: string, actorId: string, requestId: string) => {
  const trimmedReason = reason.trim();
  if (!trimmedReason) {
    throw new Error("cancel_reason_required");
  }

  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);
  try {
    const cancelled = db.transaction(() => {
      getEventBySlugInternal(db, slug);
      const now = new Date().toISOString();

      db.prepare("UPDATE events SET status = 'CANCELLED', updated_at = ? WHERE slug = ?").run(now, slug);

      appendAudit(db, "api.event.cancel", actorId, requestId, {
        slug,
        reason: trimmedReason,
      });

      return getEventBySlugInternal(db, slug);
    })();

    return cancelled;
  } finally {
    db.close();
  }
};


===== FILE: src/lib/api/invitations.ts =====
import { randomUUID, createHash } from "node:crypto";
import { mkdirSync } from "node:fs";
import { dirname, resolve } from "node:path";
import { hash } from "@node-rs/argon2";
import Database from "better-sqlite3";

import { resolveConfig } from "../../cli/config";
import type { AppConfig } from "../../cli/types";

const openDb = (config: AppConfig): Database.Database => {
  const dbPath = resolve(config.db.file);
  mkdirSync(dirname(dbPath), { recursive: true });
  const db = new Database(dbPath);
  db.pragma(`busy_timeout = ${config.db.busyTimeoutMs}`);
  db.pragma("foreign_keys = ON");
  db.pragma("journal_mode = WAL");
  return db;
};

const hashInviteToken = (token: string): string =>
  createHash("sha256").update(token).digest("hex");

const appendAudit = (
  db: Database.Database,
  action: string,
  actorId: string | null,
  requestId: string,
  metadata?: Record<string, unknown>,
): void => {
  db.prepare(
    `
INSERT INTO audit_log (
  id,
  actor_type,
  actor_id,
  action,
  target_type,
  target_id,
  metadata,
  created_at,
  request_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
  ).run(
    randomUUID(),
    "USER",
    actorId,
    action,
    "user",
    null,
    metadata ? JSON.stringify(metadata) : null,
    new Date().toISOString(),
    requestId,
  );
};

const ensureRole = (db: Database.Database, role: string): string => {
  const normalized = role.toUpperCase();
  const row = db.prepare("SELECT id FROM roles WHERE name = ?").get(normalized) as { id: string } | undefined;
  if (row) {
    return row.id;
  }

  const id = randomUUID();
  db.prepare("INSERT INTO roles (id, name) VALUES (?, ?)").run(id, normalized);
  return id;
};

const ensureInvitationTables = (db: Database.Database): void => {
  db.exec(`
CREATE TABLE IF NOT EXISTS api_credentials (
  user_id TEXT PRIMARY KEY,
  password_hash TEXT NOT NULL,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS api_admin_invitations (
  id TEXT PRIMARY KEY,
  email TEXT NOT NULL,
  role TEXT NOT NULL,
  token_hash TEXT NOT NULL UNIQUE,
  invited_by TEXT NOT NULL,
  created_at TEXT NOT NULL,
  expires_at TEXT NOT NULL,
  accepted_at TEXT,
  cancelled_at TEXT
);
`);
};

export const createAdminInvitation = (
  email: string,
  actorId: string,
  requestId: string,
): { email: string; role: "ADMIN"; token?: string } => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);

  try {
    ensureInvitationTables(db);
    const normalizedEmail = email.trim().toLowerCase();
    if (!normalizedEmail) {
      throw new Error("invalid_email");
    }

    const existingUser = db.prepare("SELECT id FROM users WHERE email = ?").get(normalizedEmail) as
      | { id: string }
      | undefined;

    if (existingUser) {
      throw new Error("existing_account");
    }

    const now = new Date();
    const nowIso = now.toISOString();
    const token = `invite_${randomUUID().replace(/-/g, "")}`;

    db.transaction(() => {
      db.prepare(
        `
UPDATE api_admin_invitations
SET cancelled_at = ?
WHERE email = ? AND accepted_at IS NULL AND cancelled_at IS NULL
`,
      ).run(nowIso, normalizedEmail);

      db.prepare(
        `
INSERT INTO api_admin_invitations (
  id,
  email,
  role,
  token_hash,
  invited_by,
  created_at,
  expires_at,
  accepted_at,
  cancelled_at
) VALUES (?, ?, ?, ?, ?, ?, ?, NULL, NULL)
`,
      ).run(
        randomUUID(),
        normalizedEmail,
        "ADMIN",
        hashInviteToken(token),
        actorId,
        nowIso,
        new Date(now.getTime() + 1000 * 60 * 60 * 24).toISOString(),
      );

      appendAudit(db, "api.admin.invite.create", actorId, requestId, {
        email: normalizedEmail,
        role: "ADMIN",
      });
    })();

    return {
      email: normalizedEmail,
      role: "ADMIN",
      ...(config.env === "local" ? { token } : {}),
    };
  } finally {
    db.close();
  }
};

export const acceptAdminInvitation = async (
  token: string,
  password: string,
  requestId: string,
): Promise<{ id: string; email: string; role: "ADMIN" }> => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);

  try {
    ensureInvitationTables(db);

    const normalizedToken = token.trim();
    if (!normalizedToken || !password) {
      throw new Error("invalid_payload");
    }

    const invite = db
      .prepare(
        `
SELECT id, email, role, expires_at, accepted_at, cancelled_at
FROM api_admin_invitations
WHERE token_hash = ?
`,
      )
      .get(hashInviteToken(normalizedToken)) as
      | {
          id: string;
          email: string;
          role: string;
          expires_at: string;
          accepted_at: string | null;
          cancelled_at: string | null;
        }
      | undefined;

    if (!invite) {
      throw new Error("invite_not_found");
    }

    if (invite.accepted_at || invite.cancelled_at) {
      throw new Error("invite_used");
    }

    if (invite.expires_at <= new Date().toISOString()) {
      throw new Error("invite_expired");
    }

    const now = new Date().toISOString();

    const existingUser = db.prepare("SELECT id FROM users WHERE email = ?").get(invite.email) as
      | { id: string }
      | undefined;
    if (existingUser) {
      throw new Error("existing_account");
    }

    const passwordHash = await hash(password, {
      algorithm: 2,
      memoryCost: 19456,
      timeCost: 2,
      parallelism: 1,
    });

    const userId = randomUUID();
    db.transaction(() => {
      db.prepare("INSERT INTO users (id, email, status, created_at, updated_at) VALUES (?, ?, ?, ?, ?)").run(
        userId,
        invite.email,
        "ACTIVE",
        now,
        now,
      );

      db.prepare(
        "INSERT INTO api_credentials (user_id, password_hash, created_at, updated_at) VALUES (?, ?, ?, ?)",
      ).run(userId, passwordHash, now, now);

      const userRole = ensureRole(db, "USER");
      const adminRole = ensureRole(db, "ADMIN");
      db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(userId, userRole);
      db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(userId, adminRole);

      db.prepare("UPDATE api_admin_invitations SET accepted_at = ? WHERE id = ?").run(now, invite.id);

      appendAudit(db, "api.admin.invite.accept", userId, requestId, {
        email: invite.email,
        role: "ADMIN",
      });
    })();

    return {
      id: userId,
      email: invite.email,
      role: "ADMIN",
    };
  } finally {
    db.close();
  }
};


===== FILE: src/lib/api/openapi.ts =====
export const openApiDocument = {
  openapi: "3.1.0",
  info: {
    title: "LMS 219 API",
    version: "0.1.0",
    description: "API contract skeleton for Sprint 07 foundation.",
  },
  servers: [{ url: "/" }],
  paths: {
    "/api/v1": {
      get: {
        summary: "API root",
        responses: {
          "200": {
            description: "HAL root document",
          },
        },
      },
    },
    "/api/v1/docs": {
      get: {
        summary: "OpenAPI document",
        responses: {
          "200": {
            description: "OpenAPI 3.1 JSON",
          },
        },
      },
    },
  },
} as const;


===== FILE: src/lib/api/rate-limit.ts =====
type RateLimitEntry = {
  count: number;
  resetAt: number;
};

const buckets = new Map<string, RateLimitEntry>();

const nowMs = (): number => Date.now();

const getClientId = (request: Request): string => {
  const forwarded = request.headers.get("x-forwarded-for");
  if (forwarded) {
    return forwarded.split(",")[0]?.trim() || "unknown";
  }

  const realIp = request.headers.get("x-real-ip");
  if (realIp) {
    return realIp;
  }

  return "unknown";
};

export const consumeRateLimit = (
  request: Request,
  key: string,
  limit: number,
  windowMs: number,
): { allowed: boolean; retryAfterSeconds: number } => {
  const clientId = getClientId(request);
  const bucketKey = `${key}:${clientId}`;
  const current = buckets.get(bucketKey);
  const now = nowMs();

  if (!current || current.resetAt <= now) {
    buckets.set(bucketKey, {
      count: 1,
      resetAt: now + windowMs,
    });
    return { allowed: true, retryAfterSeconds: Math.ceil(windowMs / 1000) };
  }

  if (current.count >= limit) {
    return {
      allowed: false,
      retryAfterSeconds: Math.max(1, Math.ceil((current.resetAt - now) / 1000)),
    };
  }

  current.count += 1;
  buckets.set(bucketKey, current);
  return {
    allowed: true,
    retryAfterSeconds: Math.max(1, Math.ceil((current.resetAt - now) / 1000)),
  };
};

export const resetRateLimits = (): void => {
  buckets.clear();
};


===== FILE: src/lib/api/registrations.ts =====
import { randomUUID } from "node:crypto";
import { mkdirSync } from "node:fs";
import { dirname, resolve } from "node:path";
import Database from "better-sqlite3";

import { resolveConfig } from "../../cli/config";
import { AppConfig } from "../../cli/types";

export type RegistrationStatus = "REGISTERED" | "WAITLISTED" | "CANCELLED" | "CHECKED_IN";

export interface RegistrationRecord {
  id: string;
  event_id: string;
  user_id: string;
  status: RegistrationStatus;
}

export interface RegistrationListRow {
  id: string;
  event_slug: string;
  user_id: string;
  user_email: string;
  status: RegistrationStatus;
}

export interface UserRegistrationHistoryRow {
  registration_id: string;
  event_id: string;
  event_slug: string;
  event_title: string;
  status: RegistrationStatus;
}

const openDb = (config: AppConfig): Database.Database => {
  const dbPath = resolve(config.db.file);
  mkdirSync(dirname(dbPath), { recursive: true });
  const db = new Database(dbPath);
  db.pragma(`busy_timeout = ${config.db.busyTimeoutMs}`);
  db.pragma("foreign_keys = ON");
  db.pragma("journal_mode = WAL");
  return db;
};

const appendAudit = (
  db: Database.Database,
  action: string,
  actorId: string,
  requestId: string,
  metadata?: Record<string, unknown>,
): void => {
  db.prepare(
    `
INSERT INTO audit_log (
  id,
  actor_type,
  actor_id,
  action,
  target_type,
  target_id,
  metadata,
  created_at,
  request_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
  ).run(
    randomUUID(),
    "USER",
    actorId,
    action,
    "registration",
    null,
    metadata ? JSON.stringify(metadata) : null,
    new Date().toISOString(),
    requestId,
  );
};

const resolveEvent = (db: Database.Database, slug: string): { id: string; slug: string; capacity: number | null } => {
  const event = db.prepare("SELECT id, slug, capacity FROM events WHERE slug = ?").get(slug) as
    | { id: string; slug: string; capacity: number | null }
    | undefined;
  if (!event) {
    throw new Error("event_not_found");
  }
  return event;
};

const resolveUser = (db: Database.Database, identifier: string): { id: string; email: string } => {
  const isEmail = identifier.includes("@");
  const user = isEmail
    ? (db.prepare("SELECT id, email FROM users WHERE email = ?").get(identifier.toLowerCase()) as
        | { id: string; email: string }
        | undefined)
    : (db.prepare("SELECT id, email FROM users WHERE id = ?").get(identifier) as
        | { id: string; email: string }
        | undefined);

  if (!user) {
    throw new Error("user_not_found");
  }

  return user;
};

const computeRegistrationStatus = (
  db: Database.Database,
  eventId: string,
  capacity: number | null,
): RegistrationStatus => {
  if (capacity === null) {
    return "REGISTERED";
  }

  const activeCount = db
    .prepare(
      "SELECT COUNT(*) AS count FROM event_registrations WHERE event_id = ? AND status IN ('REGISTERED', 'CHECKED_IN')",
    )
    .get(eventId) as { count: number };

  return activeCount.count >= capacity ? "WAITLISTED" : "REGISTERED";
};

export const addRegistration = (
  eventSlug: string,
  userIdentifier: string,
  actorId: string,
  requestId: string,
): RegistrationRecord => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);

  try {
    const event = resolveEvent(db, eventSlug);
    const user = resolveUser(db, userIdentifier);

    const result = db.transaction(() => {
      const existing = db
        .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
        .get(event.id, user.id) as RegistrationRecord | undefined;

      const status = computeRegistrationStatus(db, event.id, event.capacity);

      if (!existing) {
        db.prepare("INSERT INTO event_registrations (id, event_id, user_id, status) VALUES (?, ?, ?, ?)").run(
          randomUUID(),
          event.id,
          user.id,
          status,
        );
      } else if (existing.status === "CANCELLED") {
        db.prepare("UPDATE event_registrations SET status = ? WHERE id = ?").run(status, existing.id);
      }

      appendAudit(db, "api.registration.add", actorId, requestId, {
        eventSlug,
        userId: user.id,
      });

      return db
        .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
        .get(event.id, user.id) as RegistrationRecord;
    })();

    return result;
  } finally {
    db.close();
  }
};

export const removeRegistration = (
  eventSlug: string,
  userIdentifier: string,
  actorId: string,
  requestId: string,
  reason?: string,
): RegistrationRecord => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);

  try {
    const event = resolveEvent(db, eventSlug);
    const user = resolveUser(db, userIdentifier);

    return db.transaction(() => {
      const existing = db
        .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
        .get(event.id, user.id) as RegistrationRecord | undefined;

      if (!existing) {
        throw new Error("registration_not_found");
      }

      db.prepare("UPDATE event_registrations SET status = 'CANCELLED' WHERE id = ?").run(existing.id);

      appendAudit(db, "api.registration.cancel", actorId, requestId, {
        eventSlug,
        userId: user.id,
        reason: reason ?? null,
      });

      return db
        .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
        .get(event.id, user.id) as RegistrationRecord;
    })();
  } finally {
    db.close();
  }
};

export const listRegistrations = (eventSlug: string, status?: string): RegistrationListRow[] => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);

  try {
    const event = resolveEvent(db, eventSlug);
    const params: unknown[] = [event.id];
    const clauses = ["r.event_id = ?"];

    if (status) {
      clauses.push("r.status = ?");
      params.push(status.toUpperCase());
    }

    return db
      .prepare(
        `
SELECT r.id, e.slug AS event_slug, u.id AS user_id, u.email AS user_email, r.status
FROM event_registrations r
JOIN events e ON e.id = r.event_id
JOIN users u ON u.id = r.user_id
WHERE ${clauses.join(" AND ")}
ORDER BY u.email ASC
`,
      )
      .all(...params) as RegistrationListRow[];
  } finally {
    db.close();
  }
};

export const checkinRegistration = (
  eventSlug: string,
  userIdentifier: string,
  actorId: string,
  requestId: string,
): RegistrationRecord => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);

  try {
    const event = resolveEvent(db, eventSlug);
    const user = resolveUser(db, userIdentifier);

    return db.transaction(() => {
      const existing = db
        .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
        .get(event.id, user.id) as RegistrationRecord | undefined;

      if (!existing) {
        throw new Error("registration_not_found");
      }

      if (existing.status === "CANCELLED") {
        throw new Error("registration_cancelled");
      }

      db.prepare("UPDATE event_registrations SET status = 'CHECKED_IN' WHERE id = ?").run(existing.id);

      appendAudit(db, "api.registration.checkin", actorId, requestId, {
        eventSlug,
        userId: user.id,
      });

      return db
        .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
        .get(event.id, user.id) as RegistrationRecord;
    })();
  } finally {
    db.close();
  }
};

export const exportEventData = (args: {
  slug: string;
  format: "csv" | "json";
  includeEmail: boolean;
  actorId: string;
  requestId: string;
}) => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);
  try {
    const event = resolveEvent(db, args.slug);
    const rows = db
      .prepare(
        `
SELECT r.id, r.status, u.id AS user_id, u.email AS user_email
FROM event_registrations r
JOIN users u ON u.id = r.user_id
WHERE r.event_id = ?
ORDER BY u.email ASC
`,
      )
      .all(event.id) as Array<{ id: string; status: string; user_id: string; user_email: string }>;

    const serializable = rows.map((row) =>
      args.includeEmail
        ? {
            id: row.id,
            status: row.status,
            user_id: row.user_id,
            user_email: row.user_email,
          }
        : {
            id: row.id,
            status: row.status,
            user_id: row.user_id,
          },
    );

    appendAudit(db, "api.event.export", args.actorId, args.requestId, {
      slug: args.slug,
      format: args.format,
      includeEmail: args.includeEmail,
      count: rows.length,
    });

    if (args.format === "json") {
      return {
        format: "json" as const,
        body: JSON.stringify(serializable, null, 2),
      };
    }

    const headers = args.includeEmail ? ["id", "status", "user_id", "user_email"] : ["id", "status", "user_id"];
    const bodyRows = serializable
      .map((row) => headers.map((header) => JSON.stringify((row as Record<string, string>)[header] ?? "")).join(","))
      .join("\n");
    const csv = `${headers.join(",")}\n${bodyRows}${bodyRows ? "\n" : ""}`;

    return {
      format: "csv" as const,
      body: csv,
    };
  } finally {
    db.close();
  }
};

export const listRegistrationsForUser = (userId: string): UserRegistrationHistoryRow[] => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);

  try {
    return db
      .prepare(
        `
SELECT
  r.id AS registration_id,
  e.id AS event_id,
  e.slug AS event_slug,
  e.title AS event_title,
  r.status
FROM event_registrations r
JOIN events e ON e.id = r.event_id
WHERE r.user_id = ?
ORDER BY e.start_at ASC
`,
      )
      .all(userId) as UserRegistrationHistoryRow[];
  } finally {
    db.close();
  }
};


===== FILE: src/lib/api/response.ts =====
type HalLinks = Record<string, { href: string; [key: string]: unknown }>;

type HalOptions = {
  status?: number;
  requestId?: string;
  headers?: HeadersInit;
};

type ProblemInput = {
  type: string;
  title: string;
  status: number;
  detail?: string;
  instance?: string;
  [key: string]: unknown;
};

type ProblemOptions = {
  requestId?: string;
  headers?: HeadersInit;
};

const HAL_CONTENT_TYPE = "application/hal+json";
const PROBLEM_CONTENT_TYPE = "application/problem+json";

const createRequestId = () => {
  if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
    return crypto.randomUUID();
  }

  return `${Date.now()}-${Math.random().toString(16).slice(2)}`;
};

const withCommonHeaders = (
  requestId: string,
  contentType: string,
  headers?: HeadersInit,
) => {
  const merged = new Headers(headers);
  merged.set("content-type", contentType);
  merged.set("x-request-id", requestId);
  return merged;
};

export const hal = (
  payload: Record<string, unknown>,
  links: HalLinks,
  options: HalOptions = {},
) => {
  const requestId = options.requestId ?? createRequestId();
  return Response.json(
    {
      ...payload,
      _links: links,
    },
    {
      status: options.status ?? 200,
      headers: withCommonHeaders(requestId, HAL_CONTENT_TYPE, options.headers),
    },
  );
};

export const problem = (
  issue: ProblemInput,
  request?: Request,
  options: ProblemOptions = {},
) => {
  const requestId = options.requestId ?? createRequestId();
  return Response.json(
    {
      ...issue,
      instance: issue.instance ?? request?.url,
      request_id: requestId,
    },
    {
      status: issue.status,
      headers: withCommonHeaders(
        requestId,
        PROBLEM_CONTENT_TYPE,
        options.headers,
      ),
    },
  );
};

export const mediaTypes = {
  hal: HAL_CONTENT_TYPE,
  problem: PROBLEM_CONTENT_TYPE,
} as const;


===== FILE: src/lib/api/users.ts =====
import { randomUUID } from "node:crypto";
import { mkdirSync } from "node:fs";
import { dirname, resolve } from "node:path";
import Database from "better-sqlite3";

import { resolveConfig } from "../../cli/config";
import { AppConfig } from "../../cli/types";

const openDb = (config: AppConfig): Database.Database => {
  const dbPath = resolve(config.db.file);
  mkdirSync(dirname(dbPath), { recursive: true });
  const db = new Database(dbPath);
  db.pragma(`busy_timeout = ${config.db.busyTimeoutMs}`);
  db.pragma("foreign_keys = ON");
  db.pragma("journal_mode = WAL");
  return db;
};

const appendAudit = (
  db: Database.Database,
  action: string,
  actorId: string,
  requestId: string,
  metadata?: Record<string, unknown>,
): void => {
  db.prepare(
    `
INSERT INTO audit_log (
  id,
  actor_type,
  actor_id,
  action,
  target_type,
  target_id,
  metadata,
  created_at,
  request_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
  ).run(
    randomUUID(),
    "USER",
    actorId,
    action,
    "user",
    null,
    metadata ? JSON.stringify(metadata) : null,
    new Date().toISOString(),
    requestId,
  );
};

const getRolesForUser = (db: Database.Database, userId: string): string[] => {
  const rows = db
    .prepare(
      `
SELECT r.name
FROM roles r
JOIN user_roles ur ON ur.role_id = r.id
WHERE ur.user_id = ?
ORDER BY r.name ASC
`,
    )
    .all(userId) as { name: string }[];
  return rows.map((row) => row.name);
};

const ensureUserExists = (db: Database.Database, userId: string): void => {
  const found = db.prepare("SELECT id FROM users WHERE id = ?").get(userId) as
    | { id: string }
    | undefined;
  if (!found) {
    throw new Error("user_not_found");
  }
};

const ensureRoleExists = (db: Database.Database, role: string): string => {
  const normalizedRole = role.toUpperCase();
  const found = db.prepare("SELECT id FROM roles WHERE name = ?").get(normalizedRole) as
    | { id: string }
    | undefined;

  if (found) {
    return found.id;
  }

  const id = randomUUID();
  db.prepare("INSERT INTO roles (id, name) VALUES (?, ?)").run(id, normalizedRole);
  return id;
};

const toUserResponse = (
  db: Database.Database,
  row: { id: string; email: string; status: string; created_at: string; updated_at: string },
) => ({
  ...row,
  roles: getRolesForUser(db, row.id),
});

export const listUsers = (filters: {
  role?: string;
  status?: string;
  search?: string;
  limit?: number;
  offset?: number;
}) => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);

  try {
    const joins: string[] = [];
    const clauses: string[] = [];
    const params: unknown[] = [];

    if (filters.role) {
      joins.push("JOIN user_roles ur ON ur.user_id = u.id", "JOIN roles r ON r.id = ur.role_id");
      clauses.push("r.name = ?");
      params.push(filters.role.toUpperCase());
    }

    if (filters.status) {
      clauses.push("u.status = ?");
      params.push(filters.status.toUpperCase());
    }

    if (filters.search) {
      clauses.push("u.email LIKE ?");
      params.push(`%${filters.search}%`);
    }

    const whereClause = clauses.length > 0 ? `WHERE ${clauses.join(" AND ")}` : "";
    const query = `
SELECT DISTINCT u.id, u.email, u.status, u.created_at, u.updated_at
FROM users u
${joins.join(" ")}
${whereClause}
ORDER BY u.created_at ASC
LIMIT ? OFFSET ?
`;

    const limit = Math.min(Math.max(filters.limit ?? 25, 1), 100);
    const offset = Math.max(filters.offset ?? 0, 0);
    const rows = db.prepare(query).all(...params, limit, offset) as {
      id: string;
      email: string;
      status: string;
      created_at: string;
      updated_at: string;
    }[];

    return {
      count: rows.length,
      items: rows.map((row) => toUserResponse(db, row)),
      limit,
      offset,
    };
  } finally {
    db.close();
  }
};

export const getUserById = (id: string) => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);

  try {
    const row = db
      .prepare("SELECT id, email, status, created_at, updated_at FROM users WHERE id = ?")
      .get(id) as
      | {
          id: string;
          email: string;
          status: string;
          created_at: string;
          updated_at: string;
        }
      | undefined;

    if (!row) {
      throw new Error("user_not_found");
    }

    return toUserResponse(db, row);
  } finally {
    db.close();
  }
};

export const updateUserStatus = (
  id: string,
  status: string,
  actorId: string,
  requestId: string,
) => {
  const normalizedStatus = status.toUpperCase();
  if (!["ACTIVE", "DISABLED", "PENDING"].includes(normalizedStatus)) {
    throw new Error("invalid_status");
  }

  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);

  try {
    const now = new Date().toISOString();
    const result = db.transaction(() => {
      const change = db
        .prepare("UPDATE users SET status = ?, updated_at = ? WHERE id = ?")
        .run(normalizedStatus, now, id);

      if (change.changes === 0) {
        throw new Error("user_not_found");
      }

      appendAudit(db, "api.user.update", actorId, requestId, {
        userId: id,
        status: normalizedStatus,
      });

      const row = db
        .prepare("SELECT id, email, status, created_at, updated_at FROM users WHERE id = ?")
        .get(id) as {
        id: string;
        email: string;
        status: string;
        created_at: string;
        updated_at: string;
      };

      return toUserResponse(db, row);
    })();

    return result;
  } finally {
    db.close();
  }
};

export const addUserRole = (id: string, role: string, actorId: string, requestId: string) => {
  const normalizedRole = role.toUpperCase();
  if (normalizedRole === "SUPER_ADMIN") {
    throw new Error("super_admin_forbidden");
  }

  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);
  try {
    const result = db.transaction(() => {
      ensureUserExists(db, id);
      const roleId = ensureRoleExists(db, normalizedRole);
      const change = db
        .prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)")
        .run(id, roleId);

      appendAudit(db, "api.user.role.add", actorId, requestId, {
        userId: id,
        role: normalizedRole,
        changed: change.changes > 0,
      });

      return {
        changed: change.changes > 0,
        role: normalizedRole,
      };
    })();

    return result;
  } finally {
    db.close();
  }
};

export const removeUserRole = (id: string, role: string, actorId: string, requestId: string) => {
  const normalizedRole = role.toUpperCase();
  if (normalizedRole === "SUPER_ADMIN") {
    throw new Error("super_admin_forbidden");
  }

  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);
  try {
    const result = db.transaction(() => {
      ensureUserExists(db, id);

      const roleRow = db.prepare("SELECT id FROM roles WHERE name = ?").get(normalizedRole) as
        | { id: string }
        | undefined;

      const change = roleRow
        ? db
            .prepare("DELETE FROM user_roles WHERE user_id = ? AND role_id = ?")
            .run(id, roleRow.id)
        : { changes: 0 };

      appendAudit(db, "api.user.role.remove", actorId, requestId, {
        userId: id,
        role: normalizedRole,
        changed: change.changes > 0,
      });

      return {
        changed: change.changes > 0,
        role: normalizedRole,
      };
    })();

    return result;
  } finally {
    db.close();
  }
};


===== FILE: src/lib/auth-forms.ts =====
import { z } from "zod";

export const loginSchema = z.object({
  email: z.string().email("Enter a valid email address."),
  password: z.string().min(8, "Password must be at least 8 characters."),
});

export const registerSchema = z
  .object({
    email: z.string().email("Enter a valid email address."),
    password: z.string().min(8, "Password must be at least 8 characters."),
    confirmPassword: z.string().min(8, "Confirm your password."),
    termsAccepted: z.boolean().refine((value) => value, {
      message: "You must accept Terms and Privacy.",
    }),
  })
  .refine((value) => value.password === value.confirmPassword, {
    path: ["confirmPassword"],
    message: "Passwords do not match.",
  });

export type LoginFormValues = z.infer<typeof loginSchema>;
export type RegisterFormValues = z.infer<typeof registerSchema>;


===== FILE: src/lib/hal-client.ts =====
export interface HalLink {
  href: string;
  [key: string]: unknown;
}

export interface HalResource {
  _links: Record<string, HalLink>;
  [key: string]: unknown;
}

export interface ProblemDetails {
  type: string;
  title: string;
  status: number;
  detail?: string;
  instance?: string;
  request_id?: string;
  errors?: string[];
  [key: string]: unknown;
}

export type HalResult<T> =
  | { ok: true; data: T }
  | { ok: false; problem: ProblemDetails };

const acceptHeader = "application/hal+json, application/problem+json, application/json";

const isProblem = (value: unknown): value is ProblemDetails => {
  return (
    typeof value === "object" &&
    value !== null &&
    "title" in value &&
    "status" in value &&
    typeof (value as { title: unknown }).title === "string" &&
    typeof (value as { status: unknown }).status === "number"
  );
};

export const follow = (resource: HalResource, rel: string): HalLink | null => {
  return resource._links[rel] ?? null;
};

const safeJson = async (response: Response): Promise<unknown> => {
  try {
    return await response.json();
  } catch {
    return null;
  }
};

export const requestHal = async <T>(
  href: string,
  init?: RequestInit,
): Promise<HalResult<T>> => {
  const response = await fetch(href, {
    ...init,
    credentials: "include",
    headers: {
      accept: acceptHeader,
      ...(init?.headers ?? {}),
    },
  });

  const body = await safeJson(response);

  if (!response.ok) {
    if (isProblem(body)) {
      return { ok: false, problem: body };
    }

    return {
      ok: false,
      problem: {
        type: "about:blank",
        title: "Request Failed",
        status: response.status,
        detail: "Request failed and no problem details were returned.",
      },
    };
  }

  return {
    ok: true,
    data: body as T,
  };
};

export const getRoot = async (): Promise<HalResult<HalResource>> => {
  return requestHal<HalResource>("/api/v1");
};


===== FILE: src/lib/ui-access.ts =====
import { follow, HalResource } from "./hal-client";

export const canAccessAdminFromMe = (resource: HalResource): boolean => {
  return follow(resource, "users") !== null;
};

export const adminAccessProblem = {
  type: "https://lms-219.dev/problems/forbidden",
  title: "Forbidden",
  status: 403,
  detail: "Admin access requires users management affordance from /api/v1/me.",
} as const;


