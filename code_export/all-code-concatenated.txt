===== FILE: COURSE_README.md =====
# Intro to Build Web Apps with AI 

## Background Info

[React Documentary](https://www.youtube.com/watch?v=8pDqJVdNa44)



===== FILE: docs/cli-manual.md =====
# appctl CLI Manual

## 1. Overview

`appctl` is the operational control plane for this project. It provides auditable, repeatable commands for:

- database lifecycle
- service token security
- user and role administration
- event lifecycle
- registration/check-in/export operations

All mutating commands are designed to write audit records.

## 2. Prerequisites

- Node.js 20+
- Dependencies installed (`npm install`)

Run CLI:

```bash
npm run cli -- --help
```

## 3. Configuration

Configuration precedence:

1. CLI flags
2. environment variables
3. config file
4. defaults

Primary env var:

- `APPCTL_DB_FILE` — SQLite database path

Examples:

```bash
APPCTL_DB_FILE=./data/app.db npm run cli -- db status --env local
```

## 4. Global Flags

- `--env <local|staging|prod>`
- `--json`
- `--token <token>`
- `--yes`
- `--trace`
- `--quiet`

## 5. Command Reference

### 5.1 Health and DB

```bash
npm run cli -- doctor --env local --json
npm run cli -- db status --env local
npm run cli -- db migrate --env local
npm run cli -- db seed --env local
npm run cli -- db backup --out ./tmp/backup.db --env local
npm run cli -- db restore --from ./tmp/backup.db --env local --yes
```

### 5.2 Tokens

```bash
npm run cli -- auth token create --name ops-token --env local --json
npm run cli -- auth token revoke --id <TOKEN_ID> --env local
```

### 5.3 Users and Roles

```bash
npm run cli -- user create --email admin@example.com --status ACTIVE --env local
npm run cli -- user list --env local --json
npm run cli -- user show --email admin@example.com --env local --json
npm run cli -- user disable --id <USER_ID> --reason "security" --env local
npm run cli -- user enable --id <USER_ID> --env local
npm run cli -- user role add --id <USER_ID> --role ADMIN --env local
npm run cli -- user role remove --id <USER_ID> --role ADMIN --env local
```

### 5.4 Events

```bash
npm run cli -- event create --slug spring-launch --title "Spring Launch" --start 2026-04-01T14:00:00Z --end 2026-04-01T15:00:00Z --tz UTC --capacity 100 --env local
npm run cli -- event update --slug spring-launch --title "Spring Launch v2" --env local
npm run cli -- event publish --slug spring-launch --env local
npm run cli -- event cancel --slug spring-launch --reason "operational" --env local
npm run cli -- event list --status CANCELLED --env local --json
```

### 5.5 Registrations and Export

```bash
npm run cli -- reg add --event spring-launch --user admin@example.com --env local
npm run cli -- reg remove --event spring-launch --user admin@example.com --reason "requested" --env local
npm run cli -- reg list --event spring-launch --env local --json
npm run cli -- checkin --event spring-launch --user admin@example.com --env local
npm run cli -- event export --slug spring-launch --format csv --out ./tmp/spring-launch.csv --env local
npm run cli -- event export --slug spring-launch --format json --out ./tmp/spring-launch.json --env local
```

## 6. Security and Safety Rails

### 6.1 Staging/Prod write protection

Write commands in `staging`/`prod` require a valid token:

```bash
npm run cli -- user create --email x@example.com --env staging --token <TOKEN>
```

### 6.2 PII export control

`--include-email` outside local requires token:

```bash
npm run cli -- event export --slug spring-launch --format json --out ./tmp/secure.json --include-email --env staging --token <TOKEN>
```

### 6.3 Dangerous prod DB operations

For `db backup` / `db restore` in `prod`, all are required:

- `--force-prod`
- `--yes`
- valid `--token`

Example:

```bash
npm run cli -- db backup --out ./tmp/prod-backup.db --env prod --force-prod --yes --token <TOKEN>
```

## 7. Exit Code Guide

- `0` success
- `1` unexpected/internal error
- `2` usage or validation error
- `3` auth/permission error
- `4` not found
- `5` conflict/already exists
- `6` precondition failed

## 8. Recommended Local Bootstrap Flow

```bash
npm run cli -- db migrate --env local
npm run cli -- db seed --env local
npm run cli -- auth token create --name local-admin --env local --json
npm run cli -- user create --email admin@example.com --status ACTIVE --env local
```

## 9. Verification Commands

Core validation:

```bash
npm test
npm run lint
npm run build
npm run cli -- doctor --env local --json
```

Manual round-trip backup/restore:

```bash
npm run cli -- db backup --out ./tmp/backup.db --env local
npm run cli -- db restore --from ./tmp/backup.db --env local --yes
```

## 10. CLI Architecture (Contributor Notes)

The CLI now follows a layered structure to keep business logic separate from persistence and delivery concerns.

### 10.1 Layering

1. **Delivery layer** — `src/cli/run-cli.ts`
	- Parses commands/flags
	- Resolves runtime config
	- Formats JSON/text output
	- Calls use-case functions only

2. **Use-case layer** — `src/cli/auth-users.ts`, `src/cli/events.ts`, `src/cli/registrations.ts`
	- Performs input validation and orchestration
	- Enforces auth/schema preconditions
	- Maps repository/domain errors to CLI errors/exit codes
	- Avoids direct SQL and low-level DB setup

3. **Repository layer** — `src/cli/*-repository.ts`
	- Owns SQL statements and transactions
	- Persists audit log rows
	- Returns typed records/errors for use cases

4. **Shared repository utilities**
	- `src/cli/repository-helpers.ts` — common DB open + service audit append helpers
	- `src/cli/service-token-repository.ts` — shared token lookup for write auth

5. **Cross-cutting use-case helpers**
	- `src/cli/write-auth.ts` — shared write auth enforcement for non-local envs
	- `src/cli/schema-guard.ts` — shared migration precondition guard

### 10.2 Rules for New CLI Work

- Put command parsing and output formatting in `run-cli.ts` only.
- Put business flow/validation in use-case modules.
- Put SQL/transactions in repository modules.
- Prefer typed errors over message-string branching.
- Keep audit writes inside repository operations that mutate state.

This structure keeps commands testable, makes persistence swappable, and reduces duplication across CLI surfaces.


===== FILE: e2e/critical-flows.spec.ts =====
import { expect, test } from "@playwright/test";

test("critical public auth and event browse flow", async ({ page }) => {
  await page.goto("/register");
  await expect(page.getByRole("heading", { name: "Register" })).toBeVisible();

  await page.goto("/login");
  await expect(page.getByRole("heading", { name: "Login" })).toBeVisible();

  await page.goto("/events");
  await expect(page.getByRole("heading", { name: "Events" })).toBeVisible();
});

test("critical admin routes are reachable behind auth gate", async ({ page }) => {
  await page.goto("/admin");
  await expect(page.getByText(/Checking admin access|Unauthorized|Forbidden/)).toBeVisible();
});


===== FILE: eslint.config.mjs =====
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;


===== FILE: next-env.d.ts =====
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


===== FILE: next.config.ts =====
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;


===== FILE: package-lock.json =====
{
  "name": "lms_219",
  "version": "0.1.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "lms_219",
      "version": "0.1.0",
      "dependencies": {
        "@hookform/resolvers": "^5.2.2",
        "@node-rs/argon2": "^2.0.2",
        "better-sqlite3": "^12.6.2",
        "commander": "^14.0.3",
        "cosmiconfig": "^9.0.0",
        "next": "16.1.6",
        "pino": "^10.3.1",
        "react": "19.2.3",
        "react-dom": "19.2.3",
        "react-hook-form": "^7.71.1",
        "yaml": "^2.8.2",
        "zod": "^4.3.6"
      },
      "devDependencies": {
        "@playwright/test": "^1.58.2",
        "@tailwindcss/postcss": "^4",
        "@types/better-sqlite3": "^7.6.13",
        "@types/node": "^20",
        "@types/react": "^19",
        "@types/react-dom": "^19",
        "@types/yaml": "^1.9.6",
        "eslint": "^9",
        "eslint-config-next": "16.1.6",
        "tailwindcss": "^4",
        "tsx": "^4.21.0",
        "typescript": "^5",
        "vitest": "^4.0.18"
      }
    },
    "node_modules/@alloc/quick-lru": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@alloc/quick-lru/-/quick-lru-5.2.0.tgz",
      "integrity": "sha512-UrcABB+4bUrFABwbluTIBErXwvbsU/V7TZWfmbgJfbkwiBuziS9gxdODUyuiecfdGQ85jglMW6juS3+z5TsKLw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/@babel/code-frame": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.29.0.tgz",
      "integrity": "sha512-9NhCeYjq9+3uxgdtp20LSiJXJvN0FeCtNGpJxuMFZ1Kv3cWUNb6DOhJwUvcVCzKGR66cw4njwM6hrJLqgOwbcw==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-validator-identifier": "^7.28.5",
        "js-tokens": "^4.0.0",
        "picocolors": "^1.1.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/compat-data": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.29.0.tgz",
      "integrity": "sha512-T1NCJqT/j9+cn8fvkt7jtwbLBfLC/1y1c7NtCeXFRgzGTsafi68MRv8yzkYSapBnFA6L3U2VSc02ciDzoAJhJg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/core": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.29.0.tgz",
      "integrity": "sha512-CGOfOJqWjg2qW/Mb6zNsDm+u5vFQ8DxXfbM09z69p5Z6+mE1ikP2jUXw+j42Pf1XTYED2Rni5f95npYeuwMDQA==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "@babel/code-frame": "^7.29.0",
        "@babel/generator": "^7.29.0",
        "@babel/helper-compilation-targets": "^7.28.6",
        "@babel/helper-module-transforms": "^7.28.6",
        "@babel/helpers": "^7.28.6",
        "@babel/parser": "^7.29.0",
        "@babel/template": "^7.28.6",
        "@babel/traverse": "^7.29.0",
        "@babel/types": "^7.29.0",
        "@jridgewell/remapping": "^2.3.5",
        "convert-source-map": "^2.0.0",
        "debug": "^4.1.0",
        "gensync": "^1.0.0-beta.2",
        "json5": "^2.2.3",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/babel"
      }
    },
    "node_modules/@babel/generator": {
      "version": "7.29.1",
      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.29.1.tgz",
      "integrity": "sha512-qsaF+9Qcm2Qv8SRIMMscAvG4O3lJ0F1GuMo5HR/Bp02LopNgnZBC/EkbevHFeGs4ls/oPz9v+Bsmzbkbe+0dUw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.29.0",
        "@babel/types": "^7.29.0",
        "@jridgewell/gen-mapping": "^0.3.12",
        "@jridgewell/trace-mapping": "^0.3.28",
        "jsesc": "^3.0.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-compilation-targets": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.28.6.tgz",
      "integrity": "sha512-JYtls3hqi15fcx5GaSNL7SCTJ2MNmjrkHXg4FSpOA/grxK8KwyZ5bubHsCq8FXCkua6xhuaaBit+3b7+VZRfcA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.28.6",
        "@babel/helper-validator-option": "^7.27.1",
        "browserslist": "^4.24.0",
        "lru-cache": "^5.1.1",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-globals": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/helper-globals/-/helper-globals-7.28.0.tgz",
      "integrity": "sha512-+W6cISkXFa1jXsDEdYA8HeevQT/FULhxzR99pxphltZcVaugps53THCeiWA8SguxxpSp3gKPiuYfSWopkLQ4hw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-imports": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.28.6.tgz",
      "integrity": "sha512-l5XkZK7r7wa9LucGw9LwZyyCUscb4x37JWTPz7swwFE/0FMQAGpiWUZn8u9DzkSBWEcK25jmvubfpw2dnAMdbw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/traverse": "^7.28.6",
        "@babel/types": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-transforms": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.28.6.tgz",
      "integrity": "sha512-67oXFAYr2cDLDVGLXTEABjdBJZ6drElUSI7WKp70NrpyISso3plG9SAGEF6y7zbha/wOzUByWWTJvEDVNIUGcA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.28.6",
        "@babel/helper-validator-identifier": "^7.28.5",
        "@babel/traverse": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-option": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.27.1.tgz",
      "integrity": "sha512-YvjJow9FxbhFFKDSuFnVCe2WxXk1zWc22fFePVNEaWJEu8IrZVlda6N0uHwzZrUM1il7NC9Mlp4MaJYbYd9JSg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helpers": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.28.6.tgz",
      "integrity": "sha512-xOBvwq86HHdB7WUDTfKfT/Vuxh7gElQ+Sfti2Cy6yIWNW05P8iUslOVcZ4/sKbE+/jQaukQAdz/gf3724kYdqw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.28.6",
        "@babel/types": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.29.0"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/template": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.28.6.tgz",
      "integrity": "sha512-YA6Ma2KsCdGb+WC6UpBVFJGXL58MDA6oyONbjyF/+5sBgxY/dwkhLogbMT2GXXyU84/IhRw/2D1Os1B/giz+BQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.28.6",
        "@babel/parser": "^7.28.6",
        "@babel/types": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/traverse": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.29.0.tgz",
      "integrity": "sha512-4HPiQr0X7+waHfyXPZpWPfWL/J7dcN1mx9gL6WdQVMbPnF3+ZhSMs8tCxN7oHddJE9fhNE7+lxdnlyemKfJRuA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.29.0",
        "@babel/generator": "^7.29.0",
        "@babel/helper-globals": "^7.28.0",
        "@babel/parser": "^7.29.0",
        "@babel/template": "^7.28.6",
        "@babel/types": "^7.29.0",
        "debug": "^4.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.28.5"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@emnapi/core": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/@emnapi/core/-/core-1.8.1.tgz",
      "integrity": "sha512-AvT9QFpxK0Zd8J0jopedNm+w/2fIzvtPKPjqyw9jwvBaReTTqPBk9Hixaz7KbjimP+QNz605/XnjFcDAL2pqBg==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "@emnapi/wasi-threads": "1.1.0",
        "tslib": "^2.4.0"
      }
    },
    "node_modules/@emnapi/runtime": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/@emnapi/runtime/-/runtime-1.8.1.tgz",
      "integrity": "sha512-mehfKSMWjjNol8659Z8KxEMrdSJDDot5SXMq00dM8BN4o+CLNXQ0xH2V7EchNHV4RmbZLmmPdEaXZc5H2FXmDg==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "tslib": "^2.4.0"
      }
    },
    "node_modules/@emnapi/wasi-threads": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@emnapi/wasi-threads/-/wasi-threads-1.1.0.tgz",
      "integrity": "sha512-WI0DdZ8xFSbgMjR1sFsKABJ/C5OnRrjT06JXbZKexJGrDuPTzZdDYfFlsgcCXCyf+suG5QU2e/y1Wo2V/OapLQ==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "tslib": "^2.4.0"
      }
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.27.3.tgz",
      "integrity": "sha512-9fJMTNFTWZMh5qwrBItuziu834eOCUcEqymSH7pY+zoMVEZg3gcPuBNxH1EvfVYe9h0x/Ptw8KBzv7qxb7l8dg==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.27.3.tgz",
      "integrity": "sha512-i5D1hPY7GIQmXlXhs2w8AWHhenb00+GxjxRncS2ZM7YNVGNfaMxgzSGuO8o8SJzRc/oZwU2bcScvVERk03QhzA==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.27.3.tgz",
      "integrity": "sha512-YdghPYUmj/FX2SYKJ0OZxf+iaKgMsKHVPF1MAq/P8WirnSpCStzKJFjOjzsW0QQ7oIAiccHdcqjbHmJxRb/dmg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.27.3.tgz",
      "integrity": "sha512-IN/0BNTkHtk8lkOM8JWAYFg4ORxBkZQf9zXiEOfERX/CzxW3Vg1ewAhU7QSWQpVIzTW+b8Xy+lGzdYXV6UZObQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.27.3.tgz",
      "integrity": "sha512-Re491k7ByTVRy0t3EKWajdLIr0gz2kKKfzafkth4Q8A5n1xTHrkqZgLLjFEHVD+AXdUGgQMq+Godfq45mGpCKg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.27.3.tgz",
      "integrity": "sha512-vHk/hA7/1AckjGzRqi6wbo+jaShzRowYip6rt6q7VYEDX4LEy1pZfDpdxCBnGtl+A5zq8iXDcyuxwtv3hNtHFg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.27.3.tgz",
      "integrity": "sha512-ipTYM2fjt3kQAYOvo6vcxJx3nBYAzPjgTCk7QEgZG8AUO3ydUhvelmhrbOheMnGOlaSFUoHXB6un+A7q4ygY9w==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.27.3.tgz",
      "integrity": "sha512-dDk0X87T7mI6U3K9VjWtHOXqwAMJBNN2r7bejDsc+j03SEjtD9HrOl8gVFByeM0aJksoUuUVU9TBaZa2rgj0oA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.27.3.tgz",
      "integrity": "sha512-s6nPv2QkSupJwLYyfS+gwdirm0ukyTFNl3KTgZEAiJDd+iHZcbTPPcWCcRYH+WlNbwChgH2QkE9NSlNrMT8Gfw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.27.3.tgz",
      "integrity": "sha512-sZOuFz/xWnZ4KH3YfFrKCf1WyPZHakVzTiqji3WDc0BCl2kBwiJLCXpzLzUBLgmp4veFZdvN5ChW4Eq/8Fc2Fg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.27.3.tgz",
      "integrity": "sha512-yGlQYjdxtLdh0a3jHjuwOrxQjOZYD/C9PfdbgJJF3TIZWnm/tMd/RcNiLngiu4iwcBAOezdnSLAwQDPqTmtTYg==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.27.3.tgz",
      "integrity": "sha512-WO60Sn8ly3gtzhyjATDgieJNet/KqsDlX5nRC5Y3oTFcS1l0KWba+SEa9Ja1GfDqSF1z6hif/SkpQJbL63cgOA==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.27.3.tgz",
      "integrity": "sha512-APsymYA6sGcZ4pD6k+UxbDjOFSvPWyZhjaiPyl/f79xKxwTnrn5QUnXR5prvetuaSMsb4jgeHewIDCIWljrSxw==",
      "cpu": [
        "mips64el"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.27.3.tgz",
      "integrity": "sha512-eizBnTeBefojtDb9nSh4vvVQ3V9Qf9Df01PfawPcRzJH4gFSgrObw+LveUyDoKU3kxi5+9RJTCWlj4FjYXVPEA==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.27.3.tgz",
      "integrity": "sha512-3Emwh0r5wmfm3ssTWRQSyVhbOHvqegUDRd0WhmXKX2mkHJe1SFCMJhagUleMq+Uci34wLSipf8Lagt4LlpRFWQ==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.27.3.tgz",
      "integrity": "sha512-pBHUx9LzXWBc7MFIEEL0yD/ZVtNgLytvx60gES28GcWMqil8ElCYR4kvbV2BDqsHOvVDRrOxGySBM9Fcv744hw==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.27.3.tgz",
      "integrity": "sha512-Czi8yzXUWIQYAtL/2y6vogER8pvcsOsk5cpwL4Gk5nJqH5UZiVByIY8Eorm5R13gq+DQKYg0+JyQoytLQas4dA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-arm64/-/netbsd-arm64-0.27.3.tgz",
      "integrity": "sha512-sDpk0RgmTCR/5HguIZa9n9u+HVKf40fbEUt+iTzSnCaGvY9kFP0YKBWZtJaraonFnqef5SlJ8/TiPAxzyS+UoA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.27.3.tgz",
      "integrity": "sha512-P14lFKJl/DdaE00LItAukUdZO5iqNH7+PjoBm+fLQjtxfcfFE20Xf5CrLsmZdq5LFFZzb5JMZ9grUwvtVYzjiA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.27.3.tgz",
      "integrity": "sha512-AIcMP77AvirGbRl/UZFTq5hjXK+2wC7qFRGoHSDrZ5v5b8DK/GYpXW3CPRL53NkvDqb9D+alBiC/dV0Fb7eJcw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.27.3.tgz",
      "integrity": "sha512-DnW2sRrBzA+YnE70LKqnM3P+z8vehfJWHXECbwBmH/CU51z6FiqTQTHFenPlHmo3a8UgpLyH3PT+87OViOh1AQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openharmony-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/openharmony-arm64/-/openharmony-arm64-0.27.3.tgz",
      "integrity": "sha512-NinAEgr/etERPTsZJ7aEZQvvg/A6IsZG/LgZy+81wON2huV7SrK3e63dU0XhyZP4RKGyTm7aOgmQk0bGp0fy2g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.27.3.tgz",
      "integrity": "sha512-PanZ+nEz+eWoBJ8/f8HKxTTD172SKwdXebZ0ndd953gt1HRBbhMsaNqjTyYLGLPdoWHy4zLU7bDVJztF5f3BHA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.27.3.tgz",
      "integrity": "sha512-B2t59lWWYrbRDw/tjiWOuzSsFh1Y/E95ofKz7rIVYSQkUYBjfSgf6oeYPNWHToFRr2zx52JKApIcAS/D5TUBnA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.27.3.tgz",
      "integrity": "sha512-QLKSFeXNS8+tHW7tZpMtjlNb7HKau0QDpwm49u0vUp9y1WOF+PEzkU84y9GqYaAVW8aH8f3GcBck26jh54cX4Q==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.27.3.tgz",
      "integrity": "sha512-4uJGhsxuptu3OcpVAzli+/gWusVGwZZHTlS63hh++ehExkVT8SgiEf7/uC/PclrPPkLhZqGgCTjd0VWLo6xMqA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@eslint-community/eslint-utils": {
      "version": "4.9.1",
      "resolved": "https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.9.1.tgz",
      "integrity": "sha512-phrYmNiYppR7znFEdqgfWHXR6NCkZEK7hwWDHZUjit/2/U0r6XvkDl0SYnoM51Hq7FhCGdLDT6zxCCOY1hexsQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "eslint-visitor-keys": "^3.4.3"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      },
      "peerDependencies": {
        "eslint": "^6.0.0 || ^7.0.0 || >=8.0.0"
      }
    },
    "node_modules/@eslint-community/eslint-utils/node_modules/eslint-visitor-keys": {
      "version": "3.4.3",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz",
      "integrity": "sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint-community/regexpp": {
      "version": "4.12.2",
      "resolved": "https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.12.2.tgz",
      "integrity": "sha512-EriSTlt5OC9/7SXkRSCAhfSxxoSUgBm33OH+IkwbdpgoqsSsUg7y3uh+IICI/Qg4BBWr3U2i39RpmycbxMq4ew==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^12.0.0 || ^14.0.0 || >=16.0.0"
      }
    },
    "node_modules/@eslint/config-array": {
      "version": "0.21.1",
      "resolved": "https://registry.npmjs.org/@eslint/config-array/-/config-array-0.21.1.tgz",
      "integrity": "sha512-aw1gNayWpdI/jSYVgzN5pL0cfzU02GT3NBpeT/DXbx1/1x7ZKxFPd9bwrzygx/qiwIQiJ1sw/zD8qY/kRvlGHA==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/object-schema": "^2.1.7",
        "debug": "^4.3.1",
        "minimatch": "^3.1.2"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/config-helpers": {
      "version": "0.4.2",
      "resolved": "https://registry.npmjs.org/@eslint/config-helpers/-/config-helpers-0.4.2.tgz",
      "integrity": "sha512-gBrxN88gOIf3R7ja5K9slwNayVcZgK6SOUORm2uBzTeIEfeVaIhOpCtTox3P6R7o2jLFwLFTLnC7kU/RGcYEgw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/core": "^0.17.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/core": {
      "version": "0.17.0",
      "resolved": "https://registry.npmjs.org/@eslint/core/-/core-0.17.0.tgz",
      "integrity": "sha512-yL/sLrpmtDaFEiUj1osRP4TI2MDz1AddJL+jZ7KSqvBuliN4xqYY54IfdN8qD8Toa6g1iloph1fxQNkjOxrrpQ==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@types/json-schema": "^7.0.15"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/eslintrc": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-3.3.3.tgz",
      "integrity": "sha512-Kr+LPIUVKz2qkx1HAMH8q1q6azbqBAsXJUxBl/ODDuVPX45Z9DfwB8tPjTi6nNZ8BuM3nbJxC5zCAg5elnBUTQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ajv": "^6.12.4",
        "debug": "^4.3.2",
        "espree": "^10.0.1",
        "globals": "^14.0.0",
        "ignore": "^5.2.0",
        "import-fresh": "^3.2.1",
        "js-yaml": "^4.1.1",
        "minimatch": "^3.1.2",
        "strip-json-comments": "^3.1.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint/js": {
      "version": "9.39.2",
      "resolved": "https://registry.npmjs.org/@eslint/js/-/js-9.39.2.tgz",
      "integrity": "sha512-q1mjIoW1VX4IvSocvM/vbTiveKC4k9eLrajNEuSsmjymSDEbpGddtpfOoN7YGAqBK3NG+uqo8ia4PDTt8buCYA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://eslint.org/donate"
      }
    },
    "node_modules/@eslint/object-schema": {
      "version": "2.1.7",
      "resolved": "https://registry.npmjs.org/@eslint/object-schema/-/object-schema-2.1.7.tgz",
      "integrity": "sha512-VtAOaymWVfZcmZbp6E2mympDIHvyjXs/12LqWYjVw6qjrfF+VK+fyG33kChz3nnK+SU5/NeHOqrTEHS8sXO3OA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/plugin-kit": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/@eslint/plugin-kit/-/plugin-kit-0.4.1.tgz",
      "integrity": "sha512-43/qtrDUokr7LJqoF2c3+RInu/t4zfrpYdoSDfYyhg52rwLV6TnOvdG4fXm7IkSB3wErkcmJS9iEhjVtOSEjjA==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/core": "^0.17.0",
        "levn": "^0.4.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@hookform/resolvers": {
      "version": "5.2.2",
      "resolved": "https://registry.npmjs.org/@hookform/resolvers/-/resolvers-5.2.2.tgz",
      "integrity": "sha512-A/IxlMLShx3KjV/HeTcTfaMxdwy690+L/ZADoeaTltLx+CVuzkeVIPuybK3jrRfw7YZnmdKsVVHAlEPIAEUNlA==",
      "license": "MIT",
      "dependencies": {
        "@standard-schema/utils": "^0.3.0"
      },
      "peerDependencies": {
        "react-hook-form": "^7.55.0"
      }
    },
    "node_modules/@humanfs/core": {
      "version": "0.19.1",
      "resolved": "https://registry.npmjs.org/@humanfs/core/-/core-0.19.1.tgz",
      "integrity": "sha512-5DyQ4+1JEUzejeK1JGICcideyfUbGixgS9jNgex5nqkW+cY7WZhxBigmieN5Qnw9ZosSNVC9KQKyb+GUaGyKUA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanfs/node": {
      "version": "0.16.7",
      "resolved": "https://registry.npmjs.org/@humanfs/node/-/node-0.16.7.tgz",
      "integrity": "sha512-/zUx+yOsIrG4Y43Eh2peDeKCxlRt/gET6aHfaKpuq267qXdYDFViVHfMaLyygZOnl0kGWxFIgsBy8QFuTLUXEQ==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@humanfs/core": "^0.19.1",
        "@humanwhocodes/retry": "^0.4.0"
      },
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanwhocodes/module-importer": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz",
      "integrity": "sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=12.22"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@humanwhocodes/retry": {
      "version": "0.4.3",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/retry/-/retry-0.4.3.tgz",
      "integrity": "sha512-bV0Tgo9K4hfPCek+aMAn81RppFKv2ySDQeMoSZuvTASywNTnVJCArCZE2FWqpvIatKu7VMRLWlR1EazvVhDyhQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@img/colour": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/@img/colour/-/colour-1.0.0.tgz",
      "integrity": "sha512-A5P/LfWGFSl6nsckYtjw9da+19jB8hkJ6ACTGcDfEJ0aE+l2n2El7dsVM7UVHZQ9s2lmYMWlrS21YLy2IR1LUw==",
      "license": "MIT",
      "optional": true,
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@img/sharp-darwin-arm64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-darwin-arm64/-/sharp-darwin-arm64-0.34.5.tgz",
      "integrity": "sha512-imtQ3WMJXbMY4fxb/Ndp6HBTNVtWCUI0WdobyheGf5+ad6xX8VIDO8u2xE4qc/fr08CKG/7dDseFtn6M6g/r3w==",
      "cpu": [
        "arm64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-darwin-arm64": "1.2.4"
      }
    },
    "node_modules/@img/sharp-darwin-x64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-darwin-x64/-/sharp-darwin-x64-0.34.5.tgz",
      "integrity": "sha512-YNEFAF/4KQ/PeW0N+r+aVVsoIY0/qxxikF2SWdp+NRkmMB7y9LBZAVqQ4yhGCm/H3H270OSykqmQMKLBhBJDEw==",
      "cpu": [
        "x64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-darwin-x64": "1.2.4"
      }
    },
    "node_modules/@img/sharp-libvips-darwin-arm64": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-darwin-arm64/-/sharp-libvips-darwin-arm64-1.2.4.tgz",
      "integrity": "sha512-zqjjo7RatFfFoP0MkQ51jfuFZBnVE2pRiaydKJ1G/rHZvnsrHAOcQALIi9sA5co5xenQdTugCvtb1cuf78Vf4g==",
      "cpu": [
        "arm64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "darwin"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-darwin-x64": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-darwin-x64/-/sharp-libvips-darwin-x64-1.2.4.tgz",
      "integrity": "sha512-1IOd5xfVhlGwX+zXv2N93k0yMONvUlANylbJw1eTah8K/Jtpi15KC+WSiaX/nBmbm2HxRM1gZ0nSdjSsrZbGKg==",
      "cpu": [
        "x64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "darwin"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-arm": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-arm/-/sharp-libvips-linux-arm-1.2.4.tgz",
      "integrity": "sha512-bFI7xcKFELdiNCVov8e44Ia4u2byA+l3XtsAj+Q8tfCwO6BQ8iDojYdvoPMqsKDkuoOo+X6HZA0s0q11ANMQ8A==",
      "cpu": [
        "arm"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-arm64": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-arm64/-/sharp-libvips-linux-arm64-1.2.4.tgz",
      "integrity": "sha512-excjX8DfsIcJ10x1Kzr4RcWe1edC9PquDRRPx3YVCvQv+U5p7Yin2s32ftzikXojb1PIFc/9Mt28/y+iRklkrw==",
      "cpu": [
        "arm64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-ppc64": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-ppc64/-/sharp-libvips-linux-ppc64-1.2.4.tgz",
      "integrity": "sha512-FMuvGijLDYG6lW+b/UvyilUWu5Ayu+3r2d1S8notiGCIyYU/76eig1UfMmkZ7vwgOrzKzlQbFSuQfgm7GYUPpA==",
      "cpu": [
        "ppc64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-riscv64": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-riscv64/-/sharp-libvips-linux-riscv64-1.2.4.tgz",
      "integrity": "sha512-oVDbcR4zUC0ce82teubSm+x6ETixtKZBh/qbREIOcI3cULzDyb18Sr/Wcyx7NRQeQzOiHTNbZFF1UwPS2scyGA==",
      "cpu": [
        "riscv64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-s390x": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-s390x/-/sharp-libvips-linux-s390x-1.2.4.tgz",
      "integrity": "sha512-qmp9VrzgPgMoGZyPvrQHqk02uyjA0/QrTO26Tqk6l4ZV0MPWIW6LTkqOIov+J1yEu7MbFQaDpwdwJKhbJvuRxQ==",
      "cpu": [
        "s390x"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-x64": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-x64/-/sharp-libvips-linux-x64-1.2.4.tgz",
      "integrity": "sha512-tJxiiLsmHc9Ax1bz3oaOYBURTXGIRDODBqhveVHonrHJ9/+k89qbLl0bcJns+e4t4rvaNBxaEZsFtSfAdquPrw==",
      "cpu": [
        "x64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linuxmusl-arm64": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linuxmusl-arm64/-/sharp-libvips-linuxmusl-arm64-1.2.4.tgz",
      "integrity": "sha512-FVQHuwx1IIuNow9QAbYUzJ+En8KcVm9Lk5+uGUQJHaZmMECZmOlix9HnH7n1TRkXMS0pGxIJokIVB9SuqZGGXw==",
      "cpu": [
        "arm64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linuxmusl-x64": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linuxmusl-x64/-/sharp-libvips-linuxmusl-x64-1.2.4.tgz",
      "integrity": "sha512-+LpyBk7L44ZIXwz/VYfglaX/okxezESc6UxDSoyo2Ks6Jxc4Y7sGjpgU9s4PMgqgjj1gZCylTieNamqA1MF7Dg==",
      "cpu": [
        "x64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-linux-arm": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-arm/-/sharp-linux-arm-0.34.5.tgz",
      "integrity": "sha512-9dLqsvwtg1uuXBGZKsxem9595+ujv0sJ6Vi8wcTANSFpwV/GONat5eCkzQo/1O6zRIkh0m/8+5BjrRr7jDUSZw==",
      "cpu": [
        "arm"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-arm": "1.2.4"
      }
    },
    "node_modules/@img/sharp-linux-arm64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-arm64/-/sharp-linux-arm64-0.34.5.tgz",
      "integrity": "sha512-bKQzaJRY/bkPOXyKx5EVup7qkaojECG6NLYswgktOZjaXecSAeCWiZwwiFf3/Y+O1HrauiE3FVsGxFg8c24rZg==",
      "cpu": [
        "arm64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-arm64": "1.2.4"
      }
    },
    "node_modules/@img/sharp-linux-ppc64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-ppc64/-/sharp-linux-ppc64-0.34.5.tgz",
      "integrity": "sha512-7zznwNaqW6YtsfrGGDA6BRkISKAAE1Jo0QdpNYXNMHu2+0dTrPflTLNkpc8l7MUP5M16ZJcUvysVWWrMefZquA==",
      "cpu": [
        "ppc64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-ppc64": "1.2.4"
      }
    },
    "node_modules/@img/sharp-linux-riscv64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-riscv64/-/sharp-linux-riscv64-0.34.5.tgz",
      "integrity": "sha512-51gJuLPTKa7piYPaVs8GmByo7/U7/7TZOq+cnXJIHZKavIRHAP77e3N2HEl3dgiqdD/w0yUfiJnII77PuDDFdw==",
      "cpu": [
        "riscv64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-riscv64": "1.2.4"
      }
    },
    "node_modules/@img/sharp-linux-s390x": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-s390x/-/sharp-linux-s390x-0.34.5.tgz",
      "integrity": "sha512-nQtCk0PdKfho3eC5MrbQoigJ2gd1CgddUMkabUj+rBevs8tZ2cULOx46E7oyX+04WGfABgIwmMC0VqieTiR4jg==",
      "cpu": [
        "s390x"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-s390x": "1.2.4"
      }
    },
    "node_modules/@img/sharp-linux-x64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-x64/-/sharp-linux-x64-0.34.5.tgz",
      "integrity": "sha512-MEzd8HPKxVxVenwAa+JRPwEC7QFjoPWuS5NZnBt6B3pu7EG2Ge0id1oLHZpPJdn3OQK+BQDiw9zStiHBTJQQQQ==",
      "cpu": [
        "x64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-x64": "1.2.4"
      }
    },
    "node_modules/@img/sharp-linuxmusl-arm64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-linuxmusl-arm64/-/sharp-linuxmusl-arm64-0.34.5.tgz",
      "integrity": "sha512-fprJR6GtRsMt6Kyfq44IsChVZeGN97gTD331weR1ex1c1rypDEABN6Tm2xa1wE6lYb5DdEnk03NZPqA7Id21yg==",
      "cpu": [
        "arm64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linuxmusl-arm64": "1.2.4"
      }
    },
    "node_modules/@img/sharp-linuxmusl-x64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-linuxmusl-x64/-/sharp-linuxmusl-x64-0.34.5.tgz",
      "integrity": "sha512-Jg8wNT1MUzIvhBFxViqrEhWDGzqymo3sV7z7ZsaWbZNDLXRJZoRGrjulp60YYtV4wfY8VIKcWidjojlLcWrd8Q==",
      "cpu": [
        "x64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linuxmusl-x64": "1.2.4"
      }
    },
    "node_modules/@img/sharp-wasm32": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-wasm32/-/sharp-wasm32-0.34.5.tgz",
      "integrity": "sha512-OdWTEiVkY2PHwqkbBI8frFxQQFekHaSSkUIJkwzclWZe64O1X4UlUjqqqLaPbUpMOQk6FBu/HtlGXNblIs0huw==",
      "cpu": [
        "wasm32"
      ],
      "license": "Apache-2.0 AND LGPL-3.0-or-later AND MIT",
      "optional": true,
      "dependencies": {
        "@emnapi/runtime": "^1.7.0"
      },
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-win32-arm64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-win32-arm64/-/sharp-win32-arm64-0.34.5.tgz",
      "integrity": "sha512-WQ3AgWCWYSb2yt+IG8mnC6Jdk9Whs7O0gxphblsLvdhSpSTtmu69ZG1Gkb6NuvxsNACwiPV6cNSZNzt0KPsw7g==",
      "cpu": [
        "arm64"
      ],
      "license": "Apache-2.0 AND LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-win32-ia32": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-win32-ia32/-/sharp-win32-ia32-0.34.5.tgz",
      "integrity": "sha512-FV9m/7NmeCmSHDD5j4+4pNI8Cp3aW+JvLoXcTUo0IqyjSfAZJ8dIUmijx1qaJsIiU+Hosw6xM5KijAWRJCSgNg==",
      "cpu": [
        "ia32"
      ],
      "license": "Apache-2.0 AND LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-win32-x64": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/@img/sharp-win32-x64/-/sharp-win32-x64-0.34.5.tgz",
      "integrity": "sha512-+29YMsqY2/9eFEiW93eqWnuLcWcufowXewwSNIT6UwZdUUCrM3oFjMWH/Z6/TMmb4hlFenmfAVbpWeup2jryCw==",
      "cpu": [
        "x64"
      ],
      "license": "Apache-2.0 AND LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.13",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.0",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/remapping": {
      "version": "2.3.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/remapping/-/remapping-2.3.5.tgz",
      "integrity": "sha512-LI9u/+laYG4Ds1TDKSJW2YPrIlcVYOwi2fUC6xB43lueCjgxV4lffOCZCtYFiH6TNOX+tQKXx97T4IKHbhyHEQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.31",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/@napi-rs/wasm-runtime": {
      "version": "0.2.12",
      "resolved": "https://registry.npmjs.org/@napi-rs/wasm-runtime/-/wasm-runtime-0.2.12.tgz",
      "integrity": "sha512-ZVWUcfwY4E/yPitQJl481FjFo3K22D6qF0DuFH6Y/nbnE11GY5uguDxZMGXPQ8WQ0128MXQD7TnfHyK4oWoIJQ==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "@emnapi/core": "^1.4.3",
        "@emnapi/runtime": "^1.4.3",
        "@tybys/wasm-util": "^0.10.0"
      }
    },
    "node_modules/@next/env": {
      "version": "16.1.6",
      "resolved": "https://registry.npmjs.org/@next/env/-/env-16.1.6.tgz",
      "integrity": "sha512-N1ySLuZjnAtN3kFnwhAwPvZah8RJxKasD7x1f8shFqhncnWZn4JMfg37diLNuoHsLAlrDfM3g4mawVdtAG8XLQ==",
      "license": "MIT"
    },
    "node_modules/@next/eslint-plugin-next": {
      "version": "16.1.6",
      "resolved": "https://registry.npmjs.org/@next/eslint-plugin-next/-/eslint-plugin-next-16.1.6.tgz",
      "integrity": "sha512-/Qq3PTagA6+nYVfryAtQ7/9FEr/6YVyvOtl6rZnGsbReGLf0jZU6gkpr1FuChAQpvV46a78p4cmHOVP8mbfSMQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fast-glob": "3.3.1"
      }
    },
    "node_modules/@next/swc-darwin-arm64": {
      "version": "16.1.6",
      "resolved": "https://registry.npmjs.org/@next/swc-darwin-arm64/-/swc-darwin-arm64-16.1.6.tgz",
      "integrity": "sha512-wTzYulosJr/6nFnqGW7FrG3jfUUlEf8UjGA0/pyypJl42ExdVgC6xJgcXQ+V8QFn6niSG2Pb8+MIG1mZr2vczw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-darwin-x64": {
      "version": "16.1.6",
      "resolved": "https://registry.npmjs.org/@next/swc-darwin-x64/-/swc-darwin-x64-16.1.6.tgz",
      "integrity": "sha512-BLFPYPDO+MNJsiDWbeVzqvYd4NyuRrEYVB5k2N3JfWncuHAy2IVwMAOlVQDFjj+krkWzhY2apvmekMkfQR0CUQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-linux-arm64-gnu": {
      "version": "16.1.6",
      "resolved": "https://registry.npmjs.org/@next/swc-linux-arm64-gnu/-/swc-linux-arm64-gnu-16.1.6.tgz",
      "integrity": "sha512-OJYkCd5pj/QloBvoEcJ2XiMnlJkRv9idWA/j0ugSuA34gMT6f5b7vOiCQHVRpvStoZUknhl6/UxOXL4OwtdaBw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-linux-arm64-musl": {
      "version": "16.1.6",
      "resolved": "https://registry.npmjs.org/@next/swc-linux-arm64-musl/-/swc-linux-arm64-musl-16.1.6.tgz",
      "integrity": "sha512-S4J2v+8tT3NIO9u2q+S0G5KdvNDjXfAv06OhfOzNDaBn5rw84DGXWndOEB7d5/x852A20sW1M56vhC/tRVbccQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-linux-x64-gnu": {
      "version": "16.1.6",
      "resolved": "https://registry.npmjs.org/@next/swc-linux-x64-gnu/-/swc-linux-x64-gnu-16.1.6.tgz",
      "integrity": "sha512-2eEBDkFlMMNQnkTyPBhQOAyn2qMxyG2eE7GPH2WIDGEpEILcBPI/jdSv4t6xupSP+ot/jkfrCShLAa7+ZUPcJQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-linux-x64-musl": {
      "version": "16.1.6",
      "resolved": "https://registry.npmjs.org/@next/swc-linux-x64-musl/-/swc-linux-x64-musl-16.1.6.tgz",
      "integrity": "sha512-oicJwRlyOoZXVlxmIMaTq7f8pN9QNbdes0q2FXfRsPhfCi8n8JmOZJm5oo1pwDaFbnnD421rVU409M3evFbIqg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-win32-arm64-msvc": {
      "version": "16.1.6",
      "resolved": "https://registry.npmjs.org/@next/swc-win32-arm64-msvc/-/swc-win32-arm64-msvc-16.1.6.tgz",
      "integrity": "sha512-gQmm8izDTPgs+DCWH22kcDmuUp7NyiJgEl18bcr8irXA5N2m2O+JQIr6f3ct42GOs9c0h8QF3L5SzIxcYAAXXw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-win32-x64-msvc": {
      "version": "16.1.6",
      "resolved": "https://registry.npmjs.org/@next/swc-win32-x64-msvc/-/swc-win32-x64-msvc-16.1.6.tgz",
      "integrity": "sha512-NRfO39AIrzBnixKbjuo2YiYhB6o9d8v/ymU9m/Xk8cyVk+k7XylniXkHwjs4s70wedVffc6bQNbufk5v0xEm0A==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@node-rs/argon2": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/@node-rs/argon2/-/argon2-2.0.2.tgz",
      "integrity": "sha512-t64wIsPEtNd4aUPuTAyeL2ubxATCBGmeluaKXEMAFk/8w6AJIVVkeLKMBpgLW6LU2t5cQxT+env/c6jxbtTQBg==",
      "license": "MIT",
      "engines": {
        "node": ">= 10"
      },
      "optionalDependencies": {
        "@node-rs/argon2-android-arm-eabi": "2.0.2",
        "@node-rs/argon2-android-arm64": "2.0.2",
        "@node-rs/argon2-darwin-arm64": "2.0.2",
        "@node-rs/argon2-darwin-x64": "2.0.2",
        "@node-rs/argon2-freebsd-x64": "2.0.2",
        "@node-rs/argon2-linux-arm-gnueabihf": "2.0.2",
        "@node-rs/argon2-linux-arm64-gnu": "2.0.2",
        "@node-rs/argon2-linux-arm64-musl": "2.0.2",
        "@node-rs/argon2-linux-x64-gnu": "2.0.2",
        "@node-rs/argon2-linux-x64-musl": "2.0.2",
        "@node-rs/argon2-wasm32-wasi": "2.0.2",
        "@node-rs/argon2-win32-arm64-msvc": "2.0.2",
        "@node-rs/argon2-win32-ia32-msvc": "2.0.2",
        "@node-rs/argon2-win32-x64-msvc": "2.0.2"
      }
    },
    "node_modules/@node-rs/argon2-android-arm-eabi": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/@node-rs/argon2-android-arm-eabi/-/argon2-android-arm-eabi-2.0.2.tgz",
      "integrity": "sha512-DV/H8p/jt40lrao5z5g6nM9dPNPGEHL+aK6Iy/og+dbL503Uj0AHLqj1Hk9aVUSCNnsDdUEKp4TVMi0YakDYKw==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@node-rs/argon2-android-arm64": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/@node-rs/argon2-android-arm64/-/argon2-android-arm64-2.0.2.tgz",
      "integrity": "sha512-1LKwskau+8O1ktKx7TbK7jx1oMOMt4YEXZOdSNIar1TQKxm6isZ0cRXgHLibPHEcNHgYRsJWDE9zvDGBB17QDg==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@node-rs/argon2-darwin-arm64": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/@node-rs/argon2-darwin-arm64/-/argon2-darwin-arm64-2.0.2.tgz",
      "integrity": "sha512-3TTNL/7wbcpNju5YcqUrCgXnXUSbD7ogeAKatzBVHsbpjZQbNb1NDxDjqqrWoTt6XL3z9mJUMGwbAk7zQltHtA==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@node-rs/argon2-darwin-x64": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/@node-rs/argon2-darwin-x64/-/argon2-darwin-x64-2.0.2.tgz",
      "integrity": "sha512-vNPfkLj5Ij5111UTiYuwgxMqE7DRbOS2y58O2DIySzSHbcnu+nipmRKg+P0doRq6eKIJStyBK8dQi5Ic8pFyDw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@node-rs/argon2-freebsd-x64": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/@node-rs/argon2-freebsd-x64/-/argon2-freebsd-x64-2.0.2.tgz",
      "integrity": "sha512-M8vQZk01qojQfCqQU0/O1j1a4zPPrz93zc9fSINY7Q/6RhQRBCYwDw7ltDCZXg5JRGlSaeS8cUXWyhPGar3cGg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@node-rs/argon2-linux-arm-gnueabihf": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/@node-rs/argon2-linux-arm-gnueabihf/-/argon2-linux-arm-gnueabihf-2.0.2.tgz",
      "integrity": "sha512-7EmmEPHLzcu0G2GDh30L6G48CH38roFC2dqlQJmtRCxs6no3tTE/pvgBGatTp/o2n2oyOJcfmgndVFcUpwMnww==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@node-rs/argon2-linux-arm64-gnu": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/@node-rs/argon2-linux-arm64-gnu/-/argon2-linux-arm64-gnu-2.0.2.tgz",
      "integrity": "sha512-6lsYh3Ftbk+HAIZ7wNuRF4SZDtxtFTfK+HYFAQQyW7Ig3LHqasqwfUKRXVSV5tJ+xTnxjqgKzvZSUJCAyIfHew==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@node-rs/argon2-linux-arm64-musl": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/@node-rs/argon2-linux-arm64-musl/-/argon2-linux-arm64-musl-2.0.2.tgz",
      "integrity": "sha512-p3YqVMNT/4DNR67tIHTYGbedYmXxW9QlFmF39SkXyEbGQwpgSf6pH457/fyXBIYznTU/smnG9EH+C1uzT5j4hA==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@node-rs/argon2-linux-x64-gnu": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/@node-rs/argon2-linux-x64-gnu/-/argon2-linux-x64-gnu-2.0.2.tgz",
      "integrity": "sha512-ZM3jrHuJ0dKOhvA80gKJqBpBRmTJTFSo2+xVZR+phQcbAKRlDMSZMFDiKbSTnctkfwNFtjgDdh5g1vaEV04AvA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@node-rs/argon2-linux-x64-musl": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/@node-rs/argon2-linux-x64-musl/-/argon2-linux-x64-musl-2.0.2.tgz",
      "integrity": "sha512-of5uPqk7oCRF/44a89YlWTEfjsftPywyTULwuFDKyD8QtVZoonrJR6ZWvfFE/6jBT68S0okAkAzzMEdBVWdxWw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@node-rs/argon2-wasm32-wasi": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/@node-rs/argon2-wasm32-wasi/-/argon2-wasm32-wasi-2.0.2.tgz",
      "integrity": "sha512-U3PzLYKSQYzTERstgtHLd4ZTkOF9co57zTXT77r0cVUsleGZOrd6ut7rHzeWwoJSiHOVxxa0OhG1JVQeB7lLoQ==",
      "cpu": [
        "wasm32"
      ],
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "@napi-rs/wasm-runtime": "^0.2.5"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@node-rs/argon2-win32-arm64-msvc": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/@node-rs/argon2-win32-arm64-msvc/-/argon2-win32-arm64-msvc-2.0.2.tgz",
      "integrity": "sha512-Eisd7/NM0m23ijrGr6xI2iMocdOuyl6gO27gfMfya4C5BODbUSP7ljKJ7LrA0teqZMdYHesRDzx36Js++/vhiQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@node-rs/argon2-win32-ia32-msvc": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/@node-rs/argon2-win32-ia32-msvc/-/argon2-win32-ia32-msvc-2.0.2.tgz",
      "integrity": "sha512-GsE2ezwAYwh72f9gIjbGTZOf4HxEksb5M2eCaj+Y5rGYVwAdt7C12Q2e9H5LRYxWcFvLH4m4jiSZpQQ4upnPAQ==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@node-rs/argon2-win32-x64-msvc": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/@node-rs/argon2-win32-x64-msvc/-/argon2-win32-x64-msvc-2.0.2.tgz",
      "integrity": "sha512-cJxWXanH4Ew9CfuZ4IAEiafpOBCe97bzoKowHCGk5lG/7kR4WF/eknnBlHW9m8q7t10mKq75kruPLtbSDqgRTw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@nodelib/fs.scandir": {
      "version": "2.1.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
      "integrity": "sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "2.0.5",
        "run-parallel": "^1.1.9"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.stat": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz",
      "integrity": "sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.walk": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz",
      "integrity": "sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.scandir": "2.1.5",
        "fastq": "^1.6.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nolyfill/is-core-module": {
      "version": "1.0.39",
      "resolved": "https://registry.npmjs.org/@nolyfill/is-core-module/-/is-core-module-1.0.39.tgz",
      "integrity": "sha512-nn5ozdjYQpUCZlWGuxcJY/KpxkWQs4DcbMCmKojjyrYDEAGy4Ce19NN4v5MduafTwJlbKc99UA8YhSVqq9yPZA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12.4.0"
      }
    },
    "node_modules/@pinojs/redact": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/@pinojs/redact/-/redact-0.4.0.tgz",
      "integrity": "sha512-k2ENnmBugE/rzQfEcdWHcCY+/FM3VLzH9cYEsbdsoqrvzAKRhUZeRNhAZvB8OitQJ1TBed3yqWtdjzS6wJKBwg==",
      "license": "MIT"
    },
    "node_modules/@playwright/test": {
      "version": "1.58.2",
      "resolved": "https://registry.npmjs.org/@playwright/test/-/test-1.58.2.tgz",
      "integrity": "sha512-akea+6bHYBBfA9uQqSYmlJXn61cTa+jbO87xVLCWbTqbWadRVmhxlXATaOjOgcBaWU4ePo0wB41KMFv3o35IXA==",
      "devOptional": true,
      "license": "Apache-2.0",
      "peer": true,
      "dependencies": {
        "playwright": "1.58.2"
      },
      "bin": {
        "playwright": "cli.js"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
      "integrity": "sha512-A6ehUVSiSaaliTxai040ZpZ2zTevHYbvu/lDoeAteHI8QnaosIzm4qwtezfRg1jOYaUmnzLX1AOD6Z+UJjtifg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-android-arm64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.57.1.tgz",
      "integrity": "sha512-dQaAddCY9YgkFHZcFNS/606Exo8vcLHwArFZ7vxXq4rigo2bb494/xKMMwRRQW6ug7Js6yXmBZhSBRuBvCCQ3w==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.57.1.tgz",
      "integrity": "sha512-crNPrwJOrRxagUYeMn/DZwqN88SDmwaJ8Cvi/TN1HnWBU7GwknckyosC2gd0IqYRsHDEnXf328o9/HC6OkPgOg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.57.1.tgz",
      "integrity": "sha512-Ji8g8ChVbKrhFtig5QBV7iMaJrGtpHelkB3lsaKzadFBe58gmjfGXAOfI5FV0lYMH8wiqsxKQ1C9B0YTRXVy4w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.57.1.tgz",
      "integrity": "sha512-R+/WwhsjmwodAcz65guCGFRkMb4gKWTcIeLy60JJQbXrJ97BOXHxnkPFrP+YwFlaS0m+uWJTstrUA9o+UchFug==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.57.1.tgz",
      "integrity": "sha512-IEQTCHeiTOnAUC3IDQdzRAGj3jOAYNr9kBguI7MQAAZK3caezRrg0GxAb6Hchg4lxdZEI5Oq3iov/w/hnFWY9Q==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.57.1.tgz",
      "integrity": "sha512-F8sWbhZ7tyuEfsmOxwc2giKDQzN3+kuBLPwwZGyVkLlKGdV1nvnNwYD0fKQ8+XS6hp9nY7B+ZeK01EBUE7aHaw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.57.1.tgz",
      "integrity": "sha512-rGfNUfn0GIeXtBP1wL5MnzSj98+PZe/AXaGBCRmT0ts80lU5CATYGxXukeTX39XBKsxzFpEeK+Mrp9faXOlmrw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.57.1.tgz",
      "integrity": "sha512-MMtej3YHWeg/0klK2Qodf3yrNzz6CGjo2UntLvk2RSPlhzgLvYEB3frRvbEF2wRKh1Z2fDIg9KRPe1fawv7C+g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.57.1.tgz",
      "integrity": "sha512-1a/qhaaOXhqXGpMFMET9VqwZakkljWHLmZOX48R0I/YLbhdxr1m4gtG1Hq7++VhVUmf+L3sTAf9op4JlhQ5u1Q==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-gnu/-/rollup-linux-loong64-gnu-4.57.1.tgz",
      "integrity": "sha512-QWO6RQTZ/cqYtJMtxhkRkidoNGXc7ERPbZN7dVW5SdURuLeVU7lwKMpo18XdcmpWYd0qsP1bwKPf7DNSUinhvA==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-musl/-/rollup-linux-loong64-musl-4.57.1.tgz",
      "integrity": "sha512-xpObYIf+8gprgWaPP32xiN5RVTi/s5FCR+XMXSKmhfoJjrpRAjCuuqQXyxUa/eJTdAE6eJ+KDKaoEqjZQxh3Gw==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.57.1.tgz",
      "integrity": "sha512-4BrCgrpZo4hvzMDKRqEaW1zeecScDCR+2nZ86ATLhAoJ5FQ+lbHVD3ttKe74/c7tNT9c6F2viwB3ufwp01Oh2w==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-musl/-/rollup-linux-ppc64-musl-4.57.1.tgz",
      "integrity": "sha512-NOlUuzesGauESAyEYFSe3QTUguL+lvrN1HtwEEsU2rOwdUDeTMJdO5dUYl/2hKf9jWydJrO9OL/XSSf65R5+Xw==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.57.1.tgz",
      "integrity": "sha512-ptA88htVp0AwUUqhVghwDIKlvJMD/fmL/wrQj99PRHFRAG6Z5nbWoWG4o81Nt9FT+IuqUQi+L31ZKAFeJ5Is+A==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.57.1.tgz",
      "integrity": "sha512-S51t7aMMTNdmAMPpBg7OOsTdn4tySRQvklmL3RpDRyknk87+Sp3xaumlatU+ppQ+5raY7sSTcC2beGgvhENfuw==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.57.1.tgz",
      "integrity": "sha512-Bl00OFnVFkL82FHbEqy3k5CUCKH6OEJL54KCyx2oqsmZnFTR8IoNqBF+mjQVcRCT5sB6yOvK8A37LNm/kPJiZg==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.57.1.tgz",
      "integrity": "sha512-ABca4ceT4N+Tv/GtotnWAeXZUZuM/9AQyCyKYyKnpk4yoA7QIAuBt6Hkgpw8kActYlew2mvckXkvx0FfoInnLg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.57.1.tgz",
      "integrity": "sha512-HFps0JeGtuOR2convgRRkHCekD7j+gdAuXM+/i6kGzQtFhlCtQkpwtNzkNj6QhCDp7DRJ7+qC/1Vg2jt5iSOFw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-openbsd-x64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openbsd-x64/-/rollup-openbsd-x64-4.57.1.tgz",
      "integrity": "sha512-H+hXEv9gdVQuDTgnqD+SQffoWoc0Of59AStSzTEj/feWTBAnSfSD3+Dql1ZruJQxmykT/JVY0dE8Ka7z0DH1hw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ]
    },
    "node_modules/@rollup/rollup-openharmony-arm64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openharmony-arm64/-/rollup-openharmony-arm64-4.57.1.tgz",
      "integrity": "sha512-4wYoDpNg6o/oPximyc/NG+mYUejZrCU2q+2w6YZqrAs2UcNUChIZXjtafAiiZSUc7On8v5NyNj34Kzj/Ltk6dQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ]
    },
    "node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.57.1.tgz",
      "integrity": "sha512-O54mtsV/6LW3P8qdTcamQmuC990HDfR71lo44oZMZlXU4tzLrbvTii87Ni9opq60ds0YzuAlEr/GNwuNluZyMQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.57.1.tgz",
      "integrity": "sha512-P3dLS+IerxCT/7D2q2FYcRdWRl22dNbrbBEtxdWhXrfIMPP9lQhb5h4Du04mdl5Woq05jVCDPCMF7Ub0NAjIew==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-gnu/-/rollup-win32-x64-gnu-4.57.1.tgz",
      "integrity": "sha512-VMBH2eOOaKGtIJYleXsi2B8CPVADrh+TyNxJ4mWPnKfLB/DBUmzW+5m1xUrcwWoMfSLagIRpjUFeW5CO5hyciQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.57.1.tgz",
      "integrity": "sha512-mxRFDdHIWRxg3UfIIAwCm6NzvxG0jDX/wBN6KsQFTvKFqqg9vTrWUE68qEjHt19A5wwx5X5aUi2zuZT7YR0jrA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rtsao/scc": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@rtsao/scc/-/scc-1.1.0.tgz",
      "integrity": "sha512-zt6OdqaDoOnJ1ZYsCYGt9YmWzDXl4vQdKTyJev62gFhRGKdx7mcT54V9KIjg+d2wi9EXsPvAPKe7i7WjfVWB8g==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@standard-schema/spec": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@standard-schema/spec/-/spec-1.1.0.tgz",
      "integrity": "sha512-l2aFy5jALhniG5HgqrD6jXLi/rUWrKvqN/qJx6yoJsgKhblVd+iqqU4RCXavm/jPityDo5TCvKMnpjKnOriy0w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@standard-schema/utils": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/@standard-schema/utils/-/utils-0.3.0.tgz",
      "integrity": "sha512-e7Mew686owMaPJVNNLs55PUvgz371nKgwsc4vxE49zsODpJEnxgxRo2y/OKrqueavXgZNMDVj3DdHFlaSAeU8g==",
      "license": "MIT"
    },
    "node_modules/@swc/helpers": {
      "version": "0.5.15",
      "resolved": "https://registry.npmjs.org/@swc/helpers/-/helpers-0.5.15.tgz",
      "integrity": "sha512-JQ5TuMi45Owi4/BIMAJBoSQoOJu12oOk/gADqlcUL9JEdHB8vyjUSsxqeNXnmXHjYKMi2WcYtezGEEhqUI/E2g==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.8.0"
      }
    },
    "node_modules/@tailwindcss/node": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/node/-/node-4.1.18.tgz",
      "integrity": "sha512-DoR7U1P7iYhw16qJ49fgXUlry1t4CpXeErJHnQ44JgTSKMaZUdf17cfn5mHchfJ4KRBZRFA/Coo+MUF5+gOaCQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/remapping": "^2.3.4",
        "enhanced-resolve": "^5.18.3",
        "jiti": "^2.6.1",
        "lightningcss": "1.30.2",
        "magic-string": "^0.30.21",
        "source-map-js": "^1.2.1",
        "tailwindcss": "4.1.18"
      }
    },
    "node_modules/@tailwindcss/oxide": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide/-/oxide-4.1.18.tgz",
      "integrity": "sha512-EgCR5tTS5bUSKQgzeMClT6iCY3ToqE1y+ZB0AKldj809QXk1Y+3jB0upOYZrn9aGIzPtUsP7sX4QQ4XtjBB95A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 10"
      },
      "optionalDependencies": {
        "@tailwindcss/oxide-android-arm64": "4.1.18",
        "@tailwindcss/oxide-darwin-arm64": "4.1.18",
        "@tailwindcss/oxide-darwin-x64": "4.1.18",
        "@tailwindcss/oxide-freebsd-x64": "4.1.18",
        "@tailwindcss/oxide-linux-arm-gnueabihf": "4.1.18",
        "@tailwindcss/oxide-linux-arm64-gnu": "4.1.18",
        "@tailwindcss/oxide-linux-arm64-musl": "4.1.18",
        "@tailwindcss/oxide-linux-x64-gnu": "4.1.18",
        "@tailwindcss/oxide-linux-x64-musl": "4.1.18",
        "@tailwindcss/oxide-wasm32-wasi": "4.1.18",
        "@tailwindcss/oxide-win32-arm64-msvc": "4.1.18",
        "@tailwindcss/oxide-win32-x64-msvc": "4.1.18"
      }
    },
    "node_modules/@tailwindcss/oxide-android-arm64": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-android-arm64/-/oxide-android-arm64-4.1.18.tgz",
      "integrity": "sha512-dJHz7+Ugr9U/diKJA0W6N/6/cjI+ZTAoxPf9Iz9BFRF2GzEX8IvXxFIi/dZBloVJX/MZGvRuFA9rqwdiIEZQ0Q==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-darwin-arm64": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-darwin-arm64/-/oxide-darwin-arm64-4.1.18.tgz",
      "integrity": "sha512-Gc2q4Qhs660bhjyBSKgq6BYvwDz4G+BuyJ5H1xfhmDR3D8HnHCmT/BSkvSL0vQLy/nkMLY20PQ2OoYMO15Jd0A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-darwin-x64": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-darwin-x64/-/oxide-darwin-x64-4.1.18.tgz",
      "integrity": "sha512-FL5oxr2xQsFrc3X9o1fjHKBYBMD1QZNyc1Xzw/h5Qu4XnEBi3dZn96HcHm41c/euGV+GRiXFfh2hUCyKi/e+yw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-freebsd-x64": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-freebsd-x64/-/oxide-freebsd-x64-4.1.18.tgz",
      "integrity": "sha512-Fj+RHgu5bDodmV1dM9yAxlfJwkkWvLiRjbhuO2LEtwtlYlBgiAT4x/j5wQr1tC3SANAgD+0YcmWVrj8R9trVMA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-arm-gnueabihf": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-arm-gnueabihf/-/oxide-linux-arm-gnueabihf-4.1.18.tgz",
      "integrity": "sha512-Fp+Wzk/Ws4dZn+LV2Nqx3IilnhH51YZoRaYHQsVq3RQvEl+71VGKFpkfHrLM/Li+kt5c0DJe/bHXK1eHgDmdiA==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-arm64-gnu": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-arm64-gnu/-/oxide-linux-arm64-gnu-4.1.18.tgz",
      "integrity": "sha512-S0n3jboLysNbh55Vrt7pk9wgpyTTPD0fdQeh7wQfMqLPM/Hrxi+dVsLsPrycQjGKEQk85Kgbx+6+QnYNiHalnw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-arm64-musl": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-arm64-musl/-/oxide-linux-arm64-musl-4.1.18.tgz",
      "integrity": "sha512-1px92582HkPQlaaCkdRcio71p8bc8i/ap5807tPRDK/uw953cauQBT8c5tVGkOwrHMfc2Yh6UuxaH4vtTjGvHg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-x64-gnu": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-x64-gnu/-/oxide-linux-x64-gnu-4.1.18.tgz",
      "integrity": "sha512-v3gyT0ivkfBLoZGF9LyHmts0Isc8jHZyVcbzio6Wpzifg/+5ZJpDiRiUhDLkcr7f/r38SWNe7ucxmGW3j3Kb/g==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-x64-musl": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-x64-musl/-/oxide-linux-x64-musl-4.1.18.tgz",
      "integrity": "sha512-bhJ2y2OQNlcRwwgOAGMY0xTFStt4/wyU6pvI6LSuZpRgKQwxTec0/3Scu91O8ir7qCR3AuepQKLU/kX99FouqQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-wasm32-wasi": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-wasm32-wasi/-/oxide-wasm32-wasi-4.1.18.tgz",
      "integrity": "sha512-LffYTvPjODiP6PT16oNeUQJzNVyJl1cjIebq/rWWBF+3eDst5JGEFSc5cWxyRCJ0Mxl+KyIkqRxk1XPEs9x8TA==",
      "bundleDependencies": [
        "@napi-rs/wasm-runtime",
        "@emnapi/core",
        "@emnapi/runtime",
        "@tybys/wasm-util",
        "@emnapi/wasi-threads",
        "tslib"
      ],
      "cpu": [
        "wasm32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "@emnapi/core": "^1.7.1",
        "@emnapi/runtime": "^1.7.1",
        "@emnapi/wasi-threads": "^1.1.0",
        "@napi-rs/wasm-runtime": "^1.1.0",
        "@tybys/wasm-util": "^0.10.1",
        "tslib": "^2.4.0"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@tailwindcss/oxide-win32-arm64-msvc": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-win32-arm64-msvc/-/oxide-win32-arm64-msvc-4.1.18.tgz",
      "integrity": "sha512-HjSA7mr9HmC8fu6bdsZvZ+dhjyGCLdotjVOgLA2vEqxEBZaQo9YTX4kwgEvPCpRh8o4uWc4J/wEoFzhEmjvPbA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-win32-x64-msvc": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-win32-x64-msvc/-/oxide-win32-x64-msvc-4.1.18.tgz",
      "integrity": "sha512-bJWbyYpUlqamC8dpR7pfjA0I7vdF6t5VpUGMWRkXVE3AXgIZjYUYAK7II1GNaxR8J1SSrSrppRar8G++JekE3Q==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/postcss": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/@tailwindcss/postcss/-/postcss-4.1.18.tgz",
      "integrity": "sha512-Ce0GFnzAOuPyfV5SxjXGn0CubwGcuDB0zcdaPuCSzAa/2vII24JTkH+I6jcbXLb1ctjZMZZI6OjDaLPJQL1S0g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@alloc/quick-lru": "^5.2.0",
        "@tailwindcss/node": "4.1.18",
        "@tailwindcss/oxide": "4.1.18",
        "postcss": "^8.4.41",
        "tailwindcss": "4.1.18"
      }
    },
    "node_modules/@tybys/wasm-util": {
      "version": "0.10.1",
      "resolved": "https://registry.npmjs.org/@tybys/wasm-util/-/wasm-util-0.10.1.tgz",
      "integrity": "sha512-9tTaPJLSiejZKx+Bmog4uSubteqTvFrVrURwkmHixBo0G4seD0zUxp98E1DzUBJxLQ3NPwXrGKDiVjwx/DpPsg==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "tslib": "^2.4.0"
      }
    },
    "node_modules/@types/better-sqlite3": {
      "version": "7.6.13",
      "resolved": "https://registry.npmjs.org/@types/better-sqlite3/-/better-sqlite3-7.6.13.tgz",
      "integrity": "sha512-NMv9ASNARoKksWtsq/SHakpYAYnhBrQgGD8zkLYk/jaK8jUGn08CfEdTRgYhMypUQAfzSP8W6gNLe0q19/t4VA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/chai": {
      "version": "5.2.3",
      "resolved": "https://registry.npmjs.org/@types/chai/-/chai-5.2.3.tgz",
      "integrity": "sha512-Mw558oeA9fFbv65/y4mHtXDs9bPnFMZAL/jxdPFUpOHHIXX91mcgEHbS5Lahr+pwZFR8A7GQleRWeI6cGFC2UA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/deep-eql": "*",
        "assertion-error": "^2.0.1"
      }
    },
    "node_modules/@types/deep-eql": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/@types/deep-eql/-/deep-eql-4.0.2.tgz",
      "integrity": "sha512-c9h9dVVMigMPc4bwTvC5dxqtqJZwQPePsWjPlpSOnojbor6pGqdk541lfA7AqFQr5pB1BRdq0juY9db81BwyFw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/estree": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz",
      "integrity": "sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/json-schema": {
      "version": "7.0.15",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz",
      "integrity": "sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/json5": {
      "version": "0.0.29",
      "resolved": "https://registry.npmjs.org/@types/json5/-/json5-0.0.29.tgz",
      "integrity": "sha512-dRLjCWHYg4oaA77cxO64oO+7JwCwnIzkZPdrrC71jQmQtlhM556pwKo5bUzqvZndkVbeFLIIi+9TC40JNF5hNQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/node": {
      "version": "20.19.33",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-20.19.33.tgz",
      "integrity": "sha512-Rs1bVAIdBs5gbTIKza/tgpMuG1k3U/UMJLWecIMxNdJFDMzcM5LOiLVRYh3PilWEYDIeUDv7bpiHPLPsbydGcw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/react": {
      "version": "19.2.14",
      "resolved": "https://registry.npmjs.org/@types/react/-/react-19.2.14.tgz",
      "integrity": "sha512-ilcTH/UniCkMdtexkoCN0bI7pMcJDvmQFPvuPvmEaYA/NSfFTAgdUSLAoVjaRJm7+6PvcM+q1zYOwS4wTYMF9w==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "csstype": "^3.2.2"
      }
    },
    "node_modules/@types/react-dom": {
      "version": "19.2.3",
      "resolved": "https://registry.npmjs.org/@types/react-dom/-/react-dom-19.2.3.tgz",
      "integrity": "sha512-jp2L/eY6fn+KgVVQAOqYItbF0VY/YApe5Mz2F0aykSO8gx31bYCZyvSeYxCHKvzHG5eZjc+zyaS5BrBWya2+kQ==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "^19.2.0"
      }
    },
    "node_modules/@types/yaml": {
      "version": "1.9.6",
      "resolved": "https://registry.npmjs.org/@types/yaml/-/yaml-1.9.6.tgz",
      "integrity": "sha512-VKOCuDN57wngmyQnRqcn4vuGWCXViISHv+UCCjrKcf1yt4zyfMmOGlZDI2ucTHK72V8ki+sd7h21OZL6O5S52A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "yaml": "*"
      }
    },
    "node_modules/@typescript-eslint/eslint-plugin": {
      "version": "8.56.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-8.56.0.tgz",
      "integrity": "sha512-lRyPDLzNCuae71A3t9NEINBiTn7swyOhvUj3MyUOxb8x6g6vPEFoOU+ZRmGMusNC3X3YMhqMIX7i8ShqhT74Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/regexpp": "^4.12.2",
        "@typescript-eslint/scope-manager": "8.56.0",
        "@typescript-eslint/type-utils": "8.56.0",
        "@typescript-eslint/utils": "8.56.0",
        "@typescript-eslint/visitor-keys": "8.56.0",
        "ignore": "^7.0.5",
        "natural-compare": "^1.4.0",
        "ts-api-utils": "^2.4.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "@typescript-eslint/parser": "^8.56.0",
        "eslint": "^8.57.0 || ^9.0.0 || ^10.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/eslint-plugin/node_modules/ignore": {
      "version": "7.0.5",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-7.0.5.tgz",
      "integrity": "sha512-Hs59xBNfUIunMFgWAbGX5cq6893IbWg4KnrjbYwX3tx0ztorVgTDA6B2sxf8ejHJ4wz8BqGUMYlnzNBer5NvGg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/@typescript-eslint/parser": {
      "version": "8.56.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-8.56.0.tgz",
      "integrity": "sha512-IgSWvLobTDOjnaxAfDTIHaECbkNlAlKv2j5SjpB2v7QHKv1FIfjwMy8FsDbVfDX/KjmCmYICcw7uGaXLhtsLNg==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "@typescript-eslint/scope-manager": "8.56.0",
        "@typescript-eslint/types": "8.56.0",
        "@typescript-eslint/typescript-estree": "8.56.0",
        "@typescript-eslint/visitor-keys": "8.56.0",
        "debug": "^4.4.3"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0 || ^10.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/project-service": {
      "version": "8.56.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/project-service/-/project-service-8.56.0.tgz",
      "integrity": "sha512-M3rnyL1vIQOMeWxTWIW096/TtVP+8W3p/XnaFflhmcFp+U4zlxUxWj4XwNs6HbDeTtN4yun0GNTTDBw/SvufKg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/tsconfig-utils": "^8.56.0",
        "@typescript-eslint/types": "^8.56.0",
        "debug": "^4.4.3"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/scope-manager": {
      "version": "8.56.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-8.56.0.tgz",
      "integrity": "sha512-7UiO/XwMHquH+ZzfVCfUNkIXlp/yQjjnlYUyYz7pfvlK3/EyyN6BK+emDmGNyQLBtLGaYrTAI6KOw8tFucWL2w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "8.56.0",
        "@typescript-eslint/visitor-keys": "8.56.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/tsconfig-utils": {
      "version": "8.56.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/tsconfig-utils/-/tsconfig-utils-8.56.0.tgz",
      "integrity": "sha512-bSJoIIt4o3lKXD3xmDh9chZcjCz5Lk8xS7Rxn+6l5/pKrDpkCwtQNQQwZ2qRPk7TkUYhrq3WPIHXOXlbXP0itg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/type-utils": {
      "version": "8.56.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/type-utils/-/type-utils-8.56.0.tgz",
      "integrity": "sha512-qX2L3HWOU2nuDs6GzglBeuFXviDODreS58tLY/BALPC7iu3Fa+J7EOTwnX9PdNBxUI7Uh0ntP0YWGnxCkXzmfA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "8.56.0",
        "@typescript-eslint/typescript-estree": "8.56.0",
        "@typescript-eslint/utils": "8.56.0",
        "debug": "^4.4.3",
        "ts-api-utils": "^2.4.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0 || ^10.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/types": {
      "version": "8.56.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/types/-/types-8.56.0.tgz",
      "integrity": "sha512-DBsLPs3GsWhX5HylbP9HNG15U0bnwut55Lx12bHB9MpXxQ+R5GC8MwQe+N1UFXxAeQDvEsEDY6ZYwX03K7Z6HQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree": {
      "version": "8.56.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-8.56.0.tgz",
      "integrity": "sha512-ex1nTUMWrseMltXUHmR2GAQ4d+WjkZCT4f+4bVsps8QEdh0vlBsaCokKTPlnqBFqqGaxilDNJG7b8dolW2m43Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/project-service": "8.56.0",
        "@typescript-eslint/tsconfig-utils": "8.56.0",
        "@typescript-eslint/types": "8.56.0",
        "@typescript-eslint/visitor-keys": "8.56.0",
        "debug": "^4.4.3",
        "minimatch": "^9.0.5",
        "semver": "^7.7.3",
        "tinyglobby": "^0.2.15",
        "ts-api-utils": "^2.4.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/brace-expansion": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.2.tgz",
      "integrity": "sha512-Jt0vHyM+jmUBqojB7E1NIYadt0vI0Qxjxd2TErW94wDz+E2LAm5vKMXXwg6ZZBTHPuUlDgQHKXvjGBdfcF1ZDQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/minimatch": {
      "version": "9.0.5",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-9.0.5.tgz",
      "integrity": "sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^2.0.1"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/semver": {
      "version": "7.7.4",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.4.tgz",
      "integrity": "sha512-vFKC2IEtQnVhpT78h1Yp8wzwrf8CM+MzKMHGJZfBtzhZNycRFnXsHk6E5TxIkkMsgNS7mdX3AGB7x2QM2di4lA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/@typescript-eslint/utils": {
      "version": "8.56.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/utils/-/utils-8.56.0.tgz",
      "integrity": "sha512-RZ3Qsmi2nFGsS+n+kjLAYDPVlrzf7UhTffrDIKr+h2yzAlYP/y5ZulU0yeDEPItos2Ph46JAL5P/On3pe7kDIQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.9.1",
        "@typescript-eslint/scope-manager": "8.56.0",
        "@typescript-eslint/types": "8.56.0",
        "@typescript-eslint/typescript-estree": "8.56.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0 || ^10.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/visitor-keys": {
      "version": "8.56.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-8.56.0.tgz",
      "integrity": "sha512-q+SL+b+05Ud6LbEE35qe4A99P+htKTKVbyiNEe45eCbJFyh/HVK9QXwlrbz+Q4L8SOW4roxSVwXYj4DMBT7Ieg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "8.56.0",
        "eslint-visitor-keys": "^5.0.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/visitor-keys/node_modules/eslint-visitor-keys": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-5.0.0.tgz",
      "integrity": "sha512-A0XeIi7CXU7nPlfHS9loMYEKxUaONu/hTEzHTGba9Huu94Cq1hPivf+DE5erJozZOky0LfvXAyrV/tcswpLI0Q==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^20.19.0 || ^22.13.0 || >=24"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@unrs/resolver-binding-android-arm-eabi": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-android-arm-eabi/-/resolver-binding-android-arm-eabi-1.11.1.tgz",
      "integrity": "sha512-ppLRUgHVaGRWUx0R0Ut06Mjo9gBaBkg3v/8AxusGLhsIotbBLuRk51rAzqLC8gq6NyyAojEXglNjzf6R948DNw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@unrs/resolver-binding-android-arm64": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-android-arm64/-/resolver-binding-android-arm64-1.11.1.tgz",
      "integrity": "sha512-lCxkVtb4wp1v+EoN+HjIG9cIIzPkX5OtM03pQYkG+U5O/wL53LC4QbIeazgiKqluGeVEeBlZahHalCaBvU1a2g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@unrs/resolver-binding-darwin-arm64": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-darwin-arm64/-/resolver-binding-darwin-arm64-1.11.1.tgz",
      "integrity": "sha512-gPVA1UjRu1Y/IsB/dQEsp2V1pm44Of6+LWvbLc9SDk1c2KhhDRDBUkQCYVWe6f26uJb3fOK8saWMgtX8IrMk3g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@unrs/resolver-binding-darwin-x64": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-darwin-x64/-/resolver-binding-darwin-x64-1.11.1.tgz",
      "integrity": "sha512-cFzP7rWKd3lZaCsDze07QX1SC24lO8mPty9vdP+YVa3MGdVgPmFc59317b2ioXtgCMKGiCLxJ4HQs62oz6GfRQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@unrs/resolver-binding-freebsd-x64": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-freebsd-x64/-/resolver-binding-freebsd-x64-1.11.1.tgz",
      "integrity": "sha512-fqtGgak3zX4DCB6PFpsH5+Kmt/8CIi4Bry4rb1ho6Av2QHTREM+47y282Uqiu3ZRF5IQioJQ5qWRV6jduA+iGw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-arm-gnueabihf": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-arm-gnueabihf/-/resolver-binding-linux-arm-gnueabihf-1.11.1.tgz",
      "integrity": "sha512-u92mvlcYtp9MRKmP+ZvMmtPN34+/3lMHlyMj7wXJDeXxuM0Vgzz0+PPJNsro1m3IZPYChIkn944wW8TYgGKFHw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-arm-musleabihf": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-arm-musleabihf/-/resolver-binding-linux-arm-musleabihf-1.11.1.tgz",
      "integrity": "sha512-cINaoY2z7LVCrfHkIcmvj7osTOtm6VVT16b5oQdS4beibX2SYBwgYLmqhBjA1t51CarSaBuX5YNsWLjsqfW5Cw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-arm64-gnu": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-arm64-gnu/-/resolver-binding-linux-arm64-gnu-1.11.1.tgz",
      "integrity": "sha512-34gw7PjDGB9JgePJEmhEqBhWvCiiWCuXsL9hYphDF7crW7UgI05gyBAi6MF58uGcMOiOqSJ2ybEeCvHcq0BCmQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-arm64-musl": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-arm64-musl/-/resolver-binding-linux-arm64-musl-1.11.1.tgz",
      "integrity": "sha512-RyMIx6Uf53hhOtJDIamSbTskA99sPHS96wxVE/bJtePJJtpdKGXO1wY90oRdXuYOGOTuqjT8ACccMc4K6QmT3w==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-ppc64-gnu": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-ppc64-gnu/-/resolver-binding-linux-ppc64-gnu-1.11.1.tgz",
      "integrity": "sha512-D8Vae74A4/a+mZH0FbOkFJL9DSK2R6TFPC9M+jCWYia/q2einCubX10pecpDiTmkJVUH+y8K3BZClycD8nCShA==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-riscv64-gnu": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-riscv64-gnu/-/resolver-binding-linux-riscv64-gnu-1.11.1.tgz",
      "integrity": "sha512-frxL4OrzOWVVsOc96+V3aqTIQl1O2TjgExV4EKgRY09AJ9leZpEg8Ak9phadbuX0BA4k8U5qtvMSQQGGmaJqcQ==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-riscv64-musl": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-riscv64-musl/-/resolver-binding-linux-riscv64-musl-1.11.1.tgz",
      "integrity": "sha512-mJ5vuDaIZ+l/acv01sHoXfpnyrNKOk/3aDoEdLO/Xtn9HuZlDD6jKxHlkN8ZhWyLJsRBxfv9GYM2utQ1SChKew==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-s390x-gnu": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-s390x-gnu/-/resolver-binding-linux-s390x-gnu-1.11.1.tgz",
      "integrity": "sha512-kELo8ebBVtb9sA7rMe1Cph4QHreByhaZ2QEADd9NzIQsYNQpt9UkM9iqr2lhGr5afh885d/cB5QeTXSbZHTYPg==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-x64-gnu": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-x64-gnu/-/resolver-binding-linux-x64-gnu-1.11.1.tgz",
      "integrity": "sha512-C3ZAHugKgovV5YvAMsxhq0gtXuwESUKc5MhEtjBpLoHPLYM+iuwSj3lflFwK3DPm68660rZ7G8BMcwSro7hD5w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-linux-x64-musl": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-linux-x64-musl/-/resolver-binding-linux-x64-musl-1.11.1.tgz",
      "integrity": "sha512-rV0YSoyhK2nZ4vEswT/QwqzqQXw5I6CjoaYMOX0TqBlWhojUf8P94mvI7nuJTeaCkkds3QE4+zS8Ko+GdXuZtA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@unrs/resolver-binding-wasm32-wasi": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-wasm32-wasi/-/resolver-binding-wasm32-wasi-1.11.1.tgz",
      "integrity": "sha512-5u4RkfxJm+Ng7IWgkzi3qrFOvLvQYnPBmjmZQ8+szTK/b31fQCnleNl1GgEt7nIsZRIf5PLhPwT0WM+q45x/UQ==",
      "cpu": [
        "wasm32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "@napi-rs/wasm-runtime": "^0.2.11"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@unrs/resolver-binding-win32-arm64-msvc": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-win32-arm64-msvc/-/resolver-binding-win32-arm64-msvc-1.11.1.tgz",
      "integrity": "sha512-nRcz5Il4ln0kMhfL8S3hLkxI85BXs3o8EYoattsJNdsX4YUU89iOkVn7g0VHSRxFuVMdM4Q1jEpIId1Ihim/Uw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@unrs/resolver-binding-win32-ia32-msvc": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-win32-ia32-msvc/-/resolver-binding-win32-ia32-msvc-1.11.1.tgz",
      "integrity": "sha512-DCEI6t5i1NmAZp6pFonpD5m7i6aFrpofcp4LA2i8IIq60Jyo28hamKBxNrZcyOwVOZkgsRp9O2sXWBWP8MnvIQ==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@unrs/resolver-binding-win32-x64-msvc": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/@unrs/resolver-binding-win32-x64-msvc/-/resolver-binding-win32-x64-msvc-1.11.1.tgz",
      "integrity": "sha512-lrW200hZdbfRtztbygyaq/6jP6AKE8qQN2KvPcJ+x7wiD038YtnYtZ82IMNJ69GJibV7bwL3y9FgK+5w/pYt6g==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@vitest/expect": {
      "version": "4.0.18",
      "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-4.0.18.tgz",
      "integrity": "sha512-8sCWUyckXXYvx4opfzVY03EOiYVxyNrHS5QxX3DAIi5dpJAAkyJezHCP77VMX4HKA2LDT/Jpfo8i2r5BE3GnQQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@standard-schema/spec": "^1.0.0",
        "@types/chai": "^5.2.2",
        "@vitest/spy": "4.0.18",
        "@vitest/utils": "4.0.18",
        "chai": "^6.2.1",
        "tinyrainbow": "^3.0.3"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/mocker": {
      "version": "4.0.18",
      "resolved": "https://registry.npmjs.org/@vitest/mocker/-/mocker-4.0.18.tgz",
      "integrity": "sha512-HhVd0MDnzzsgevnOWCBj5Otnzobjy5wLBe4EdeeFGv8luMsGcYqDuFRMcttKWZA5vVO8RFjexVovXvAM4JoJDQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/spy": "4.0.18",
        "estree-walker": "^3.0.3",
        "magic-string": "^0.30.21"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "msw": "^2.4.9",
        "vite": "^6.0.0 || ^7.0.0-0"
      },
      "peerDependenciesMeta": {
        "msw": {
          "optional": true
        },
        "vite": {
          "optional": true
        }
      }
    },
    "node_modules/@vitest/pretty-format": {
      "version": "4.0.18",
      "resolved": "https://registry.npmjs.org/@vitest/pretty-format/-/pretty-format-4.0.18.tgz",
      "integrity": "sha512-P24GK3GulZWC5tz87ux0m8OADrQIUVDPIjjj65vBXYG17ZeU3qD7r+MNZ1RNv4l8CGU2vtTRqixrOi9fYk/yKw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "tinyrainbow": "^3.0.3"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/runner": {
      "version": "4.0.18",
      "resolved": "https://registry.npmjs.org/@vitest/runner/-/runner-4.0.18.tgz",
      "integrity": "sha512-rpk9y12PGa22Jg6g5M3UVVnTS7+zycIGk9ZNGN+m6tZHKQb7jrP7/77WfZy13Y/EUDd52NDsLRQhYKtv7XfPQw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/utils": "4.0.18",
        "pathe": "^2.0.3"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/snapshot": {
      "version": "4.0.18",
      "resolved": "https://registry.npmjs.org/@vitest/snapshot/-/snapshot-4.0.18.tgz",
      "integrity": "sha512-PCiV0rcl7jKQjbgYqjtakly6T1uwv/5BQ9SwBLekVg/EaYeQFPiXcgrC2Y7vDMA8dM1SUEAEV82kgSQIlXNMvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/pretty-format": "4.0.18",
        "magic-string": "^0.30.21",
        "pathe": "^2.0.3"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/spy": {
      "version": "4.0.18",
      "resolved": "https://registry.npmjs.org/@vitest/spy/-/spy-4.0.18.tgz",
      "integrity": "sha512-cbQt3PTSD7P2OARdVW3qWER5EGq7PHlvE+QfzSC0lbwO+xnt7+XH06ZzFjFRgzUX//JmpxrCu92VdwvEPlWSNw==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/utils": {
      "version": "4.0.18",
      "resolved": "https://registry.npmjs.org/@vitest/utils/-/utils-4.0.18.tgz",
      "integrity": "sha512-msMRKLMVLWygpK3u2Hybgi4MNjcYJvwTb0Ru09+fOyCXIgT5raYP041DRRdiJiI3k/2U6SEbAETB3YtBrUkCFA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/pretty-format": "4.0.18",
        "tinyrainbow": "^3.0.3"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/acorn": {
      "version": "8.15.0",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.15.0.tgz",
      "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-jsx": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz",
      "integrity": "sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
      }
    },
    "node_modules/ajv": {
      "version": "6.12.6",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fast-deep-equal": "^3.1.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/epoberezkin"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "license": "Python-2.0"
    },
    "node_modules/aria-query": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/aria-query/-/aria-query-5.3.2.tgz",
      "integrity": "sha512-COROpnaoap1E2F000S62r6A60uHZnmlvomhfyT2DlTcrY1OrBKn2UhH7qn5wTC9zMvD0AY7csdPSNwKP+7WiQw==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/array-buffer-byte-length": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/array-buffer-byte-length/-/array-buffer-byte-length-1.0.2.tgz",
      "integrity": "sha512-LHE+8BuR7RYGDKvnrmcuSq3tDcKv9OFEXQt/HpbZhY7V6h0zlUXutnAD82GiFx9rdieCMjkvtcsPqBwgUl1Iiw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "is-array-buffer": "^3.0.5"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/array-includes": {
      "version": "3.1.9",
      "resolved": "https://registry.npmjs.org/array-includes/-/array-includes-3.1.9.tgz",
      "integrity": "sha512-FmeCCAenzH0KH381SPT5FZmiA/TmpndpcaShhfgEN9eCVjnFBqq3l1xrI42y8+PPLI6hypzou4GXw00WHmPBLQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.4",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.24.0",
        "es-object-atoms": "^1.1.1",
        "get-intrinsic": "^1.3.0",
        "is-string": "^1.1.1",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/array.prototype.findlast": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/array.prototype.findlast/-/array.prototype.findlast-1.2.5.tgz",
      "integrity": "sha512-CVvd6FHg1Z3POpBLxO6E6zr+rSKEQ9L6rZHAaY7lLfhKsWYUBBOuMs0e9o24oopj6H+geRCX0YJ+TJLBK2eHyQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.7",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.2",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.0.0",
        "es-shim-unscopables": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/array.prototype.findlastindex": {
      "version": "1.2.6",
      "resolved": "https://registry.npmjs.org/array.prototype.findlastindex/-/array.prototype.findlastindex-1.2.6.tgz",
      "integrity": "sha512-F/TKATkzseUExPlfvmwQKGITM3DGTK+vkAsCZoDc5daVygbJBnjEUCbgkAvVFsgfXfX4YIqZ/27G3k3tdXrTxQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.4",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.9",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "es-shim-unscopables": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/array.prototype.flat": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/array.prototype.flat/-/array.prototype.flat-1.3.3.tgz",
      "integrity": "sha512-rwG/ja1neyLqCuGZ5YYrznA62D4mZXg0i1cIskIUKSiqF3Cje9/wXAls9B9s1Wa2fomMsIv8czB8jZcPmxCXFg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.5",
        "es-shim-unscopables": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/array.prototype.flatmap": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/array.prototype.flatmap/-/array.prototype.flatmap-1.3.3.tgz",
      "integrity": "sha512-Y7Wt51eKJSyi80hFrJCePGGNo5ktJCslFuboqJsbf57CCPcm5zztluPlc4/aD8sWsKvlwatezpV4U1efk8kpjg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.5",
        "es-shim-unscopables": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/array.prototype.tosorted": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/array.prototype.tosorted/-/array.prototype.tosorted-1.1.4.tgz",
      "integrity": "sha512-p6Fx8B7b7ZhL/gmUsAy0D15WhvDccw3mnGNbZpi3pmeJdxtWsj2jEaI4Y6oo3XiHfzuSgPwKc04MYt6KgvC/wA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.7",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.3",
        "es-errors": "^1.3.0",
        "es-shim-unscopables": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/arraybuffer.prototype.slice": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/arraybuffer.prototype.slice/-/arraybuffer.prototype.slice-1.0.4.tgz",
      "integrity": "sha512-BNoCY6SXXPQ7gF2opIP4GBE+Xw7U+pHMYKuzjgCN3GwiaIR09UUeKfheyIry77QtrCBlC0KK0q5/TER/tYh3PQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "array-buffer-byte-length": "^1.0.1",
        "call-bind": "^1.0.8",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.5",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "is-array-buffer": "^3.0.4"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/assertion-error": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/assertion-error/-/assertion-error-2.0.1.tgz",
      "integrity": "sha512-Izi8RQcffqCeNVgFigKli1ssklIbpHnCYc6AknXGYoB6grJqyeby7jv12JUQgmTAnIDnbck1uxksT4dzN3PWBA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/ast-types-flow": {
      "version": "0.0.8",
      "resolved": "https://registry.npmjs.org/ast-types-flow/-/ast-types-flow-0.0.8.tgz",
      "integrity": "sha512-OH/2E5Fg20h2aPrbe+QL8JZQFko0YZaF+j4mnQ7BGhfavO7OpSLa8a0y9sBwomHdSbkhTS8TQNayBfnW5DwbvQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/async-function": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/async-function/-/async-function-1.0.0.tgz",
      "integrity": "sha512-hsU18Ae8CDTR6Kgu9DYf0EbCr/a5iGL0rytQDobUcdpYOKokk8LEjVphnXkDkgpi0wYVsqrXuP0bZxJaTqdgoA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/atomic-sleep": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/atomic-sleep/-/atomic-sleep-1.0.0.tgz",
      "integrity": "sha512-kNOjDqAh7px0XWNI+4QbzoiR/nTkHAWNud2uvnJquD1/x5a7EQZMJT0AczqK0Qn67oY/TTQ1LbUKajZpp3I9tQ==",
      "license": "MIT",
      "engines": {
        "node": ">=8.0.0"
      }
    },
    "node_modules/available-typed-arrays": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/available-typed-arrays/-/available-typed-arrays-1.0.7.tgz",
      "integrity": "sha512-wvUjBtSGN7+7SjNpq/9M2Tg350UZD3q62IFZLbRAR1bSMlCo1ZaeW+BJ+D090e4hIIZLBcTDWe4Mh4jvUDajzQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "possible-typed-array-names": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/axe-core": {
      "version": "4.11.1",
      "resolved": "https://registry.npmjs.org/axe-core/-/axe-core-4.11.1.tgz",
      "integrity": "sha512-BASOg+YwO2C+346x3LZOeoovTIoTrRqEsqMa6fmfAV0P+U9mFr9NsyOEpiYvFjbc64NMrSswhV50WdXzdb/Z5A==",
      "dev": true,
      "license": "MPL-2.0",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/axobject-query": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/axobject-query/-/axobject-query-4.1.0.tgz",
      "integrity": "sha512-qIj0G9wZbMGNLjLmg1PT6v2mE9AH2zlnADJD/2tC6E00hgmhUOfEB6greHPAfLRSufHqROIUTkw6E+M3lH0PTQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/base64-js": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.5.1.tgz",
      "integrity": "sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/baseline-browser-mapping": {
      "version": "2.9.19",
      "resolved": "https://registry.npmjs.org/baseline-browser-mapping/-/baseline-browser-mapping-2.9.19.tgz",
      "integrity": "sha512-ipDqC8FrAl/76p2SSWKSI+H9tFwm7vYqXQrItCuiVPt26Km0jS+NzSsBWAaBusvSbQcfJG+JitdMm+wZAgTYqg==",
      "license": "Apache-2.0",
      "bin": {
        "baseline-browser-mapping": "dist/cli.js"
      }
    },
    "node_modules/better-sqlite3": {
      "version": "12.6.2",
      "resolved": "https://registry.npmjs.org/better-sqlite3/-/better-sqlite3-12.6.2.tgz",
      "integrity": "sha512-8VYKM3MjCa9WcaSAI3hzwhmyHVlH8tiGFwf0RlTsZPWJ1I5MkzjiudCo4KC4DxOaL/53A5B1sI/IbldNFDbsKA==",
      "hasInstallScript": true,
      "license": "MIT",
      "dependencies": {
        "bindings": "^1.5.0",
        "prebuild-install": "^7.1.1"
      },
      "engines": {
        "node": "20.x || 22.x || 23.x || 24.x || 25.x"
      }
    },
    "node_modules/bindings": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/bindings/-/bindings-1.5.0.tgz",
      "integrity": "sha512-p2q/t/mhvuOj/UeLlV6566GD/guowlr0hHxClI0W9m7MWYkL1F0hLo+0Aexs9HSPCtR1SXQ0TD3MMKrXZajbiQ==",
      "license": "MIT",
      "dependencies": {
        "file-uri-to-path": "1.0.0"
      }
    },
    "node_modules/bl": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/bl/-/bl-4.1.0.tgz",
      "integrity": "sha512-1W07cM9gS6DcLperZfFSj+bWLtaPGSOHWhPiGzXmvVJbRLdG82sH/Kn8EtW1VqWVA54AKf2h5k5BbnIbwF3h6w==",
      "license": "MIT",
      "dependencies": {
        "buffer": "^5.5.0",
        "inherits": "^2.0.4",
        "readable-stream": "^3.4.0"
      }
    },
    "node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/browserslist": {
      "version": "4.28.1",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.28.1.tgz",
      "integrity": "sha512-ZC5Bd0LgJXgwGqUknZY/vkUQ04r8NXnJZ3yYi4vDmSiZmC/pdSN0NbNRPxZpbtO4uAfDUAFffO8IZoM3Gj8IkA==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "baseline-browser-mapping": "^2.9.0",
        "caniuse-lite": "^1.0.30001759",
        "electron-to-chromium": "^1.5.263",
        "node-releases": "^2.0.27",
        "update-browserslist-db": "^1.2.0"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      }
    },
    "node_modules/buffer": {
      "version": "5.7.1",
      "resolved": "https://registry.npmjs.org/buffer/-/buffer-5.7.1.tgz",
      "integrity": "sha512-EHcyIPBQ4BSGlvjB16k5KgAJ27CIsHY/2JBmCRReo48y9rQ3MaUzWX3KVlBa4U7MyX02HdVj0K7C3WaB3ju7FQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "base64-js": "^1.3.1",
        "ieee754": "^1.1.13"
      }
    },
    "node_modules/call-bind": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/call-bind/-/call-bind-1.0.8.tgz",
      "integrity": "sha512-oKlSFMcMwpUg2ednkhQ454wfWiU/ul3CkJe/PEHcTKuiX6RpbehUiFMXu13HalGZxfUwCQzZG747YXBn1im9ww==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.0",
        "es-define-property": "^1.0.0",
        "get-intrinsic": "^1.2.4",
        "set-function-length": "^1.2.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/callsites": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001770",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001770.tgz",
      "integrity": "sha512-x/2CLQ1jHENRbHg5PSId2sXq1CIO1CISvwWAj027ltMVG2UNgW+w9oH2+HzgEIRFembL8bUlXtfbBHR1fCg2xw==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "CC-BY-4.0"
    },
    "node_modules/chai": {
      "version": "6.2.2",
      "resolved": "https://registry.npmjs.org/chai/-/chai-6.2.2.tgz",
      "integrity": "sha512-NUPRluOfOiTKBKvWPtSD4PhFvWCqOi0BGStNWs57X9js7XGTprSmFoz5F0tWhR4WPjNeR9jXqdC7/UpSJTnlRg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/chalk": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/chalk?sponsor=1"
      }
    },
    "node_modules/chownr": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/chownr/-/chownr-1.1.4.tgz",
      "integrity": "sha512-jJ0bqzaylmJtVnNgzTeSOs8DPavpbYgEr/b0YL8/2GO3xJEhInFmhKMUnEJQjZumK7KXGFhUy89PrsJWlakBVg==",
      "license": "ISC"
    },
    "node_modules/client-only": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/client-only/-/client-only-0.0.1.tgz",
      "integrity": "sha512-IV3Ou0jSMzZrd3pZ48nLkT9DA7Ag1pnPzaiQhpW7c3RbcqqzvzzVu+L8gfqMp/8IM2MQtSiqaCxrrcfu8I8rMA==",
      "license": "MIT"
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/commander": {
      "version": "14.0.3",
      "resolved": "https://registry.npmjs.org/commander/-/commander-14.0.3.tgz",
      "integrity": "sha512-H+y0Jo/T1RZ9qPP4Eh1pkcQcLRglraJaSLoyOtHxu6AapkjWVCy2Sit1QQ4x3Dng8qDlSsZEet7g5Pq06MvTgw==",
      "license": "MIT",
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/convert-source-map": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz",
      "integrity": "sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cosmiconfig": {
      "version": "9.0.0",
      "resolved": "https://registry.npmjs.org/cosmiconfig/-/cosmiconfig-9.0.0.tgz",
      "integrity": "sha512-itvL5h8RETACmOTFc4UfIyB2RfEHi71Ax6E/PivVxq9NseKbOWpeyHEOIbmAw1rs8Ak0VursQNww7lf7YtUwzg==",
      "license": "MIT",
      "dependencies": {
        "env-paths": "^2.2.1",
        "import-fresh": "^3.3.0",
        "js-yaml": "^4.1.0",
        "parse-json": "^5.2.0"
      },
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/d-fischer"
      },
      "peerDependencies": {
        "typescript": ">=4.9.5"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/cross-spawn": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/csstype": {
      "version": "3.2.3",
      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.2.3.tgz",
      "integrity": "sha512-z1HGKcYy2xA8AGQfwrn0PAy+PB7X/GSj3UVJW9qKyn43xWa+gl5nXmU4qqLMRzWVLFC8KusUX8T/0kCiOYpAIQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/damerau-levenshtein": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/damerau-levenshtein/-/damerau-levenshtein-1.0.8.tgz",
      "integrity": "sha512-sdQSFB7+llfUcQHUQO3+B8ERRj0Oa4w9POWMI/puGtuf7gFywGmkaLCElnudfTiKZV+NvHqL0ifzdrI8Ro7ESA==",
      "dev": true,
      "license": "BSD-2-Clause"
    },
    "node_modules/data-view-buffer": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/data-view-buffer/-/data-view-buffer-1.0.2.tgz",
      "integrity": "sha512-EmKO5V3OLXh1rtK2wgXRansaK1/mtVdTUEiEI0W8RkvgT05kfxaH29PliLnpLP73yYO6142Q72QNa8Wx/A5CqQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "es-errors": "^1.3.0",
        "is-data-view": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/data-view-byte-length": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/data-view-byte-length/-/data-view-byte-length-1.0.2.tgz",
      "integrity": "sha512-tuhGbE6CfTM9+5ANGf+oQb72Ky/0+s3xKUpHvShfiz2RxMFgFPjsXuRLBVMtvMs15awe45SRb83D6wH4ew6wlQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "es-errors": "^1.3.0",
        "is-data-view": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/inspect-js"
      }
    },
    "node_modules/data-view-byte-offset": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/data-view-byte-offset/-/data-view-byte-offset-1.0.1.tgz",
      "integrity": "sha512-BS8PfmtDGnrgYdOonGZQdLZslWIeCGFP9tpan0hi1Co2Zr2NKADsvGYA8XxuG/4UWgJ6Cjtv+YJnB6MM69QGlQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "is-data-view": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/debug": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/decompress-response": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/decompress-response/-/decompress-response-6.0.0.tgz",
      "integrity": "sha512-aW35yZM6Bb/4oJlZncMH2LCoZtJXTRxES17vE3hoRiowU2kWHaJKFkSBDnDR+cm9J+9QhXmREyIfv0pji9ejCQ==",
      "license": "MIT",
      "dependencies": {
        "mimic-response": "^3.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/deep-extend": {
      "version": "0.6.0",
      "resolved": "https://registry.npmjs.org/deep-extend/-/deep-extend-0.6.0.tgz",
      "integrity": "sha512-LOHxIOaPYdHlJRtCQfDIVZtfw/ufM8+rVj649RIHzcm/vGwQRXFt6OPqIFWsm2XEMrNIEtWR64sY1LEKD2vAOA==",
      "license": "MIT",
      "engines": {
        "node": ">=4.0.0"
      }
    },
    "node_modules/deep-is": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz",
      "integrity": "sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/define-data-property": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/define-data-property/-/define-data-property-1.1.4.tgz",
      "integrity": "sha512-rBMvIzlpA8v6E+SJZoo++HAYqsLrkg7MSfIinMPFhmkorw7X+dOXVJQs+QT69zGkzMyfDnIMN2Wid1+NbL3T+A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-define-property": "^1.0.0",
        "es-errors": "^1.3.0",
        "gopd": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/define-properties": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/define-properties/-/define-properties-1.2.1.tgz",
      "integrity": "sha512-8QmQKqEASLd5nx0U1B1okLElbUuuttJ/AnYmRXbbbGDWh6uS208EjD4Xqq/I9wK7u0v6O08XhTWnt5XtEbR6Dg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "define-data-property": "^1.0.1",
        "has-property-descriptors": "^1.0.0",
        "object-keys": "^1.1.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/detect-libc": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/detect-libc/-/detect-libc-2.1.2.tgz",
      "integrity": "sha512-Btj2BOOO83o3WyH59e8MgXsxEQVcarkUOpEYrubB0urwnN10yQ364rsiByU11nZlqWYZm05i/of7io4mzihBtQ==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/doctrine": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/doctrine/-/doctrine-2.1.0.tgz",
      "integrity": "sha512-35mSku4ZXK0vfCuHEDAwt55dg2jNajHZ1odvF+8SSr82EsZY4QmXfuWso8oEd8zRhVObSN18aM0CjSdoBX7zIw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "esutils": "^2.0.2"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/electron-to-chromium": {
      "version": "1.5.286",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.286.tgz",
      "integrity": "sha512-9tfDXhJ4RKFNerfjdCcZfufu49vg620741MNs26a9+bhLThdB+plgMeou98CAaHu/WATj2iHOOHTp1hWtABj2A==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/emoji-regex": {
      "version": "9.2.2",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/end-of-stream": {
      "version": "1.4.5",
      "resolved": "https://registry.npmjs.org/end-of-stream/-/end-of-stream-1.4.5.tgz",
      "integrity": "sha512-ooEGc6HP26xXq/N+GCGOT0JKCLDGrq2bQUZrQ7gyrJiZANJ/8YDTxTpQBXGMn+WbIQXNVpyWymm7KYVICQnyOg==",
      "license": "MIT",
      "dependencies": {
        "once": "^1.4.0"
      }
    },
    "node_modules/enhanced-resolve": {
      "version": "5.19.0",
      "resolved": "https://registry.npmjs.org/enhanced-resolve/-/enhanced-resolve-5.19.0.tgz",
      "integrity": "sha512-phv3E1Xl4tQOShqSte26C7Fl84EwUdZsyOuSSk9qtAGyyQs2s3jJzComh+Abf4g187lUUAvH+H26omrqia2aGg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "graceful-fs": "^4.2.4",
        "tapable": "^2.3.0"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/env-paths": {
      "version": "2.2.1",
      "resolved": "https://registry.npmjs.org/env-paths/-/env-paths-2.2.1.tgz",
      "integrity": "sha512-+h1lkLKhZMTYjog1VEpJNG7NZJWcuc2DDk/qsqSTRRCOXiLjeQ1d1/udrUGhqMxUgAlwKNZ0cf2uqan5GLuS2A==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/error-ex": {
      "version": "1.3.4",
      "resolved": "https://registry.npmjs.org/error-ex/-/error-ex-1.3.4.tgz",
      "integrity": "sha512-sqQamAnR14VgCr1A618A3sGrygcpK+HEbenA/HiEAkkUwcZIIB/tgWqHFxWgOyDh4nB4JCRimh79dR5Ywc9MDQ==",
      "license": "MIT",
      "dependencies": {
        "is-arrayish": "^0.2.1"
      }
    },
    "node_modules/es-abstract": {
      "version": "1.24.1",
      "resolved": "https://registry.npmjs.org/es-abstract/-/es-abstract-1.24.1.tgz",
      "integrity": "sha512-zHXBLhP+QehSSbsS9Pt23Gg964240DPd6QCf8WpkqEXxQ7fhdZzYsocOr5u7apWonsS5EjZDmTF+/slGMyasvw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "array-buffer-byte-length": "^1.0.2",
        "arraybuffer.prototype.slice": "^1.0.4",
        "available-typed-arrays": "^1.0.7",
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.4",
        "data-view-buffer": "^1.0.2",
        "data-view-byte-length": "^1.0.2",
        "data-view-byte-offset": "^1.0.1",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "es-set-tostringtag": "^2.1.0",
        "es-to-primitive": "^1.3.0",
        "function.prototype.name": "^1.1.8",
        "get-intrinsic": "^1.3.0",
        "get-proto": "^1.0.1",
        "get-symbol-description": "^1.1.0",
        "globalthis": "^1.0.4",
        "gopd": "^1.2.0",
        "has-property-descriptors": "^1.0.2",
        "has-proto": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "internal-slot": "^1.1.0",
        "is-array-buffer": "^3.0.5",
        "is-callable": "^1.2.7",
        "is-data-view": "^1.0.2",
        "is-negative-zero": "^2.0.3",
        "is-regex": "^1.2.1",
        "is-set": "^2.0.3",
        "is-shared-array-buffer": "^1.0.4",
        "is-string": "^1.1.1",
        "is-typed-array": "^1.1.15",
        "is-weakref": "^1.1.1",
        "math-intrinsics": "^1.1.0",
        "object-inspect": "^1.13.4",
        "object-keys": "^1.1.1",
        "object.assign": "^4.1.7",
        "own-keys": "^1.0.1",
        "regexp.prototype.flags": "^1.5.4",
        "safe-array-concat": "^1.1.3",
        "safe-push-apply": "^1.0.0",
        "safe-regex-test": "^1.1.0",
        "set-proto": "^1.0.0",
        "stop-iteration-iterator": "^1.1.0",
        "string.prototype.trim": "^1.2.10",
        "string.prototype.trimend": "^1.0.9",
        "string.prototype.trimstart": "^1.0.8",
        "typed-array-buffer": "^1.0.3",
        "typed-array-byte-length": "^1.0.3",
        "typed-array-byte-offset": "^1.0.4",
        "typed-array-length": "^1.0.7",
        "unbox-primitive": "^1.1.0",
        "which-typed-array": "^1.1.19"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-iterator-helpers": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/es-iterator-helpers/-/es-iterator-helpers-1.2.2.tgz",
      "integrity": "sha512-BrUQ0cPTB/IwXj23HtwHjS9n7O4h9FX94b4xc5zlTHxeLgTAdzYUDyy6KdExAl9lbN5rtfe44xpjpmj9grxs5w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.4",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.24.1",
        "es-errors": "^1.3.0",
        "es-set-tostringtag": "^2.1.0",
        "function-bind": "^1.1.2",
        "get-intrinsic": "^1.3.0",
        "globalthis": "^1.0.4",
        "gopd": "^1.2.0",
        "has-property-descriptors": "^1.0.2",
        "has-proto": "^1.2.0",
        "has-symbols": "^1.1.0",
        "internal-slot": "^1.1.0",
        "iterator.prototype": "^1.1.5",
        "safe-array-concat": "^1.1.3"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-module-lexer": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/es-module-lexer/-/es-module-lexer-1.7.0.tgz",
      "integrity": "sha512-jEQoCwk8hyb2AZziIOLhDqpm5+2ww5uIE6lkO/6jcOCusfk6LhMHpXXfBLXTZ7Ydyt0j4VoUQv6uGNYbdW+kBA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-set-tostringtag": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-shim-unscopables": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/es-shim-unscopables/-/es-shim-unscopables-1.1.0.tgz",
      "integrity": "sha512-d9T8ucsEhh8Bi1woXCf+TIKDIROLG5WCkxg8geBCbvk22kzwC5G2OnXVMO6FUsvQlgUUXQ2itephWDLqDzbeCw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-to-primitive": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-to-primitive/-/es-to-primitive-1.3.0.tgz",
      "integrity": "sha512-w+5mJ3GuFL+NjVtJlvydShqE1eN3h3PbI7/5LAsYJP/2qtuMXjfL2LpHSRqo4b4eSF5K/DH1JXKUAHSB2UW50g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-callable": "^1.2.7",
        "is-date-object": "^1.0.5",
        "is-symbol": "^1.0.4"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/esbuild": {
      "version": "0.27.3",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.27.3.tgz",
      "integrity": "sha512-8VwMnyGCONIs6cWue2IdpHxHnAjzxnw2Zr7MkVxB2vjmQ2ivqGFb4LEG3SMnv0Gb2F/G/2yA8zUaiL1gywDCCg==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=18"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.27.3",
        "@esbuild/android-arm": "0.27.3",
        "@esbuild/android-arm64": "0.27.3",
        "@esbuild/android-x64": "0.27.3",
        "@esbuild/darwin-arm64": "0.27.3",
        "@esbuild/darwin-x64": "0.27.3",
        "@esbuild/freebsd-arm64": "0.27.3",
        "@esbuild/freebsd-x64": "0.27.3",
        "@esbuild/linux-arm": "0.27.3",
        "@esbuild/linux-arm64": "0.27.3",
        "@esbuild/linux-ia32": "0.27.3",
        "@esbuild/linux-loong64": "0.27.3",
        "@esbuild/linux-mips64el": "0.27.3",
        "@esbuild/linux-ppc64": "0.27.3",
        "@esbuild/linux-riscv64": "0.27.3",
        "@esbuild/linux-s390x": "0.27.3",
        "@esbuild/linux-x64": "0.27.3",
        "@esbuild/netbsd-arm64": "0.27.3",
        "@esbuild/netbsd-x64": "0.27.3",
        "@esbuild/openbsd-arm64": "0.27.3",
        "@esbuild/openbsd-x64": "0.27.3",
        "@esbuild/openharmony-arm64": "0.27.3",
        "@esbuild/sunos-x64": "0.27.3",
        "@esbuild/win32-arm64": "0.27.3",
        "@esbuild/win32-ia32": "0.27.3",
        "@esbuild/win32-x64": "0.27.3"
      }
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/escape-string-regexp": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint": {
      "version": "9.39.2",
      "resolved": "https://registry.npmjs.org/eslint/-/eslint-9.39.2.tgz",
      "integrity": "sha512-LEyamqS7W5HB3ujJyvi0HQK/dtVINZvd5mAAp9eT5S/ujByGjiZLCzPcHVzuXbpJDJF/cxwHlfceVUDZ2lnSTw==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.8.0",
        "@eslint-community/regexpp": "^4.12.1",
        "@eslint/config-array": "^0.21.1",
        "@eslint/config-helpers": "^0.4.2",
        "@eslint/core": "^0.17.0",
        "@eslint/eslintrc": "^3.3.1",
        "@eslint/js": "9.39.2",
        "@eslint/plugin-kit": "^0.4.1",
        "@humanfs/node": "^0.16.6",
        "@humanwhocodes/module-importer": "^1.0.1",
        "@humanwhocodes/retry": "^0.4.2",
        "@types/estree": "^1.0.6",
        "ajv": "^6.12.4",
        "chalk": "^4.0.0",
        "cross-spawn": "^7.0.6",
        "debug": "^4.3.2",
        "escape-string-regexp": "^4.0.0",
        "eslint-scope": "^8.4.0",
        "eslint-visitor-keys": "^4.2.1",
        "espree": "^10.4.0",
        "esquery": "^1.5.0",
        "esutils": "^2.0.2",
        "fast-deep-equal": "^3.1.3",
        "file-entry-cache": "^8.0.0",
        "find-up": "^5.0.0",
        "glob-parent": "^6.0.2",
        "ignore": "^5.2.0",
        "imurmurhash": "^0.1.4",
        "is-glob": "^4.0.0",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        "lodash.merge": "^4.6.2",
        "minimatch": "^3.1.2",
        "natural-compare": "^1.4.0",
        "optionator": "^0.9.3"
      },
      "bin": {
        "eslint": "bin/eslint.js"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://eslint.org/donate"
      },
      "peerDependencies": {
        "jiti": "*"
      },
      "peerDependenciesMeta": {
        "jiti": {
          "optional": true
        }
      }
    },
    "node_modules/eslint-config-next": {
      "version": "16.1.6",
      "resolved": "https://registry.npmjs.org/eslint-config-next/-/eslint-config-next-16.1.6.tgz",
      "integrity": "sha512-vKq40io2B0XtkkNDYyleATwblNt8xuh3FWp8SpSz3pt7P01OkBFlKsJZ2mWt5WsCySlDQLckb1zMY9yE9Qy0LA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@next/eslint-plugin-next": "16.1.6",
        "eslint-import-resolver-node": "^0.3.6",
        "eslint-import-resolver-typescript": "^3.5.2",
        "eslint-plugin-import": "^2.32.0",
        "eslint-plugin-jsx-a11y": "^6.10.0",
        "eslint-plugin-react": "^7.37.0",
        "eslint-plugin-react-hooks": "^7.0.0",
        "globals": "16.4.0",
        "typescript-eslint": "^8.46.0"
      },
      "peerDependencies": {
        "eslint": ">=9.0.0",
        "typescript": ">=3.3.1"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/eslint-config-next/node_modules/globals": {
      "version": "16.4.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-16.4.0.tgz",
      "integrity": "sha512-ob/2LcVVaVGCYN+r14cnwnoDPUufjiYgSqRhiFD0Q1iI4Odora5RE8Iv1D24hAz5oMophRGkGz+yuvQmmUMnMw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint-import-resolver-node": {
      "version": "0.3.9",
      "resolved": "https://registry.npmjs.org/eslint-import-resolver-node/-/eslint-import-resolver-node-0.3.9.tgz",
      "integrity": "sha512-WFj2isz22JahUv+B788TlO3N6zL3nNJGU8CcZbPZvVEkBPaJdCV4vy5wyghty5ROFbCRnm132v8BScu5/1BQ8g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "debug": "^3.2.7",
        "is-core-module": "^2.13.0",
        "resolve": "^1.22.4"
      }
    },
    "node_modules/eslint-import-resolver-node/node_modules/debug": {
      "version": "3.2.7",
      "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.7.tgz",
      "integrity": "sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.1"
      }
    },
    "node_modules/eslint-import-resolver-typescript": {
      "version": "3.10.1",
      "resolved": "https://registry.npmjs.org/eslint-import-resolver-typescript/-/eslint-import-resolver-typescript-3.10.1.tgz",
      "integrity": "sha512-A1rHYb06zjMGAxdLSkN2fXPBwuSaQ0iO5M/hdyS0Ajj1VBaRp0sPD3dn1FhME3c/JluGFbwSxyCfqdSbtQLAHQ==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "@nolyfill/is-core-module": "1.0.39",
        "debug": "^4.4.0",
        "get-tsconfig": "^4.10.0",
        "is-bun-module": "^2.0.0",
        "stable-hash": "^0.0.5",
        "tinyglobby": "^0.2.13",
        "unrs-resolver": "^1.6.2"
      },
      "engines": {
        "node": "^14.18.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint-import-resolver-typescript"
      },
      "peerDependencies": {
        "eslint": "*",
        "eslint-plugin-import": "*",
        "eslint-plugin-import-x": "*"
      },
      "peerDependenciesMeta": {
        "eslint-plugin-import": {
          "optional": true
        },
        "eslint-plugin-import-x": {
          "optional": true
        }
      }
    },
    "node_modules/eslint-module-utils": {
      "version": "2.12.1",
      "resolved": "https://registry.npmjs.org/eslint-module-utils/-/eslint-module-utils-2.12.1.tgz",
      "integrity": "sha512-L8jSWTze7K2mTg0vos/RuLRS5soomksDPoJLXIslC7c8Wmut3bx7CPpJijDcBZtxQ5lrbUdM+s0OlNbz0DCDNw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "debug": "^3.2.7"
      },
      "engines": {
        "node": ">=4"
      },
      "peerDependenciesMeta": {
        "eslint": {
          "optional": true
        }
      }
    },
    "node_modules/eslint-module-utils/node_modules/debug": {
      "version": "3.2.7",
      "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.7.tgz",
      "integrity": "sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.1"
      }
    },
    "node_modules/eslint-plugin-import": {
      "version": "2.32.0",
      "resolved": "https://registry.npmjs.org/eslint-plugin-import/-/eslint-plugin-import-2.32.0.tgz",
      "integrity": "sha512-whOE1HFo/qJDyX4SnXzP4N6zOWn79WhnCUY/iDR0mPfQZO8wcYE4JClzI2oZrhBnnMUCBCHZhO6VQyoBU95mZA==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "@rtsao/scc": "^1.1.0",
        "array-includes": "^3.1.9",
        "array.prototype.findlastindex": "^1.2.6",
        "array.prototype.flat": "^1.3.3",
        "array.prototype.flatmap": "^1.3.3",
        "debug": "^3.2.7",
        "doctrine": "^2.1.0",
        "eslint-import-resolver-node": "^0.3.9",
        "eslint-module-utils": "^2.12.1",
        "hasown": "^2.0.2",
        "is-core-module": "^2.16.1",
        "is-glob": "^4.0.3",
        "minimatch": "^3.1.2",
        "object.fromentries": "^2.0.8",
        "object.groupby": "^1.0.3",
        "object.values": "^1.2.1",
        "semver": "^6.3.1",
        "string.prototype.trimend": "^1.0.9",
        "tsconfig-paths": "^3.15.0"
      },
      "engines": {
        "node": ">=4"
      },
      "peerDependencies": {
        "eslint": "^2 || ^3 || ^4 || ^5 || ^6 || ^7.2.0 || ^8 || ^9"
      }
    },
    "node_modules/eslint-plugin-import/node_modules/debug": {
      "version": "3.2.7",
      "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.7.tgz",
      "integrity": "sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.1"
      }
    },
    "node_modules/eslint-plugin-jsx-a11y": {
      "version": "6.10.2",
      "resolved": "https://registry.npmjs.org/eslint-plugin-jsx-a11y/-/eslint-plugin-jsx-a11y-6.10.2.tgz",
      "integrity": "sha512-scB3nz4WmG75pV8+3eRUQOHZlNSUhFNq37xnpgRkCCELU3XMvXAxLk1eqWWyE22Ki4Q01Fnsw9BA3cJHDPgn2Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "aria-query": "^5.3.2",
        "array-includes": "^3.1.8",
        "array.prototype.flatmap": "^1.3.2",
        "ast-types-flow": "^0.0.8",
        "axe-core": "^4.10.0",
        "axobject-query": "^4.1.0",
        "damerau-levenshtein": "^1.0.8",
        "emoji-regex": "^9.2.2",
        "hasown": "^2.0.2",
        "jsx-ast-utils": "^3.3.5",
        "language-tags": "^1.0.9",
        "minimatch": "^3.1.2",
        "object.fromentries": "^2.0.8",
        "safe-regex-test": "^1.0.3",
        "string.prototype.includes": "^2.0.1"
      },
      "engines": {
        "node": ">=4.0"
      },
      "peerDependencies": {
        "eslint": "^3 || ^4 || ^5 || ^6 || ^7 || ^8 || ^9"
      }
    },
    "node_modules/eslint-plugin-react": {
      "version": "7.37.5",
      "resolved": "https://registry.npmjs.org/eslint-plugin-react/-/eslint-plugin-react-7.37.5.tgz",
      "integrity": "sha512-Qteup0SqU15kdocexFNAJMvCJEfa2xUKNV4CC1xsVMrIIqEy3SQ/rqyxCWNzfrd3/ldy6HMlD2e0JDVpDg2qIA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "array-includes": "^3.1.8",
        "array.prototype.findlast": "^1.2.5",
        "array.prototype.flatmap": "^1.3.3",
        "array.prototype.tosorted": "^1.1.4",
        "doctrine": "^2.1.0",
        "es-iterator-helpers": "^1.2.1",
        "estraverse": "^5.3.0",
        "hasown": "^2.0.2",
        "jsx-ast-utils": "^2.4.1 || ^3.0.0",
        "minimatch": "^3.1.2",
        "object.entries": "^1.1.9",
        "object.fromentries": "^2.0.8",
        "object.values": "^1.2.1",
        "prop-types": "^15.8.1",
        "resolve": "^2.0.0-next.5",
        "semver": "^6.3.1",
        "string.prototype.matchall": "^4.0.12",
        "string.prototype.repeat": "^1.0.0"
      },
      "engines": {
        "node": ">=4"
      },
      "peerDependencies": {
        "eslint": "^3 || ^4 || ^5 || ^6 || ^7 || ^8 || ^9.7"
      }
    },
    "node_modules/eslint-plugin-react-hooks": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/eslint-plugin-react-hooks/-/eslint-plugin-react-hooks-7.0.1.tgz",
      "integrity": "sha512-O0d0m04evaNzEPoSW+59Mezf8Qt0InfgGIBJnpC0h3NH/WjUAR7BIKUfysC6todmtiZ/A0oUVS8Gce0WhBrHsA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.24.4",
        "@babel/parser": "^7.24.4",
        "hermes-parser": "^0.25.1",
        "zod": "^3.25.0 || ^4.0.0",
        "zod-validation-error": "^3.5.0 || ^4.0.0"
      },
      "engines": {
        "node": ">=18"
      },
      "peerDependencies": {
        "eslint": "^3.0.0 || ^4.0.0 || ^5.0.0 || ^6.0.0 || ^7.0.0 || ^8.0.0-0 || ^9.0.0"
      }
    },
    "node_modules/eslint-plugin-react/node_modules/resolve": {
      "version": "2.0.0-next.6",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-2.0.0-next.6.tgz",
      "integrity": "sha512-3JmVl5hMGtJ3kMmB3zi3DL25KfkCEyy3Tw7Gmw7z5w8M9WlwoPFnIvwChzu1+cF3iaK3sp18hhPz8ANeimdJfA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "is-core-module": "^2.16.1",
        "node-exports-info": "^1.6.0",
        "object-keys": "^1.1.1",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/eslint-scope": {
      "version": "8.4.0",
      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-8.4.0.tgz",
      "integrity": "sha512-sNXOfKCn74rt8RICKMvJS7XKV/Xk9kA7DyJr8mJik3S7Cwgy3qlkkmyS2uQB3jiJg6VNdZd/pDBJu0nvG2NlTg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "esrecurse": "^4.3.0",
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint-visitor-keys": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-4.2.1.tgz",
      "integrity": "sha512-Uhdk5sfqcee/9H/rCOJikYz67o0a2Tw2hGRPOG2Y1R2dg7brRe1uG0yaNQDHu+TO/uQPF/5eCapvYSmHUjt7JQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/espree": {
      "version": "10.4.0",
      "resolved": "https://registry.npmjs.org/espree/-/espree-10.4.0.tgz",
      "integrity": "sha512-j6PAQ2uUr79PZhBjP5C5fhl8e39FmRnOjsD5lGnWrFU8i2G776tBK7+nP8KuQUTTyAZUwfQqXAgrVH5MbH9CYQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "acorn": "^8.15.0",
        "acorn-jsx": "^5.3.2",
        "eslint-visitor-keys": "^4.2.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/esquery": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.7.0.tgz",
      "integrity": "sha512-Ap6G0WQwcU/LHsvLwON1fAQX9Zp0A2Y6Y/cJBl9r/JbW90Zyg4/zbG6zzKa2OTALELarYHmKu0GhpM5EO+7T0g==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "estraverse": "^5.1.0"
      },
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/esrecurse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estraverse": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
      "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estree-walker": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/estree-walker/-/estree-walker-3.0.3.tgz",
      "integrity": "sha512-7RUKfXgSMMkzt6ZuXmqapOurLGPPfgj6l9uRZ7lRGolvk0y2yocc35LdcxKC5PQZdn2DMqioAQ2NoWcrTKmm6g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "^1.0.0"
      }
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/expand-template": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/expand-template/-/expand-template-2.0.3.tgz",
      "integrity": "sha512-XYfuKMvj4O35f/pOXLObndIRvyQ+/+6AhODh+OKWj9S9498pHHn/IMszH+gt0fBCRWMNfk1ZSp5x3AifmnI2vg==",
      "license": "(MIT OR WTFPL)",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/expect-type": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/expect-type/-/expect-type-1.3.0.tgz",
      "integrity": "sha512-knvyeauYhqjOYvQ66MznSMs83wmHrCycNEN6Ao+2AeYEfxUIkuiVxdEa1qlGEPK+We3n0THiDciYSsCcgW/DoA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-glob": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.3.1.tgz",
      "integrity": "sha512-kNFPyjhh5cKjrUltxs+wFx+ZkbRaxxmZ+X0ZU31SOsxCEtP9VPgtq2teZw1DebupL5GmDaNQ6yKMMVcM41iqDg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "^2.0.2",
        "@nodelib/fs.walk": "^1.2.3",
        "glob-parent": "^5.1.2",
        "merge2": "^1.3.0",
        "micromatch": "^4.0.4"
      },
      "engines": {
        "node": ">=8.6.0"
      }
    },
    "node_modules/fast-glob/node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/fast-json-stable-stringify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-levenshtein": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
      "integrity": "sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fastq": {
      "version": "1.20.1",
      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.20.1.tgz",
      "integrity": "sha512-GGToxJ/w1x32s/D2EKND7kTil4n8OVk/9mycTc4VDza13lOvpUZTGX3mFSCtV9ksdGBVzvsyAVLM6mHFThxXxw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "reusify": "^1.0.4"
      }
    },
    "node_modules/file-entry-cache": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-8.0.0.tgz",
      "integrity": "sha512-XXTUwCvisa5oacNGRP9SfNtYBNAMi+RPwBFmblZEF7N7swHYQS6/Zfk7SRwx4D5j3CH211YNRco1DEMNVfZCnQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flat-cache": "^4.0.0"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/file-uri-to-path": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/file-uri-to-path/-/file-uri-to-path-1.0.0.tgz",
      "integrity": "sha512-0Zt+s3L7Vf1biwWZ29aARiVYLx7iMGnEUl9x33fbB/j3jR81u/O2LbqK+Bm1CDSNDKVtJ/YjwY7TUd5SkeLQLw==",
      "license": "MIT"
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/find-up": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
      "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "locate-path": "^6.0.0",
        "path-exists": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/flat-cache": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-4.0.1.tgz",
      "integrity": "sha512-f7ccFPK3SXFHpx15UIGyRJ/FJQctuKZ0zVuN3frBo4HnK3cay9VEW0R6yPYFHC0AgqhukPzKjq22t5DmAyqGyw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flatted": "^3.2.9",
        "keyv": "^4.5.4"
      },
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/flatted": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.3.3.tgz",
      "integrity": "sha512-GX+ysw4PBCz0PzosHDepZGANEuFCMLrnRTiEy9McGjmkCQYwRq4A/X786G/fjM/+OjsWSU1ZrY5qyARZmO/uwg==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/for-each": {
      "version": "0.3.5",
      "resolved": "https://registry.npmjs.org/for-each/-/for-each-0.3.5.tgz",
      "integrity": "sha512-dKx12eRCVIzqCxFGplyFKJMPvLEWgmNtUrpTiJIR5u97zEhRG8ySrtboPHZXx7daLxQVrl643cTzbab2tkQjxg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-callable": "^1.2.7"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/fs-constants": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fs-constants/-/fs-constants-1.0.0.tgz",
      "integrity": "sha512-y6OAwoSIf7FyjMIv94u+b5rdheZEjzR63GTyZJm5qh4Bi+2YgwLCcI/fPFZkL5PSixOt6ZNKm+w+Hfp/Bciwow==",
      "license": "MIT"
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/function.prototype.name": {
      "version": "1.1.8",
      "resolved": "https://registry.npmjs.org/function.prototype.name/-/function.prototype.name-1.1.8.tgz",
      "integrity": "sha512-e5iwyodOHhbMr/yNrc7fDYG4qlbIvI5gajyzPnb5TCwyhjApznQh1BMFou9b30SevY43gCJKXycoCBjMbsuW0Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.3",
        "define-properties": "^1.2.1",
        "functions-have-names": "^1.2.3",
        "hasown": "^2.0.2",
        "is-callable": "^1.2.7"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/functions-have-names": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/functions-have-names/-/functions-have-names-1.2.3.tgz",
      "integrity": "sha512-xckBUXyTIqT97tq2x2AMb+g163b5JFysYk0x4qxNFwbfQkmNZoiRHb6sPzI9/QV33WeuvVYBUIiD4NzNIyqaRQ==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/generator-function": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/generator-function/-/generator-function-2.0.1.tgz",
      "integrity": "sha512-SFdFmIJi+ybC0vjlHN0ZGVGHc3lgE0DxPAT0djjVg+kjOnSqclqmj0KQ7ykTOLP6YxoqOvuAODGdcHJn+43q3g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/gensync": {
      "version": "1.0.0-beta.2",
      "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
      "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/get-symbol-description": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/get-symbol-description/-/get-symbol-description-1.1.0.tgz",
      "integrity": "sha512-w9UMqWwJxHNOvoNzSJ2oPF5wvYcvP7jUvYzhp67yEhTi17ZDBBC1z9pTdGuzjD+EFIqLSYRweZjqfiPzQ06Ebg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-tsconfig": {
      "version": "4.13.6",
      "resolved": "https://registry.npmjs.org/get-tsconfig/-/get-tsconfig-4.13.6.tgz",
      "integrity": "sha512-shZT/QMiSHc/YBLxxOkMtgSid5HFoauqCE3/exfsEcwg1WkeqjG+V40yBbBrsD+jW2HDXcs28xOfcbm2jI8Ddw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "resolve-pkg-maps": "^1.0.0"
      },
      "funding": {
        "url": "https://github.com/privatenumber/get-tsconfig?sponsor=1"
      }
    },
    "node_modules/github-from-package": {
      "version": "0.0.0",
      "resolved": "https://registry.npmjs.org/github-from-package/-/github-from-package-0.0.0.tgz",
      "integrity": "sha512-SyHy3T1v2NUXn29OsWdxmK6RwHD+vkj3v8en8AOBZ1wBQ/hCAQ5bAQTD02kW4W9tUp/3Qh6J8r9EvntiyCmOOw==",
      "license": "MIT"
    },
    "node_modules/glob-parent": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
      "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.3"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/globals": {
      "version": "14.0.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-14.0.0.tgz",
      "integrity": "sha512-oahGvuMGQlPw/ivIYBjVSrWAfWLBeku5tpPE2fOPLi+WHffIWbuh2tCjhyQhTBPMf5E9jDEH4FOmTYgYwbKwtQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/globalthis": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/globalthis/-/globalthis-1.0.4.tgz",
      "integrity": "sha512-DpLKbNU4WylpxJykQujfCcwYWiV/Jhm50Goo0wrVILAv5jOr9d+H+UR3PhSCD2rCCEIg0uc+G+muBTwD54JhDQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "define-properties": "^1.2.1",
        "gopd": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/graceful-fs": {
      "version": "4.2.11",
      "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.11.tgz",
      "integrity": "sha512-RbJ5/jmFcNNCcDV5o9eTnBLJ/HszWV0P73bc+Ff4nS/rJj+YaS6IGyiOL0VoBYX+l1Wrl3k63h/KrH+nhJ0XvQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/has-bigints": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-bigints/-/has-bigints-1.1.0.tgz",
      "integrity": "sha512-R3pbpkcIqv2Pm3dUwgjclDRVmWpTJW2DcMzcIhEXEx1oh/CEMObMm3KLmRJOdvhM7o4uQBnwr8pzRK2sJWIqfg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/has-property-descriptors": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-property-descriptors/-/has-property-descriptors-1.0.2.tgz",
      "integrity": "sha512-55JNKuIW+vq4Ke1BjOTjM2YctQIvCT7GFzHwmfZPGo5wnrgkid0YQtnAleFSqumZm4az3n2BS+erby5ipJdgrg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-define-property": "^1.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-proto": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/has-proto/-/has-proto-1.2.0.tgz",
      "integrity": "sha512-KIL7eQPfHQRC8+XluaIw7BHUwwqL19bQn4hzNgdr+1wXoU0KKj6rufu47lhY7KbJR2C6T6+PfyN0Ea7wkSS+qQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-symbols": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/hermes-estree": {
      "version": "0.25.1",
      "resolved": "https://registry.npmjs.org/hermes-estree/-/hermes-estree-0.25.1.tgz",
      "integrity": "sha512-0wUoCcLp+5Ev5pDW2OriHC2MJCbwLwuRx+gAqMTOkGKJJiBCLjtrvy4PWUGn6MIVefecRpzoOZ/UV6iGdOr+Cw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/hermes-parser": {
      "version": "0.25.1",
      "resolved": "https://registry.npmjs.org/hermes-parser/-/hermes-parser-0.25.1.tgz",
      "integrity": "sha512-6pEjquH3rqaI6cYAXYPcz9MS4rY6R4ngRgrgfDshRptUZIc3lw0MCIJIGDj9++mfySOuPTHB4nrSW99BCvOPIA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hermes-estree": "0.25.1"
      }
    },
    "node_modules/ieee754": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz",
      "integrity": "sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "BSD-3-Clause"
    },
    "node_modules/ignore": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
      "integrity": "sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/import-fresh": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.1.tgz",
      "integrity": "sha512-TR3KfrTZTYLPB6jUjfx6MF9WcWrHL9su5TObK4ZkYgBdWKPOFoSoQIdEuTuR82pmtxH2spWG9h6etwfr1pLBqQ==",
      "license": "MIT",
      "dependencies": {
        "parent-module": "^1.0.0",
        "resolve-from": "^4.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/imurmurhash": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
      "integrity": "sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.8.19"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "license": "ISC"
    },
    "node_modules/ini": {
      "version": "1.3.8",
      "resolved": "https://registry.npmjs.org/ini/-/ini-1.3.8.tgz",
      "integrity": "sha512-JV/yugV2uzW5iMRSiZAyDtQd+nxtUnjeLt0acNdw98kKLrvuRVyB80tsREOE7yvGVgalhZ6RNXCmEHkUKBKxew==",
      "license": "ISC"
    },
    "node_modules/internal-slot": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/internal-slot/-/internal-slot-1.1.0.tgz",
      "integrity": "sha512-4gd7VpWNQNB4UKKCFFVcp1AVv+FMOgs9NKzjHKusc8jTMhd5eL1NqQqOpE0KzMds804/yHlglp3uxgluOqAPLw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "hasown": "^2.0.2",
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/is-array-buffer": {
      "version": "3.0.5",
      "resolved": "https://registry.npmjs.org/is-array-buffer/-/is-array-buffer-3.0.5.tgz",
      "integrity": "sha512-DDfANUiiG2wC1qawP66qlTugJeL5HyzMpfr8lLK+jMQirGzNod0B12cFB/9q838Ru27sBwfw78/rdoU7RERz6A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.3",
        "get-intrinsic": "^1.2.6"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-arrayish": {
      "version": "0.2.1",
      "resolved": "https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.2.1.tgz",
      "integrity": "sha512-zz06S8t0ozoDXMG+ube26zeCTNXcKIPJZJi8hBrF4idCLms4CG9QtK7qBl1boi5ODzFpjswb5JPmHCbMpjaYzg==",
      "license": "MIT"
    },
    "node_modules/is-async-function": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-async-function/-/is-async-function-2.1.1.tgz",
      "integrity": "sha512-9dgM/cZBnNvjzaMYHVoxxfPj2QXt22Ev7SuuPrs+xav0ukGB0S6d4ydZdEiM48kLx5kDV+QBPrpVnFyefL8kkQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "async-function": "^1.0.0",
        "call-bound": "^1.0.3",
        "get-proto": "^1.0.1",
        "has-tostringtag": "^1.0.2",
        "safe-regex-test": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-bigint": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/is-bigint/-/is-bigint-1.1.0.tgz",
      "integrity": "sha512-n4ZT37wG78iz03xPRKJrHTdZbe3IicyucEtdRsV5yglwc3GyUfbAfpSeD0FJ41NbUNSt5wbhqfp1fS+BgnvDFQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-bigints": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-boolean-object": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/is-boolean-object/-/is-boolean-object-1.2.2.tgz",
      "integrity": "sha512-wa56o2/ElJMYqjCjGkXri7it5FbebW5usLw/nPmCMs5DeZ7eziSYZhSmPRn0txqeW4LnAmQQU7FgqLpsEFKM4A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "has-tostringtag": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-bun-module": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-bun-module/-/is-bun-module-2.0.0.tgz",
      "integrity": "sha512-gNCGbnnnnFAUGKeZ9PdbyeGYJqewpmc2aKHUEMO5nQPWU9lOmv7jcmQIv+qHD8fXW6W7qfuCwX4rY9LNRjXrkQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "semver": "^7.7.1"
      }
    },
    "node_modules/is-bun-module/node_modules/semver": {
      "version": "7.7.4",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.4.tgz",
      "integrity": "sha512-vFKC2IEtQnVhpT78h1Yp8wzwrf8CM+MzKMHGJZfBtzhZNycRFnXsHk6E5TxIkkMsgNS7mdX3AGB7x2QM2di4lA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/is-callable": {
      "version": "1.2.7",
      "resolved": "https://registry.npmjs.org/is-callable/-/is-callable-1.2.7.tgz",
      "integrity": "sha512-1BC0BVFhS/p0qtw6enp8e+8OD0UrK0oFLztSjNzhcKA3WDuJxxAPXzPuPtKkjEY9UUoEWlX/8fgKeu2S8i9JTA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-core-module": {
      "version": "2.16.1",
      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.16.1.tgz",
      "integrity": "sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-data-view": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/is-data-view/-/is-data-view-1.0.2.tgz",
      "integrity": "sha512-RKtWF8pGmS87i2D6gqQu/l7EYRlVdfzemCJN/P3UOs//x1QE7mfhvzHIApBTRf7axvT6DMGwSwBXYCT0nfB9xw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "get-intrinsic": "^1.2.6",
        "is-typed-array": "^1.1.13"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-date-object": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/is-date-object/-/is-date-object-1.1.0.tgz",
      "integrity": "sha512-PwwhEakHVKTdRNVOw+/Gyh0+MzlCl4R6qKvkhuvLtPMggI1WAHt9sOwZxQLSGpUaDnrdyDsomoRgNnCfKNSXXg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "has-tostringtag": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-finalizationregistry": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-finalizationregistry/-/is-finalizationregistry-1.1.1.tgz",
      "integrity": "sha512-1pC6N8qWJbWoPtEjgcL2xyhQOP491EQjeUo3qTKcmV8YSDDJrOepfG8pcC7h/QgnQHYSv0mJ3Z/ZWxmatVrysg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-generator-function": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/is-generator-function/-/is-generator-function-1.1.2.tgz",
      "integrity": "sha512-upqt1SkGkODW9tsGNG5mtXTXtECizwtS2kA161M+gJPc1xdb/Ax629af6YrTwcOeQHbewrPNlE5Dx7kzvXTizA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.4",
        "generator-function": "^2.0.0",
        "get-proto": "^1.0.1",
        "has-tostringtag": "^1.0.2",
        "safe-regex-test": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-map": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/is-map/-/is-map-2.0.3.tgz",
      "integrity": "sha512-1Qed0/Hr2m+YqxnM09CjA2d/i6YZNfF6R2oRAOj36eUdS6qIV/huPJNSEpKbupewFs+ZsJlxsjjPbc0/afW6Lw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-negative-zero": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/is-negative-zero/-/is-negative-zero-2.0.3.tgz",
      "integrity": "sha512-5KoIu2Ngpyek75jXodFvnafB6DJgr3u8uuK0LEZJjrU19DrMD3EVERaR8sjz8CCGgpZvxPl9SuE1GMVPFHx1mw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/is-number-object": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-number-object/-/is-number-object-1.1.1.tgz",
      "integrity": "sha512-lZhclumE1G6VYD8VHe35wFaIif+CTy5SJIi5+3y4psDgWu4wPDoBhF8NxUOinEc7pHgiTsT6MaBb92rKhhD+Xw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "has-tostringtag": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-regex": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/is-regex/-/is-regex-1.2.1.tgz",
      "integrity": "sha512-MjYsKHO5O7mCsmRGxWcLWheFqN9DJ/2TmngvjKXihe6efViPqc274+Fx/4fYj/r03+ESvBdTXK0V6tA3rgez1g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "gopd": "^1.2.0",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-set": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/is-set/-/is-set-2.0.3.tgz",
      "integrity": "sha512-iPAjerrse27/ygGLxw+EBR9agv9Y6uLeYVJMu+QNCoouJ1/1ri0mGrcWpfCqFZuzzx3WjtwxG098X+n4OuRkPg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-shared-array-buffer": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/is-shared-array-buffer/-/is-shared-array-buffer-1.0.4.tgz",
      "integrity": "sha512-ISWac8drv4ZGfwKl5slpHG9OwPNty4jOWPRIhBpxOoD+hqITiwuipOQ2bNthAzwA3B4fIjO4Nln74N0S9byq8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-string": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-string/-/is-string-1.1.1.tgz",
      "integrity": "sha512-BtEeSsoaQjlSPBemMQIrY1MY0uM6vnS1g5fmufYOtnxLGUZM2178PKbhsk7Ffv58IX+ZtcvoGwccYsh0PglkAA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "has-tostringtag": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-symbol": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-symbol/-/is-symbol-1.1.1.tgz",
      "integrity": "sha512-9gGx6GTtCQM73BgmHQXfDmLtfjjTUDSyoxTCbp5WtoixAhfgsDirWIcVQ/IHpvI5Vgd5i/J5F7B9cN/WlVbC/w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "has-symbols": "^1.1.0",
        "safe-regex-test": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-typed-array": {
      "version": "1.1.15",
      "resolved": "https://registry.npmjs.org/is-typed-array/-/is-typed-array-1.1.15.tgz",
      "integrity": "sha512-p3EcsicXjit7SaskXHs1hA91QxgTw46Fv6EFKKGS5DRFLD8yKnohjF3hxoju94b/OcMZoQukzpPpBE9uLVKzgQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "which-typed-array": "^1.1.16"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-weakmap": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/is-weakmap/-/is-weakmap-2.0.2.tgz",
      "integrity": "sha512-K5pXYOm9wqY1RgjpL3YTkF39tni1XajUIkawTLUo9EZEVUFga5gSQJF8nNS7ZwJQ02y+1YCNYcMh+HIf1ZqE+w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-weakref": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-weakref/-/is-weakref-1.1.1.tgz",
      "integrity": "sha512-6i9mGWSlqzNMEqpCp93KwRS1uUOodk2OJ6b+sq7ZPDSy2WuI5NFIxp/254TytR8ftefexkWn5xNiHUNpPOfSew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-weakset": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/is-weakset/-/is-weakset-2.0.4.tgz",
      "integrity": "sha512-mfcwb6IzQyOKTs84CQMrOwW4gQcaTOAWJ0zzJCl2WSPDrWk/OzDaImWFH3djXhb24g4eudZfLRozAvPGw4d9hQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "get-intrinsic": "^1.2.6"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/isarray": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/isarray/-/isarray-2.0.5.tgz",
      "integrity": "sha512-xHjhDr3cNBK0BzdUJSPXZntQUx/mwMS5Rw4A7lPJ90XGAO6ISP/ePDNuo0vhqOZU+UD5JoodwCAAoZQd3FeAKw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/iterator.prototype": {
      "version": "1.1.5",
      "resolved": "https://registry.npmjs.org/iterator.prototype/-/iterator.prototype-1.1.5.tgz",
      "integrity": "sha512-H0dkQoCa3b2VEeKQBOxFph+JAbcrQdE7KC0UkqwpLmv2EC4P41QXP+rqo9wYodACiG5/WM5s9oDApTU8utwj9g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "define-data-property": "^1.1.4",
        "es-object-atoms": "^1.0.0",
        "get-intrinsic": "^1.2.6",
        "get-proto": "^1.0.0",
        "has-symbols": "^1.1.0",
        "set-function-name": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/jiti": {
      "version": "2.6.1",
      "resolved": "https://registry.npmjs.org/jiti/-/jiti-2.6.1.tgz",
      "integrity": "sha512-ekilCSN1jwRvIbgeg/57YFh8qQDNbwDb9xT/qu2DAHbFFZUicIl4ygVaAvzveMhMVr3LnpSKTNnwt8PoOfmKhQ==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "jiti": "lib/jiti-cli.mjs"
      }
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "license": "MIT"
    },
    "node_modules/js-yaml": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
      "integrity": "sha512-qQKT4zQxXl8lLwBtHMWwaTcGfFOZviOJet3Oy/xmGk2gZH677CJM9EvtfdSkgWcATZhj/55JZ0rmy3myCT5lsA==",
      "license": "MIT",
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/jsesc": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-3.1.0.tgz",
      "integrity": "sha512-/sM3dO2FOzXjKQhJuo0Q173wf2KOo8t4I8vHy6lF9poUp7bKT0/NHE8fPX23PwfhnykfqnC2xRxOnVw5XuGIaA==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "jsesc": "bin/jsesc"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/json-buffer": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/json-buffer/-/json-buffer-3.0.1.tgz",
      "integrity": "sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-parse-even-better-errors": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/json-parse-even-better-errors/-/json-parse-even-better-errors-2.3.1.tgz",
      "integrity": "sha512-xyFwyhro/JEof6Ghe2iz2NcXoj2sloNsWr/XsERDK/oiPCfaNhl5ONfp+jQdAZRQQ0IJWNzH9zIZF7li91kh2w==",
      "license": "MIT"
    },
    "node_modules/json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-stable-stringify-without-jsonify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
      "integrity": "sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json5": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz",
      "integrity": "sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "json5": "lib/cli.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/jsx-ast-utils": {
      "version": "3.3.5",
      "resolved": "https://registry.npmjs.org/jsx-ast-utils/-/jsx-ast-utils-3.3.5.tgz",
      "integrity": "sha512-ZZow9HBI5O6EPgSJLUb8n2NKgmVWTwCvHGwFuJlMjvLFqlGG6pjirPhtdsseaLZjSibD8eegzmYpUZwoIlj2cQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "array-includes": "^3.1.6",
        "array.prototype.flat": "^1.3.1",
        "object.assign": "^4.1.4",
        "object.values": "^1.1.6"
      },
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/keyv": {
      "version": "4.5.4",
      "resolved": "https://registry.npmjs.org/keyv/-/keyv-4.5.4.tgz",
      "integrity": "sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "json-buffer": "3.0.1"
      }
    },
    "node_modules/language-subtag-registry": {
      "version": "0.3.23",
      "resolved": "https://registry.npmjs.org/language-subtag-registry/-/language-subtag-registry-0.3.23.tgz",
      "integrity": "sha512-0K65Lea881pHotoGEa5gDlMxt3pctLi2RplBb7Ezh4rRdLEOtgi7n4EwK9lamnUCkKBqaeKRVebTq6BAxSkpXQ==",
      "dev": true,
      "license": "CC0-1.0"
    },
    "node_modules/language-tags": {
      "version": "1.0.9",
      "resolved": "https://registry.npmjs.org/language-tags/-/language-tags-1.0.9.tgz",
      "integrity": "sha512-MbjN408fEndfiQXbFQ1vnd+1NoLDsnQW41410oQBXiyXDMYH5z505juWa4KUE1LqxRC7DgOgZDbKLxHIwm27hA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "language-subtag-registry": "^0.3.20"
      },
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/levn": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1",
        "type-check": "~0.4.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/lightningcss": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss/-/lightningcss-1.30.2.tgz",
      "integrity": "sha512-utfs7Pr5uJyyvDETitgsaqSyjCb2qNRAtuqUeWIAKztsOYdcACf2KtARYXg2pSvhkt+9NfoaNY7fxjl6nuMjIQ==",
      "dev": true,
      "license": "MPL-2.0",
      "dependencies": {
        "detect-libc": "^2.0.3"
      },
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      },
      "optionalDependencies": {
        "lightningcss-android-arm64": "1.30.2",
        "lightningcss-darwin-arm64": "1.30.2",
        "lightningcss-darwin-x64": "1.30.2",
        "lightningcss-freebsd-x64": "1.30.2",
        "lightningcss-linux-arm-gnueabihf": "1.30.2",
        "lightningcss-linux-arm64-gnu": "1.30.2",
        "lightningcss-linux-arm64-musl": "1.30.2",
        "lightningcss-linux-x64-gnu": "1.30.2",
        "lightningcss-linux-x64-musl": "1.30.2",
        "lightningcss-win32-arm64-msvc": "1.30.2",
        "lightningcss-win32-x64-msvc": "1.30.2"
      }
    },
    "node_modules/lightningcss-android-arm64": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-android-arm64/-/lightningcss-android-arm64-1.30.2.tgz",
      "integrity": "sha512-BH9sEdOCahSgmkVhBLeU7Hc9DWeZ1Eb6wNS6Da8igvUwAe0sqROHddIlvU06q3WyXVEOYDZ6ykBZQnjTbmo4+A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-darwin-arm64": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-darwin-arm64/-/lightningcss-darwin-arm64-1.30.2.tgz",
      "integrity": "sha512-ylTcDJBN3Hp21TdhRT5zBOIi73P6/W0qwvlFEk22fkdXchtNTOU4Qc37SkzV+EKYxLouZ6M4LG9NfZ1qkhhBWA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-darwin-x64": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-darwin-x64/-/lightningcss-darwin-x64-1.30.2.tgz",
      "integrity": "sha512-oBZgKchomuDYxr7ilwLcyms6BCyLn0z8J0+ZZmfpjwg9fRVZIR5/GMXd7r9RH94iDhld3UmSjBM6nXWM2TfZTQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-freebsd-x64": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-freebsd-x64/-/lightningcss-freebsd-x64-1.30.2.tgz",
      "integrity": "sha512-c2bH6xTrf4BDpK8MoGG4Bd6zAMZDAXS569UxCAGcA7IKbHNMlhGQ89eRmvpIUGfKWNVdbhSbkQaWhEoMGmGslA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-arm-gnueabihf": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-arm-gnueabihf/-/lightningcss-linux-arm-gnueabihf-1.30.2.tgz",
      "integrity": "sha512-eVdpxh4wYcm0PofJIZVuYuLiqBIakQ9uFZmipf6LF/HRj5Bgm0eb3qL/mr1smyXIS1twwOxNWndd8z0E374hiA==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-arm64-gnu": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-arm64-gnu/-/lightningcss-linux-arm64-gnu-1.30.2.tgz",
      "integrity": "sha512-UK65WJAbwIJbiBFXpxrbTNArtfuznvxAJw4Q2ZGlU8kPeDIWEX1dg3rn2veBVUylA2Ezg89ktszWbaQnxD/e3A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-arm64-musl": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-arm64-musl/-/lightningcss-linux-arm64-musl-1.30.2.tgz",
      "integrity": "sha512-5Vh9dGeblpTxWHpOx8iauV02popZDsCYMPIgiuw97OJ5uaDsL86cnqSFs5LZkG3ghHoX5isLgWzMs+eD1YzrnA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-x64-gnu": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-x64-gnu/-/lightningcss-linux-x64-gnu-1.30.2.tgz",
      "integrity": "sha512-Cfd46gdmj1vQ+lR6VRTTadNHu6ALuw2pKR9lYq4FnhvgBc4zWY1EtZcAc6EffShbb1MFrIPfLDXD6Xprbnni4w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-x64-musl": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-x64-musl/-/lightningcss-linux-x64-musl-1.30.2.tgz",
      "integrity": "sha512-XJaLUUFXb6/QG2lGIW6aIk6jKdtjtcffUT0NKvIqhSBY3hh9Ch+1LCeH80dR9q9LBjG3ewbDjnumefsLsP6aiA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-win32-arm64-msvc": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-win32-arm64-msvc/-/lightningcss-win32-arm64-msvc-1.30.2.tgz",
      "integrity": "sha512-FZn+vaj7zLv//D/192WFFVA0RgHawIcHqLX9xuWiQt7P0PtdFEVaxgF9rjM/IRYHQXNnk61/H/gb2Ei+kUQ4xQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-win32-x64-msvc": {
      "version": "1.30.2",
      "resolved": "https://registry.npmjs.org/lightningcss-win32-x64-msvc/-/lightningcss-win32-x64-msvc-1.30.2.tgz",
      "integrity": "sha512-5g1yc73p+iAkid5phb4oVFMB45417DkRevRbt/El/gKXJk4jid+vPFF/AXbxn05Aky8PapwzZrdJShv5C0avjw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lines-and-columns": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.2.4.tgz",
      "integrity": "sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==",
      "license": "MIT"
    },
    "node_modules/locate-path": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
      "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-locate": "^5.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/lodash.merge": {
      "version": "4.6.2",
      "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
      "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/loose-envify": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz",
      "integrity": "sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "js-tokens": "^3.0.0 || ^4.0.0"
      },
      "bin": {
        "loose-envify": "cli.js"
      }
    },
    "node_modules/lru-cache": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
      "integrity": "sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "yallist": "^3.0.2"
      }
    },
    "node_modules/magic-string": {
      "version": "0.30.21",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
      "integrity": "sha512-vd2F4YUyEXKGcLHoq+TEyCjxueSeHnFxyyjNp80yg0XV4vUhnDer/lvvlqM/arB5bXQN5K2/3oinyCRyx8T2CQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.5"
      }
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/merge2": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/micromatch": {
      "version": "4.0.8",
      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz",
      "integrity": "sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "braces": "^3.0.3",
        "picomatch": "^2.3.1"
      },
      "engines": {
        "node": ">=8.6"
      }
    },
    "node_modules/mimic-response": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/mimic-response/-/mimic-response-3.1.0.tgz",
      "integrity": "sha512-z0yWI+4FDrrweS8Zmt4Ej5HdJmky15+L2e6Wgn3+iK5fWzb6T3fhNFq2+MeTRb064c6Wr4N/wv0DzQTjNzHNGQ==",
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/minimist": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.8.tgz",
      "integrity": "sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/mkdirp-classic": {
      "version": "0.5.3",
      "resolved": "https://registry.npmjs.org/mkdirp-classic/-/mkdirp-classic-0.5.3.tgz",
      "integrity": "sha512-gKLcREMhtuZRwRAfqP3RFW+TK4JqApVBtOIftVgjuABpAtpxhPGaDcfvbhNvD0B8iD1oUr/txX35NjcaY6Ns/A==",
      "license": "MIT"
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/napi-build-utils": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/napi-build-utils/-/napi-build-utils-2.0.0.tgz",
      "integrity": "sha512-GEbrYkbfF7MoNaoh2iGG84Mnf/WZfB0GdGEsM8wz7Expx/LlWf5U8t9nvJKXSp3qr5IsEbK04cBGhol/KwOsWA==",
      "license": "MIT"
    },
    "node_modules/napi-postinstall": {
      "version": "0.3.4",
      "resolved": "https://registry.npmjs.org/napi-postinstall/-/napi-postinstall-0.3.4.tgz",
      "integrity": "sha512-PHI5f1O0EP5xJ9gQmFGMS6IZcrVvTjpXjz7Na41gTE7eE2hK11lg04CECCYEEjdc17EV4DO+fkGEtt7TpTaTiQ==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "napi-postinstall": "lib/cli.js"
      },
      "engines": {
        "node": "^12.20.0 || ^14.18.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/napi-postinstall"
      }
    },
    "node_modules/natural-compare": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
      "integrity": "sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/next": {
      "version": "16.1.6",
      "resolved": "https://registry.npmjs.org/next/-/next-16.1.6.tgz",
      "integrity": "sha512-hkyRkcu5x/41KoqnROkfTm2pZVbKxvbZRuNvKXLRXxs3VfyO0WhY50TQS40EuKO9SW3rBj/sF3WbVwDACeMZyw==",
      "license": "MIT",
      "dependencies": {
        "@next/env": "16.1.6",
        "@swc/helpers": "0.5.15",
        "baseline-browser-mapping": "^2.8.3",
        "caniuse-lite": "^1.0.30001579",
        "postcss": "8.4.31",
        "styled-jsx": "5.1.6"
      },
      "bin": {
        "next": "dist/bin/next"
      },
      "engines": {
        "node": ">=20.9.0"
      },
      "optionalDependencies": {
        "@next/swc-darwin-arm64": "16.1.6",
        "@next/swc-darwin-x64": "16.1.6",
        "@next/swc-linux-arm64-gnu": "16.1.6",
        "@next/swc-linux-arm64-musl": "16.1.6",
        "@next/swc-linux-x64-gnu": "16.1.6",
        "@next/swc-linux-x64-musl": "16.1.6",
        "@next/swc-win32-arm64-msvc": "16.1.6",
        "@next/swc-win32-x64-msvc": "16.1.6",
        "sharp": "^0.34.4"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.1.0",
        "@playwright/test": "^1.51.1",
        "babel-plugin-react-compiler": "*",
        "react": "^18.2.0 || 19.0.0-rc-de68d2f4-20241204 || ^19.0.0",
        "react-dom": "^18.2.0 || 19.0.0-rc-de68d2f4-20241204 || ^19.0.0",
        "sass": "^1.3.0"
      },
      "peerDependenciesMeta": {
        "@opentelemetry/api": {
          "optional": true
        },
        "@playwright/test": {
          "optional": true
        },
        "babel-plugin-react-compiler": {
          "optional": true
        },
        "sass": {
          "optional": true
        }
      }
    },
    "node_modules/next/node_modules/postcss": {
      "version": "8.4.31",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.4.31.tgz",
      "integrity": "sha512-PS08Iboia9mts/2ygV3eLpY5ghnUcfLV/EXTOW1E2qYxJKGGBUtNjN76FYHnMs36RmARn41bC0AZmn+rR0OVpQ==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.6",
        "picocolors": "^1.0.0",
        "source-map-js": "^1.0.2"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/node-abi": {
      "version": "3.87.0",
      "resolved": "https://registry.npmjs.org/node-abi/-/node-abi-3.87.0.tgz",
      "integrity": "sha512-+CGM1L1CgmtheLcBuleyYOn7NWPVu0s0EJH2C4puxgEZb9h8QpR9G2dBfZJOAUhi7VQxuBPMd0hiISWcTyiYyQ==",
      "license": "MIT",
      "dependencies": {
        "semver": "^7.3.5"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/node-abi/node_modules/semver": {
      "version": "7.7.4",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.4.tgz",
      "integrity": "sha512-vFKC2IEtQnVhpT78h1Yp8wzwrf8CM+MzKMHGJZfBtzhZNycRFnXsHk6E5TxIkkMsgNS7mdX3AGB7x2QM2di4lA==",
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/node-exports-info": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/node-exports-info/-/node-exports-info-1.6.0.tgz",
      "integrity": "sha512-pyFS63ptit/P5WqUkt+UUfe+4oevH+bFeIiPPdfb0pFeYEu/1ELnJu5l+5EcTKYL5M7zaAa7S8ddywgXypqKCw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "array.prototype.flatmap": "^1.3.3",
        "es-errors": "^1.3.0",
        "object.entries": "^1.1.9",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/node-releases": {
      "version": "2.0.27",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.27.tgz",
      "integrity": "sha512-nmh3lCkYZ3grZvqcCH+fjmQ7X+H0OeZgP40OierEaAptX4XofMh5kwNbWh7lBduUzCcV/8kZ+NDLCwm2iorIlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/object-keys": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/object-keys/-/object-keys-1.1.1.tgz",
      "integrity": "sha512-NuAESUOUMrlIXOfHKzD6bpPu3tYt3xvjNdRIQ+FeT0lNb4K8WR70CaDxhuNguS2XG+GjkyMwOzsN5ZktImfhLA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/object.assign": {
      "version": "4.1.7",
      "resolved": "https://registry.npmjs.org/object.assign/-/object.assign-4.1.7.tgz",
      "integrity": "sha512-nK28WOo+QIjBkDduTINE4JkF/UJJKyf2EJxvJKfblDpyg0Q+pkOHNTL0Qwy6NP6FhE/EnzV73BxxqcJaXY9anw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.3",
        "define-properties": "^1.2.1",
        "es-object-atoms": "^1.0.0",
        "has-symbols": "^1.1.0",
        "object-keys": "^1.1.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/object.entries": {
      "version": "1.1.9",
      "resolved": "https://registry.npmjs.org/object.entries/-/object.entries-1.1.9.tgz",
      "integrity": "sha512-8u/hfXFRBD1O0hPUjioLhoWFHRmt6tKA4/vZPyckBr18l1KE9uHrFaFaUi8MDRTpi4uak2goyPTSNJLXX2k2Hw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.4",
        "define-properties": "^1.2.1",
        "es-object-atoms": "^1.1.1"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/object.fromentries": {
      "version": "2.0.8",
      "resolved": "https://registry.npmjs.org/object.fromentries/-/object.fromentries-2.0.8.tgz",
      "integrity": "sha512-k6E21FzySsSK5a21KRADBd/NGneRegFO5pLHfdQLpRDETUNJueLXs3WCzyQ3tFRDYgbq3KHGXfTbi2bs8WQ6rQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.7",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.2",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/object.groupby": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/object.groupby/-/object.groupby-1.0.3.tgz",
      "integrity": "sha512-+Lhy3TQTuzXI5hevh8sBGqbmurHbbIjAi0Z4S63nthVLmLxfbj4T54a4CfZrXIrt9iP4mVAPYMo/v99taj3wjQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.7",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/object.values": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/object.values/-/object.values-1.2.1.tgz",
      "integrity": "sha512-gXah6aZrcUxjWg2zR2MwouP2eHlCBzdV4pygudehaKXSGW4v2AsRQUK+lwwXhii6KFZcunEnmSUoYp5CXibxtA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.3",
        "define-properties": "^1.2.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/obug": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/obug/-/obug-2.1.1.tgz",
      "integrity": "sha512-uTqF9MuPraAQ+IsnPf366RG4cP9RtUi7MLO1N3KEc+wb0a6yKpeL0lmk2IB1jY5KHPAlTc6T/JRdC/YqxHNwkQ==",
      "dev": true,
      "funding": [
        "https://github.com/sponsors/sxzz",
        "https://opencollective.com/debug"
      ],
      "license": "MIT"
    },
    "node_modules/on-exit-leak-free": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/on-exit-leak-free/-/on-exit-leak-free-2.1.2.tgz",
      "integrity": "sha512-0eJJY6hXLGf1udHwfNftBqH+g73EU4B504nZeKpz1sYRKafAghwxEJunB2O7rDZkL4PGfsMVnTXZ2EjibbqcsA==",
      "license": "MIT",
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/optionator": {
      "version": "0.9.4",
      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.4.tgz",
      "integrity": "sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "deep-is": "^0.1.3",
        "fast-levenshtein": "^2.0.6",
        "levn": "^0.4.1",
        "prelude-ls": "^1.2.1",
        "type-check": "^0.4.0",
        "word-wrap": "^1.2.5"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/own-keys": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/own-keys/-/own-keys-1.0.1.tgz",
      "integrity": "sha512-qFOyK5PjiWZd+QQIh+1jhdb9LpxTF0qs7Pm8o5QHYZ0M3vKqSqzsZaEB6oWlxZ+q2sJBMI/Ktgd2N5ZwQoRHfg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "get-intrinsic": "^1.2.6",
        "object-keys": "^1.1.1",
        "safe-push-apply": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/p-limit": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
      "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "yocto-queue": "^0.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-locate": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
      "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-limit": "^3.0.2"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "license": "MIT",
      "dependencies": {
        "callsites": "^3.0.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/parse-json": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/parse-json/-/parse-json-5.2.0.tgz",
      "integrity": "sha512-ayCKvm/phCGxOkYRSCM82iDwct8/EonSEgCSxWxD7ve6jHggsFl4fZVQBPRNgQoKiuV/odhFrGzQXZwbifC8Rg==",
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.0.0",
        "error-ex": "^1.3.1",
        "json-parse-even-better-errors": "^2.3.0",
        "lines-and-columns": "^1.1.6"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/path-exists": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
      "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-parse": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/pathe": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/pathe/-/pathe-2.0.3.tgz",
      "integrity": "sha512-WUjGcAqP1gQacoQe+OBJsFA7Ld4DyXuUIjZ5cc75cLHvJ7dtNsTugphxIADwspS+AraAUePCKrSVtPLFj/F88w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "license": "ISC"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/pino": {
      "version": "10.3.1",
      "resolved": "https://registry.npmjs.org/pino/-/pino-10.3.1.tgz",
      "integrity": "sha512-r34yH/GlQpKZbU1BvFFqOjhISRo1MNx1tWYsYvmj6KIRHSPMT2+yHOEb1SG6NMvRoHRF0a07kCOox/9yakl1vg==",
      "license": "MIT",
      "dependencies": {
        "@pinojs/redact": "^0.4.0",
        "atomic-sleep": "^1.0.0",
        "on-exit-leak-free": "^2.1.0",
        "pino-abstract-transport": "^3.0.0",
        "pino-std-serializers": "^7.0.0",
        "process-warning": "^5.0.0",
        "quick-format-unescaped": "^4.0.3",
        "real-require": "^0.2.0",
        "safe-stable-stringify": "^2.3.1",
        "sonic-boom": "^4.0.1",
        "thread-stream": "^4.0.0"
      },
      "bin": {
        "pino": "bin.js"
      }
    },
    "node_modules/pino-abstract-transport": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/pino-abstract-transport/-/pino-abstract-transport-3.0.0.tgz",
      "integrity": "sha512-wlfUczU+n7Hy/Ha5j9a/gZNy7We5+cXp8YL+X+PG8S0KXxw7n/JXA3c46Y0zQznIJ83URJiwy7Lh56WLokNuxg==",
      "license": "MIT",
      "dependencies": {
        "split2": "^4.0.0"
      }
    },
    "node_modules/pino-std-serializers": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/pino-std-serializers/-/pino-std-serializers-7.1.0.tgz",
      "integrity": "sha512-BndPH67/JxGExRgiX1dX0w1FvZck5Wa4aal9198SrRhZjH3GxKQUKIBnYJTdj2HDN3UQAS06HlfcSbQj2OHmaw==",
      "license": "MIT"
    },
    "node_modules/playwright": {
      "version": "1.58.2",
      "resolved": "https://registry.npmjs.org/playwright/-/playwright-1.58.2.tgz",
      "integrity": "sha512-vA30H8Nvkq/cPBnNw4Q8TWz1EJyqgpuinBcHET0YVJVFldr8JDNiU9LaWAE1KqSkRYazuaBhTpB5ZzShOezQ6A==",
      "devOptional": true,
      "license": "Apache-2.0",
      "dependencies": {
        "playwright-core": "1.58.2"
      },
      "bin": {
        "playwright": "cli.js"
      },
      "engines": {
        "node": ">=18"
      },
      "optionalDependencies": {
        "fsevents": "2.3.2"
      }
    },
    "node_modules/playwright-core": {
      "version": "1.58.2",
      "resolved": "https://registry.npmjs.org/playwright-core/-/playwright-core-1.58.2.tgz",
      "integrity": "sha512-yZkEtftgwS8CsfYo7nm0KE8jsvm6i/PTgVtB8DL726wNf6H2IMsDuxCpJj59KDaxCtSnrWan2AeDqM7JBaultg==",
      "devOptional": true,
      "license": "Apache-2.0",
      "bin": {
        "playwright-core": "cli.js"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/playwright/node_modules/fsevents": {
      "version": "2.3.2",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.2.tgz",
      "integrity": "sha512-xiqMQR4xAeHTuB9uWm+fFRcIOgKBMiOBP+eXiyT7jsgVCq1bkVygt00oASowB7EdtpOHaaPgKt812P9ab+DDKA==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/possible-typed-array-names": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/possible-typed-array-names/-/possible-typed-array-names-1.1.0.tgz",
      "integrity": "sha512-/+5VFTchJDoVj3bhoqi6UeymcD00DAwb1nJwamzPvHEszJ4FpF6SNNbUbOS8yI56qHzdV8eK0qEfOSiodkTdxg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz",
      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/prebuild-install": {
      "version": "7.1.3",
      "resolved": "https://registry.npmjs.org/prebuild-install/-/prebuild-install-7.1.3.tgz",
      "integrity": "sha512-8Mf2cbV7x1cXPUILADGI3wuhfqWvtiLA1iclTDbFRZkgRQS0NqsPZphna9V+HyTEadheuPmjaJMsbzKQFOzLug==",
      "license": "MIT",
      "dependencies": {
        "detect-libc": "^2.0.0",
        "expand-template": "^2.0.3",
        "github-from-package": "0.0.0",
        "minimist": "^1.2.3",
        "mkdirp-classic": "^0.5.3",
        "napi-build-utils": "^2.0.0",
        "node-abi": "^3.3.0",
        "pump": "^3.0.0",
        "rc": "^1.2.7",
        "simple-get": "^4.0.0",
        "tar-fs": "^2.0.0",
        "tunnel-agent": "^0.6.0"
      },
      "bin": {
        "prebuild-install": "bin.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/prelude-ls": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/process-warning": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/process-warning/-/process-warning-5.0.0.tgz",
      "integrity": "sha512-a39t9ApHNx2L4+HBnQKqxxHNs1r7KF+Intd8Q/g1bUh6q0WIp9voPXJ/x0j+ZL45KF1pJd9+q2jLIRMfvEshkA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/fastify"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/fastify"
        }
      ],
      "license": "MIT"
    },
    "node_modules/prop-types": {
      "version": "15.8.1",
      "resolved": "https://registry.npmjs.org/prop-types/-/prop-types-15.8.1.tgz",
      "integrity": "sha512-oj87CgZICdulUohogVAR7AjlC0327U4el4L6eAvOqCeudMDVU0NThNaV+b9Df4dXgSP1gXMTnPdhfe/2qDH5cg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "loose-envify": "^1.4.0",
        "object-assign": "^4.1.1",
        "react-is": "^16.13.1"
      }
    },
    "node_modules/pump": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/pump/-/pump-3.0.3.tgz",
      "integrity": "sha512-todwxLMY7/heScKmntwQG8CXVkWUOdYxIvY2s0VWAAMh/nd8SoYiRaKjlr7+iCs984f2P8zvrfWcDDYVb73NfA==",
      "license": "MIT",
      "dependencies": {
        "end-of-stream": "^1.1.0",
        "once": "^1.3.1"
      }
    },
    "node_modules/punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/queue-microtask": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz",
      "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/quick-format-unescaped": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/quick-format-unescaped/-/quick-format-unescaped-4.0.4.tgz",
      "integrity": "sha512-tYC1Q1hgyRuHgloV/YXs2w15unPVh8qfu/qCTfhTYamaw7fyhumKa2yGpdSo87vY32rIclj+4fWYQXUMs9EHvg==",
      "license": "MIT"
    },
    "node_modules/rc": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/rc/-/rc-1.2.8.tgz",
      "integrity": "sha512-y3bGgqKj3QBdxLbLkomlohkvsA8gdAiUQlSBJnBhfn+BPxg4bc62d8TcBW15wavDfgexCgccckhcZvywyQYPOw==",
      "license": "(BSD-2-Clause OR MIT OR Apache-2.0)",
      "dependencies": {
        "deep-extend": "^0.6.0",
        "ini": "~1.3.0",
        "minimist": "^1.2.0",
        "strip-json-comments": "~2.0.1"
      },
      "bin": {
        "rc": "cli.js"
      }
    },
    "node_modules/rc/node_modules/strip-json-comments": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-2.0.1.tgz",
      "integrity": "sha512-4gB8na07fecVVkOI6Rs4e7T6NOTki5EmL7TUduTs6bu3EdnSycntVJ4re8kgZA+wx9IueI2Y11bfbgwtzuE0KQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react": {
      "version": "19.2.3",
      "resolved": "https://registry.npmjs.org/react/-/react-19.2.3.tgz",
      "integrity": "sha512-Ku/hhYbVjOQnXDZFv2+RibmLFGwFdeeKHFcOTlrt7xplBnya5OGn/hIRDsqDiSUcfORsDC7MPxwork8jBwsIWA==",
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-dom": {
      "version": "19.2.3",
      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-19.2.3.tgz",
      "integrity": "sha512-yELu4WmLPw5Mr/lmeEpox5rw3RETacE++JgHqQzd2dg+YbJuat3jH4ingc+WPZhxaoFzdv9y33G+F7Nl5O0GBg==",
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "scheduler": "^0.27.0"
      },
      "peerDependencies": {
        "react": "^19.2.3"
      }
    },
    "node_modules/react-hook-form": {
      "version": "7.71.1",
      "resolved": "https://registry.npmjs.org/react-hook-form/-/react-hook-form-7.71.1.tgz",
      "integrity": "sha512-9SUJKCGKo8HUSsCO+y0CtqkqI5nNuaDqTxyqPsZPqIwudpj4rCrAz/jZV+jn57bx5gtZKOh3neQu94DXMc+w5w==",
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/react-hook-form"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17 || ^18 || ^19"
      }
    },
    "node_modules/react-is": {
      "version": "16.13.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-16.13.1.tgz",
      "integrity": "sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/readable-stream": {
      "version": "3.6.2",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.2.tgz",
      "integrity": "sha512-9u/sniCrY3D5WdsERHzHE4G2YCXqoG5FTHUiCC4SIbr6XcLZBY05ya9EKjYek9O5xOAwjGq+1JdGBAS7Q9ScoA==",
      "license": "MIT",
      "dependencies": {
        "inherits": "^2.0.3",
        "string_decoder": "^1.1.1",
        "util-deprecate": "^1.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/real-require": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/real-require/-/real-require-0.2.0.tgz",
      "integrity": "sha512-57frrGM/OCTLqLOAh0mhVA9VBMHd+9U7Zb2THMGdBUoZVOtGbJzjxsYGDJ3A9AYYCP4hn6y1TVbaOfzWtm5GFg==",
      "license": "MIT",
      "engines": {
        "node": ">= 12.13.0"
      }
    },
    "node_modules/reflect.getprototypeof": {
      "version": "1.0.10",
      "resolved": "https://registry.npmjs.org/reflect.getprototypeof/-/reflect.getprototypeof-1.0.10.tgz",
      "integrity": "sha512-00o4I+DVrefhv+nX0ulyi3biSHCPDe+yLv5o/p6d/UVlirijB8E16FtfwSAi4g3tcqrQ4lRAqQSoFEZJehYEcw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.9",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.0.0",
        "get-intrinsic": "^1.2.7",
        "get-proto": "^1.0.1",
        "which-builtin-type": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/regexp.prototype.flags": {
      "version": "1.5.4",
      "resolved": "https://registry.npmjs.org/regexp.prototype.flags/-/regexp.prototype.flags-1.5.4.tgz",
      "integrity": "sha512-dYqgNSZbDwkaJ2ceRd9ojCGjBq+mOm9LmtXnAnEGyHhN/5R7iDW2TRw3h+o/jCFxus3P2LfWIIiwowAjANm7IA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "define-properties": "^1.2.1",
        "es-errors": "^1.3.0",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "set-function-name": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/resolve": {
      "version": "1.22.11",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.11.tgz",
      "integrity": "sha512-RfqAvLnMl313r7c9oclB1HhUEAezcpLjz95wFH4LVuhk9JF/r22qmVP9AMmOU4vMX7Q8pN8jwNg/CSpdFnMjTQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-core-module": "^2.16.1",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/resolve-from": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/resolve-pkg-maps": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/resolve-pkg-maps/-/resolve-pkg-maps-1.0.0.tgz",
      "integrity": "sha512-seS2Tj26TBVOC2NIc2rOe2y2ZO7efxITtLZcGSOnHHNOQ7CkiUBfw0Iw2ck6xkIhPwLhKNLS8BO+hEpngQlqzw==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/privatenumber/resolve-pkg-maps?sponsor=1"
      }
    },
    "node_modules/reusify": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.1.0.tgz",
      "integrity": "sha512-g6QUff04oZpHs0eG5p83rFLhHeV00ug/Yf9nZM6fLeUrPguBTkTQOdpAWWspMh55TZfVQDPaN3NQJfbVRAxdIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "iojs": ">=1.0.0",
        "node": ">=0.10.0"
      }
    },
    "node_modules/rollup": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.57.1.tgz",
      "integrity": "sha512-oQL6lgK3e2QZeQ7gcgIkS2YZPg5slw37hYufJ3edKlfQSGGm8ICoxswK15ntSzF/a8+h7ekRy7k7oWc3BQ7y8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.8"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.57.1",
        "@rollup/rollup-android-arm64": "4.57.1",
        "@rollup/rollup-darwin-arm64": "4.57.1",
        "@rollup/rollup-darwin-x64": "4.57.1",
        "@rollup/rollup-freebsd-arm64": "4.57.1",
        "@rollup/rollup-freebsd-x64": "4.57.1",
        "@rollup/rollup-linux-arm-gnueabihf": "4.57.1",
        "@rollup/rollup-linux-arm-musleabihf": "4.57.1",
        "@rollup/rollup-linux-arm64-gnu": "4.57.1",
        "@rollup/rollup-linux-arm64-musl": "4.57.1",
        "@rollup/rollup-linux-loong64-gnu": "4.57.1",
        "@rollup/rollup-linux-loong64-musl": "4.57.1",
        "@rollup/rollup-linux-ppc64-gnu": "4.57.1",
        "@rollup/rollup-linux-ppc64-musl": "4.57.1",
        "@rollup/rollup-linux-riscv64-gnu": "4.57.1",
        "@rollup/rollup-linux-riscv64-musl": "4.57.1",
        "@rollup/rollup-linux-s390x-gnu": "4.57.1",
        "@rollup/rollup-linux-x64-gnu": "4.57.1",
        "@rollup/rollup-linux-x64-musl": "4.57.1",
        "@rollup/rollup-openbsd-x64": "4.57.1",
        "@rollup/rollup-openharmony-arm64": "4.57.1",
        "@rollup/rollup-win32-arm64-msvc": "4.57.1",
        "@rollup/rollup-win32-ia32-msvc": "4.57.1",
        "@rollup/rollup-win32-x64-gnu": "4.57.1",
        "@rollup/rollup-win32-x64-msvc": "4.57.1",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/run-parallel": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz",
      "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "queue-microtask": "^1.2.2"
      }
    },
    "node_modules/safe-array-concat": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/safe-array-concat/-/safe-array-concat-1.1.3.tgz",
      "integrity": "sha512-AURm5f0jYEOydBj7VQlVvDrjeFgthDdEF5H1dP+6mNpoXOMo1quQqJ4wvJDyRZ9+pO3kGWoOdmV08cSv2aJV6Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.2",
        "get-intrinsic": "^1.2.6",
        "has-symbols": "^1.1.0",
        "isarray": "^2.0.5"
      },
      "engines": {
        "node": ">=0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/safe-push-apply": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/safe-push-apply/-/safe-push-apply-1.0.0.tgz",
      "integrity": "sha512-iKE9w/Z7xCzUMIZqdBsp6pEQvwuEebH4vdpjcDWnyzaI6yl6O9FHvVpmGelvEHNsoY6wGblkxR6Zty/h00WiSA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "isarray": "^2.0.5"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/safe-regex-test": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/safe-regex-test/-/safe-regex-test-1.1.0.tgz",
      "integrity": "sha512-x/+Cz4YrimQxQccJf5mKEbIa1NzeCRNI5Ecl/ekmlYaampdNLPalVyIcCZNNH3MvmqBugV5TMYZXv0ljslUlaw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "is-regex": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/safe-stable-stringify": {
      "version": "2.5.0",
      "resolved": "https://registry.npmjs.org/safe-stable-stringify/-/safe-stable-stringify-2.5.0.tgz",
      "integrity": "sha512-b3rppTKm9T+PsVCBEOUR46GWI7fdOs00VKZ1+9c1EWDaDMvjQc6tUwuFyIprgGgTcWoVHSKrU8H31ZHA2e0RHA==",
      "license": "MIT",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/scheduler": {
      "version": "0.27.0",
      "resolved": "https://registry.npmjs.org/scheduler/-/scheduler-0.27.0.tgz",
      "integrity": "sha512-eNv+WrVbKu1f3vbYJT/xtiF5syA5HPIMtf9IgY/nKg0sWqzAUEvqY/xm7OcZc/qafLx/iO9FgOmeSAp4v5ti/Q==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/set-function-length": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/set-function-length/-/set-function-length-1.2.2.tgz",
      "integrity": "sha512-pgRc4hJ4/sNjWCSS9AmnS40x3bNMDTknHgL5UaMBTMyJnU90EgWh1Rz+MC9eFu4BuN/UwZjKQuY/1v3rM7HMfg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "define-data-property": "^1.1.4",
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2",
        "get-intrinsic": "^1.2.4",
        "gopd": "^1.0.1",
        "has-property-descriptors": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/set-function-name": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/set-function-name/-/set-function-name-2.0.2.tgz",
      "integrity": "sha512-7PGFlmtwsEADb0WYyvCMa1t+yke6daIG4Wirafur5kcf+MhUnPms1UeR0CKQdTZD81yESwMHbtn+TR+dMviakQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "define-data-property": "^1.1.4",
        "es-errors": "^1.3.0",
        "functions-have-names": "^1.2.3",
        "has-property-descriptors": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/set-proto": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/set-proto/-/set-proto-1.0.0.tgz",
      "integrity": "sha512-RJRdvCo6IAnPdsvP/7m6bsQqNnn1FCBX5ZNtFL98MmFF/4xAIJTIg1YbHW5DC2W5SKZanrC6i4HsJqlajw/dZw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/sharp": {
      "version": "0.34.5",
      "resolved": "https://registry.npmjs.org/sharp/-/sharp-0.34.5.tgz",
      "integrity": "sha512-Ou9I5Ft9WNcCbXrU9cMgPBcCK8LiwLqcbywW3t4oDV37n1pzpuNLsYiAV8eODnjbtQlSDwZ2cUEeQz4E54Hltg==",
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "optional": true,
      "dependencies": {
        "@img/colour": "^1.0.0",
        "detect-libc": "^2.1.2",
        "semver": "^7.7.3"
      },
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-darwin-arm64": "0.34.5",
        "@img/sharp-darwin-x64": "0.34.5",
        "@img/sharp-libvips-darwin-arm64": "1.2.4",
        "@img/sharp-libvips-darwin-x64": "1.2.4",
        "@img/sharp-libvips-linux-arm": "1.2.4",
        "@img/sharp-libvips-linux-arm64": "1.2.4",
        "@img/sharp-libvips-linux-ppc64": "1.2.4",
        "@img/sharp-libvips-linux-riscv64": "1.2.4",
        "@img/sharp-libvips-linux-s390x": "1.2.4",
        "@img/sharp-libvips-linux-x64": "1.2.4",
        "@img/sharp-libvips-linuxmusl-arm64": "1.2.4",
        "@img/sharp-libvips-linuxmusl-x64": "1.2.4",
        "@img/sharp-linux-arm": "0.34.5",
        "@img/sharp-linux-arm64": "0.34.5",
        "@img/sharp-linux-ppc64": "0.34.5",
        "@img/sharp-linux-riscv64": "0.34.5",
        "@img/sharp-linux-s390x": "0.34.5",
        "@img/sharp-linux-x64": "0.34.5",
        "@img/sharp-linuxmusl-arm64": "0.34.5",
        "@img/sharp-linuxmusl-x64": "0.34.5",
        "@img/sharp-wasm32": "0.34.5",
        "@img/sharp-win32-arm64": "0.34.5",
        "@img/sharp-win32-ia32": "0.34.5",
        "@img/sharp-win32-x64": "0.34.5"
      }
    },
    "node_modules/sharp/node_modules/semver": {
      "version": "7.7.4",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.4.tgz",
      "integrity": "sha512-vFKC2IEtQnVhpT78h1Yp8wzwrf8CM+MzKMHGJZfBtzhZNycRFnXsHk6E5TxIkkMsgNS7mdX3AGB7x2QM2di4lA==",
      "license": "ISC",
      "optional": true,
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/siginfo": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/siginfo/-/siginfo-2.0.0.tgz",
      "integrity": "sha512-ybx0WO1/8bSBLEWXZvEd7gMW3Sn3JFlW3TvX1nREbDLRNQNaeNN8WK0meBwPdAaOI7TtRRRJn/Es1zhrrCHu7g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/simple-concat": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/simple-concat/-/simple-concat-1.0.1.tgz",
      "integrity": "sha512-cSFtAPtRhljv69IK0hTVZQ+OfE9nePi/rtJmw5UjHeVyVroEqJXP1sFztKUy1qU+xvz3u/sfYJLa947b7nAN2Q==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/simple-get": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/simple-get/-/simple-get-4.0.1.tgz",
      "integrity": "sha512-brv7p5WgH0jmQJr1ZDDfKDOSeWWg+OVypG99A/5vYGPqJ6pxiaHLy8nxtFjBA7oMa01ebA9gfh1uMCFqOuXxvA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "decompress-response": "^6.0.0",
        "once": "^1.3.1",
        "simple-concat": "^1.0.0"
      }
    },
    "node_modules/sonic-boom": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/sonic-boom/-/sonic-boom-4.2.1.tgz",
      "integrity": "sha512-w6AxtubXa2wTXAUsZMMWERrsIRAdrK0Sc+FUytWvYAhBJLyuI4llrMIC1DtlNSdI99EI86KZum2MMq3EAZlF9Q==",
      "license": "MIT",
      "dependencies": {
        "atomic-sleep": "^1.0.0"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/split2": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/split2/-/split2-4.2.0.tgz",
      "integrity": "sha512-UcjcJOWknrNkF6PLX83qcHM6KHgVKNkV62Y8a5uYDVv9ydGQVwAHMKqHdJje1VTWpljG0WYpCDhrCdAOYH4TWg==",
      "license": "ISC",
      "engines": {
        "node": ">= 10.x"
      }
    },
    "node_modules/stable-hash": {
      "version": "0.0.5",
      "resolved": "https://registry.npmjs.org/stable-hash/-/stable-hash-0.0.5.tgz",
      "integrity": "sha512-+L3ccpzibovGXFK+Ap/f8LOS0ahMrHTf3xu7mMLSpEGU0EO9ucaysSylKo9eRDFNhWve/y275iPmIZ4z39a9iA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/stackback": {
      "version": "0.0.2",
      "resolved": "https://registry.npmjs.org/stackback/-/stackback-0.0.2.tgz",
      "integrity": "sha512-1XMJE5fQo1jGH6Y/7ebnwPOBEkIEnT4QF32d5R1+VXdXveM0IBMJt8zfaxX1P3QhVwrYe+576+jkANtSS2mBbw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/std-env": {
      "version": "3.10.0",
      "resolved": "https://registry.npmjs.org/std-env/-/std-env-3.10.0.tgz",
      "integrity": "sha512-5GS12FdOZNliM5mAOxFRg7Ir0pWz8MdpYm6AY6VPkGpbA7ZzmbzNcBJQ0GPvvyWgcY7QAhCgf9Uy89I03faLkg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/stop-iteration-iterator": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/stop-iteration-iterator/-/stop-iteration-iterator-1.1.0.tgz",
      "integrity": "sha512-eLoXW/DHyl62zxY4SCaIgnRhuMr6ri4juEYARS8E6sCEqzKpOiE521Ucofdx+KnDZl5xmvGYaaKCk5FEOxJCoQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "internal-slot": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/string_decoder": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.3.0.tgz",
      "integrity": "sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "~5.2.0"
      }
    },
    "node_modules/string.prototype.includes": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/string.prototype.includes/-/string.prototype.includes-2.0.1.tgz",
      "integrity": "sha512-o7+c9bW6zpAdJHTtujeePODAhkuicdAryFsfVKwA+wGw89wJ4GTY484WTucM9hLtDEOpOvI+aHnzqnC5lHp4Rg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.7",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.3"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/string.prototype.matchall": {
      "version": "4.0.12",
      "resolved": "https://registry.npmjs.org/string.prototype.matchall/-/string.prototype.matchall-4.0.12.tgz",
      "integrity": "sha512-6CC9uyBL+/48dYizRf7H7VAYCMCNTBeM78x/VTUe9bFEaxBepPJDa1Ow99LqI/1yF7kuy7Q3cQsYMrcjGUcskA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.3",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.6",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.0.0",
        "get-intrinsic": "^1.2.6",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "internal-slot": "^1.1.0",
        "regexp.prototype.flags": "^1.5.3",
        "set-function-name": "^2.0.2",
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/string.prototype.repeat": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/string.prototype.repeat/-/string.prototype.repeat-1.0.0.tgz",
      "integrity": "sha512-0u/TldDbKD8bFCQ/4f5+mNRrXwZ8hg2w7ZR8wa16e8z9XpePWl3eGEcUD0OXpEH/VJH/2G3gjUtR3ZOiBe2S/w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.17.5"
      }
    },
    "node_modules/string.prototype.trim": {
      "version": "1.2.10",
      "resolved": "https://registry.npmjs.org/string.prototype.trim/-/string.prototype.trim-1.2.10.tgz",
      "integrity": "sha512-Rs66F0P/1kedk5lyYyH9uBzuiI/kNRmwJAR9quK6VOtIpZ2G+hMZd+HQbbv25MgCA6gEffoMZYxlTod4WcdrKA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.2",
        "define-data-property": "^1.1.4",
        "define-properties": "^1.2.1",
        "es-abstract": "^1.23.5",
        "es-object-atoms": "^1.0.0",
        "has-property-descriptors": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/string.prototype.trimend": {
      "version": "1.0.9",
      "resolved": "https://registry.npmjs.org/string.prototype.trimend/-/string.prototype.trimend-1.0.9.tgz",
      "integrity": "sha512-G7Ok5C6E/j4SGfyLCloXTrngQIQU3PWtXGst3yM7Bea9FRURf1S42ZHlZZtsNque2FN2PoUhfZXYLNWwEr4dLQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.2",
        "define-properties": "^1.2.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/string.prototype.trimstart": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/string.prototype.trimstart/-/string.prototype.trimstart-1.0.8.tgz",
      "integrity": "sha512-UXSH262CSZY1tfu3G3Secr6uGLCFVPMhIqHjlgCUtCCcgihYc/xKs9djMTMUOb2j1mVSeU8EU6NWc/iQKU6Gfg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.7",
        "define-properties": "^1.2.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/strip-bom": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/strip-bom/-/strip-bom-3.0.0.tgz",
      "integrity": "sha512-vavAMRXOgBVNF6nyEEmL3DBK19iRpDcoIwW+swQ+CbGiu7lju6t+JklA1MHweoWtadgt4ISVUsXLyDq34ddcwA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/styled-jsx": {
      "version": "5.1.6",
      "resolved": "https://registry.npmjs.org/styled-jsx/-/styled-jsx-5.1.6.tgz",
      "integrity": "sha512-qSVyDTeMotdvQYoHWLNGwRFJHC+i+ZvdBRYosOFgC+Wg1vx4frN2/RG/NA7SYqqvKNLf39P2LSRA2pu6n0XYZA==",
      "license": "MIT",
      "dependencies": {
        "client-only": "0.0.1"
      },
      "engines": {
        "node": ">= 12.0.0"
      },
      "peerDependencies": {
        "react": ">= 16.8.0 || 17.x.x || ^18.0.0-0 || ^19.0.0-0"
      },
      "peerDependenciesMeta": {
        "@babel/core": {
          "optional": true
        },
        "babel-plugin-macros": {
          "optional": true
        }
      }
    },
    "node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/supports-preserve-symlinks-flag": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
      "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/tailwindcss": {
      "version": "4.1.18",
      "resolved": "https://registry.npmjs.org/tailwindcss/-/tailwindcss-4.1.18.tgz",
      "integrity": "sha512-4+Z+0yiYyEtUVCScyfHCxOYP06L5Ne+JiHhY2IjR2KWMIWhJOYZKLSGZaP5HkZ8+bY0cxfzwDE5uOmzFXyIwxw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tapable": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/tapable/-/tapable-2.3.0.tgz",
      "integrity": "sha512-g9ljZiwki/LfxmQADO3dEY1CbpmXT5Hm2fJ+QaGKwSXUylMybePR7/67YW7jOrrvjEgL1Fmz5kzyAjWVWLlucg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/webpack"
      }
    },
    "node_modules/tar-fs": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/tar-fs/-/tar-fs-2.1.4.tgz",
      "integrity": "sha512-mDAjwmZdh7LTT6pNleZ05Yt65HC3E+NiQzl672vQG38jIrehtJk/J3mNwIg+vShQPcLF/LV7CMnDW6vjj6sfYQ==",
      "license": "MIT",
      "dependencies": {
        "chownr": "^1.1.1",
        "mkdirp-classic": "^0.5.2",
        "pump": "^3.0.0",
        "tar-stream": "^2.1.4"
      }
    },
    "node_modules/tar-stream": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/tar-stream/-/tar-stream-2.2.0.tgz",
      "integrity": "sha512-ujeqbceABgwMZxEJnk2HDY2DlnUZ+9oEcb1KzTVfYHio0UE6dG71n60d8D2I4qNvleWrrXpmjpt7vZeF1LnMZQ==",
      "license": "MIT",
      "dependencies": {
        "bl": "^4.0.3",
        "end-of-stream": "^1.4.1",
        "fs-constants": "^1.0.0",
        "inherits": "^2.0.3",
        "readable-stream": "^3.1.1"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/thread-stream": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/thread-stream/-/thread-stream-4.0.0.tgz",
      "integrity": "sha512-4iMVL6HAINXWf1ZKZjIPcz5wYaOdPhtO8ATvZ+Xqp3BTdaqtAwQkNmKORqcIo5YkQqGXq5cwfswDwMqqQNrpJA==",
      "license": "MIT",
      "dependencies": {
        "real-require": "^0.2.0"
      },
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/tinybench": {
      "version": "2.9.0",
      "resolved": "https://registry.npmjs.org/tinybench/-/tinybench-2.9.0.tgz",
      "integrity": "sha512-0+DUvqWMValLmha6lr4kD8iAMK1HzV0/aKnCtWb9v9641TnP/MFb7Pc2bxoxQjTXAErryXVgUOfv2YqNllqGeg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tinyexec": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/tinyexec/-/tinyexec-1.0.2.tgz",
      "integrity": "sha512-W/KYk+NFhkmsYpuHq5JykngiOCnxeVL8v8dFnqxSD8qEEdRfXk1SDM6JzNqcERbcGYj9tMrDQBYV9cjgnunFIg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/tinyglobby": {
      "version": "0.2.15",
      "resolved": "https://registry.npmjs.org/tinyglobby/-/tinyglobby-0.2.15.tgz",
      "integrity": "sha512-j2Zq4NyQYG5XMST4cbs02Ak8iJUdxRM0XI5QyxXuZOzKOINmWurp3smXu3y5wDcJrptwpSjgXHzIQxR0omXljQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fdir": "^6.5.0",
        "picomatch": "^4.0.3"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/SuperchupuDev"
      }
    },
    "node_modules/tinyglobby/node_modules/fdir": {
      "version": "6.5.0",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/tinyglobby/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/tinyrainbow": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/tinyrainbow/-/tinyrainbow-3.0.3.tgz",
      "integrity": "sha512-PSkbLUoxOFRzJYjjxHJt9xro7D+iilgMX/C9lawzVuYiIdcihh9DXmVibBe8lmcFrRi/VzlPjBxbN7rH24q8/Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/ts-api-utils": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/ts-api-utils/-/ts-api-utils-2.4.0.tgz",
      "integrity": "sha512-3TaVTaAv2gTiMB35i3FiGJaRfwb3Pyn/j3m/bfAvGe8FB7CF6u+LMYqYlDh7reQf7UNvoTvdfAqHGmPGOSsPmA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18.12"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4"
      }
    },
    "node_modules/tsconfig-paths": {
      "version": "3.15.0",
      "resolved": "https://registry.npmjs.org/tsconfig-paths/-/tsconfig-paths-3.15.0.tgz",
      "integrity": "sha512-2Ac2RgzDe/cn48GvOe3M+o82pEFewD3UPbyoUHHdKasHwJKjds4fLXWf/Ux5kATBKN20oaFGu+jbElp1pos0mg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/json5": "^0.0.29",
        "json5": "^1.0.2",
        "minimist": "^1.2.6",
        "strip-bom": "^3.0.0"
      }
    },
    "node_modules/tsconfig-paths/node_modules/json5": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/json5/-/json5-1.0.2.tgz",
      "integrity": "sha512-g1MWMLBiz8FKi1e4w0UyVL3w+iJceWAFBAaBnnGKOpNa5f8TLktkbre1+s6oICydWAm+HRUGTmI+//xv2hvXYA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "minimist": "^1.2.0"
      },
      "bin": {
        "json5": "lib/cli.js"
      }
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/tsx": {
      "version": "4.21.0",
      "resolved": "https://registry.npmjs.org/tsx/-/tsx-4.21.0.tgz",
      "integrity": "sha512-5C1sg4USs1lfG0GFb2RLXsdpXqBSEhAaA/0kPL01wxzpMqLILNxIxIOKiILz+cdg/pLnOUxFYOR5yhHU666wbw==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "esbuild": "~0.27.0",
        "get-tsconfig": "^4.7.5"
      },
      "bin": {
        "tsx": "dist/cli.mjs"
      },
      "engines": {
        "node": ">=18.0.0"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      }
    },
    "node_modules/tunnel-agent": {
      "version": "0.6.0",
      "resolved": "https://registry.npmjs.org/tunnel-agent/-/tunnel-agent-0.6.0.tgz",
      "integrity": "sha512-McnNiV1l8RYeY8tBgEpuodCC1mLUdbSN+CYBL7kJsJNInOP8UjDDEwdk6Mw60vdLLrr5NHKZhMAOSrR2NZuQ+w==",
      "license": "Apache-2.0",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/type-check": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/typed-array-buffer": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/typed-array-buffer/-/typed-array-buffer-1.0.3.tgz",
      "integrity": "sha512-nAYYwfY3qnzX30IkA6AQZjVbtK6duGontcQm1WSG1MD94YLqK0515GNApXkoxKOWMusVssAHWLh9SeaoefYFGw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "es-errors": "^1.3.0",
        "is-typed-array": "^1.1.14"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/typed-array-byte-length": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/typed-array-byte-length/-/typed-array-byte-length-1.0.3.tgz",
      "integrity": "sha512-BaXgOuIxz8n8pIq3e7Atg/7s+DpiYrxn4vdot3w9KbnBhcRQq6o3xemQdIfynqSeXeDrF32x+WvfzmOjPiY9lg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.8",
        "for-each": "^0.3.3",
        "gopd": "^1.2.0",
        "has-proto": "^1.2.0",
        "is-typed-array": "^1.1.14"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/typed-array-byte-offset": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/typed-array-byte-offset/-/typed-array-byte-offset-1.0.4.tgz",
      "integrity": "sha512-bTlAFB/FBYMcuX81gbL4OcpH5PmlFHqlCCpAl8AlEzMz5k53oNDvN8p1PNOWLEmI2x4orp3raOFB51tv9X+MFQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "available-typed-arrays": "^1.0.7",
        "call-bind": "^1.0.8",
        "for-each": "^0.3.3",
        "gopd": "^1.2.0",
        "has-proto": "^1.2.0",
        "is-typed-array": "^1.1.15",
        "reflect.getprototypeof": "^1.0.9"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/typed-array-length": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/typed-array-length/-/typed-array-length-1.0.7.tgz",
      "integrity": "sha512-3KS2b+kL7fsuk/eJZ7EQdnEmQoaho/r6KUef7hxvltNA5DR8NAUM+8wJMbJyZ4G9/7i3v5zPBIMN5aybAh2/Jg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind": "^1.0.7",
        "for-each": "^0.3.3",
        "gopd": "^1.0.1",
        "is-typed-array": "^1.1.13",
        "possible-typed-array-names": "^1.0.0",
        "reflect.getprototypeof": "^1.0.6"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/typescript": {
      "version": "5.9.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.3.tgz",
      "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
      "devOptional": true,
      "license": "Apache-2.0",
      "peer": true,
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/typescript-eslint": {
      "version": "8.56.0",
      "resolved": "https://registry.npmjs.org/typescript-eslint/-/typescript-eslint-8.56.0.tgz",
      "integrity": "sha512-c7toRLrotJ9oixgdW7liukZpsnq5CZ7PuKztubGYlNppuTqhIoWfhgHo/7EU0v06gS2l/x0i2NEFK1qMIf0rIg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/eslint-plugin": "8.56.0",
        "@typescript-eslint/parser": "8.56.0",
        "@typescript-eslint/typescript-estree": "8.56.0",
        "@typescript-eslint/utils": "8.56.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0 || ^10.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/unbox-primitive": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/unbox-primitive/-/unbox-primitive-1.1.0.tgz",
      "integrity": "sha512-nWJ91DjeOkej/TA8pXQ3myruKpKEYgqvpw9lz4OPHj/NWFNluYrjbz9j01CJ8yKQd2g4jFoOkINCTW2I5LEEyw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.3",
        "has-bigints": "^1.0.2",
        "has-symbols": "^1.1.0",
        "which-boxed-primitive": "^1.1.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/undici-types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/unrs-resolver": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/unrs-resolver/-/unrs-resolver-1.11.1.tgz",
      "integrity": "sha512-bSjt9pjaEBnNiGgc9rUiHGKv5l4/TGzDmYw3RhnkJGtLhbnnA/5qJj7x3dNDCRx/PJxu774LlH8lCOlB4hEfKg==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "dependencies": {
        "napi-postinstall": "^0.3.0"
      },
      "funding": {
        "url": "https://opencollective.com/unrs-resolver"
      },
      "optionalDependencies": {
        "@unrs/resolver-binding-android-arm-eabi": "1.11.1",
        "@unrs/resolver-binding-android-arm64": "1.11.1",
        "@unrs/resolver-binding-darwin-arm64": "1.11.1",
        "@unrs/resolver-binding-darwin-x64": "1.11.1",
        "@unrs/resolver-binding-freebsd-x64": "1.11.1",
        "@unrs/resolver-binding-linux-arm-gnueabihf": "1.11.1",
        "@unrs/resolver-binding-linux-arm-musleabihf": "1.11.1",
        "@unrs/resolver-binding-linux-arm64-gnu": "1.11.1",
        "@unrs/resolver-binding-linux-arm64-musl": "1.11.1",
        "@unrs/resolver-binding-linux-ppc64-gnu": "1.11.1",
        "@unrs/resolver-binding-linux-riscv64-gnu": "1.11.1",
        "@unrs/resolver-binding-linux-riscv64-musl": "1.11.1",
        "@unrs/resolver-binding-linux-s390x-gnu": "1.11.1",
        "@unrs/resolver-binding-linux-x64-gnu": "1.11.1",
        "@unrs/resolver-binding-linux-x64-musl": "1.11.1",
        "@unrs/resolver-binding-wasm32-wasi": "1.11.1",
        "@unrs/resolver-binding-win32-arm64-msvc": "1.11.1",
        "@unrs/resolver-binding-win32-ia32-msvc": "1.11.1",
        "@unrs/resolver-binding-win32-x64-msvc": "1.11.1"
      }
    },
    "node_modules/update-browserslist-db": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.2.3.tgz",
      "integrity": "sha512-Js0m9cx+qOgDxo0eMiFGEueWztz+d4+M3rGlmKPT+T4IS/jP4ylw3Nwpu6cpTTP8R1MAC1kF4VbdLt3ARf209w==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "escalade": "^3.2.0",
        "picocolors": "^1.1.1"
      },
      "bin": {
        "update-browserslist-db": "cli.js"
      },
      "peerDependencies": {
        "browserslist": ">= 4.21.0"
      }
    },
    "node_modules/uri-js": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "punycode": "^2.1.0"
      }
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
      "license": "MIT"
    },
    "node_modules/vite": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/vite/-/vite-7.3.1.tgz",
      "integrity": "sha512-w+N7Hifpc3gRjZ63vYBXA56dvvRlNWRczTdmCBBa+CotUzAPf5b7YMdMR/8CQoeYE5LX3W4wj6RYTgonm1b9DA==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "esbuild": "^0.27.0",
        "fdir": "^6.5.0",
        "picomatch": "^4.0.3",
        "postcss": "^8.5.6",
        "rollup": "^4.43.0",
        "tinyglobby": "^0.2.15"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^20.19.0 || >=22.12.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^20.19.0 || >=22.12.0",
        "jiti": ">=1.21.0",
        "less": "^4.0.0",
        "lightningcss": "^1.21.0",
        "sass": "^1.70.0",
        "sass-embedded": "^1.70.0",
        "stylus": ">=0.54.8",
        "sugarss": "^5.0.0",
        "terser": "^5.16.0",
        "tsx": "^4.8.1",
        "yaml": "^2.4.2"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "jiti": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        },
        "tsx": {
          "optional": true
        },
        "yaml": {
          "optional": true
        }
      }
    },
    "node_modules/vite/node_modules/fdir": {
      "version": "6.5.0",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/vite/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/vitest": {
      "version": "4.0.18",
      "resolved": "https://registry.npmjs.org/vitest/-/vitest-4.0.18.tgz",
      "integrity": "sha512-hOQuK7h0FGKgBAas7v0mSAsnvrIgAvWmRFjmzpJ7SwFHH3g1k2u37JtYwOwmEKhK6ZO3v9ggDBBm0La1LCK4uQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/expect": "4.0.18",
        "@vitest/mocker": "4.0.18",
        "@vitest/pretty-format": "4.0.18",
        "@vitest/runner": "4.0.18",
        "@vitest/snapshot": "4.0.18",
        "@vitest/spy": "4.0.18",
        "@vitest/utils": "4.0.18",
        "es-module-lexer": "^1.7.0",
        "expect-type": "^1.2.2",
        "magic-string": "^0.30.21",
        "obug": "^2.1.1",
        "pathe": "^2.0.3",
        "picomatch": "^4.0.3",
        "std-env": "^3.10.0",
        "tinybench": "^2.9.0",
        "tinyexec": "^1.0.2",
        "tinyglobby": "^0.2.15",
        "tinyrainbow": "^3.0.3",
        "vite": "^6.0.0 || ^7.0.0",
        "why-is-node-running": "^2.3.0"
      },
      "bin": {
        "vitest": "vitest.mjs"
      },
      "engines": {
        "node": "^20.0.0 || ^22.0.0 || >=24.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "@edge-runtime/vm": "*",
        "@opentelemetry/api": "^1.9.0",
        "@types/node": "^20.0.0 || ^22.0.0 || >=24.0.0",
        "@vitest/browser-playwright": "4.0.18",
        "@vitest/browser-preview": "4.0.18",
        "@vitest/browser-webdriverio": "4.0.18",
        "@vitest/ui": "4.0.18",
        "happy-dom": "*",
        "jsdom": "*"
      },
      "peerDependenciesMeta": {
        "@edge-runtime/vm": {
          "optional": true
        },
        "@opentelemetry/api": {
          "optional": true
        },
        "@types/node": {
          "optional": true
        },
        "@vitest/browser-playwright": {
          "optional": true
        },
        "@vitest/browser-preview": {
          "optional": true
        },
        "@vitest/browser-webdriverio": {
          "optional": true
        },
        "@vitest/ui": {
          "optional": true
        },
        "happy-dom": {
          "optional": true
        },
        "jsdom": {
          "optional": true
        }
      }
    },
    "node_modules/vitest/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/which-boxed-primitive": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/which-boxed-primitive/-/which-boxed-primitive-1.1.1.tgz",
      "integrity": "sha512-TbX3mj8n0odCBFVlY8AxkqcHASw3L60jIuF8jFP78az3C2YhmGvqbHBpAjTRH2/xqYunrJ9g1jSyjCjpoWzIAA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-bigint": "^1.1.0",
        "is-boolean-object": "^1.2.1",
        "is-number-object": "^1.1.1",
        "is-string": "^1.1.1",
        "is-symbol": "^1.1.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/which-builtin-type": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/which-builtin-type/-/which-builtin-type-1.2.1.tgz",
      "integrity": "sha512-6iBczoX+kDQ7a3+YJBnh3T+KZRxM/iYNPXicqk66/Qfm1b93iu+yOImkg0zHbj5LNOcNv1TEADiZ0xa34B4q6Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "function.prototype.name": "^1.1.6",
        "has-tostringtag": "^1.0.2",
        "is-async-function": "^2.0.0",
        "is-date-object": "^1.1.0",
        "is-finalizationregistry": "^1.1.0",
        "is-generator-function": "^1.0.10",
        "is-regex": "^1.2.1",
        "is-weakref": "^1.0.2",
        "isarray": "^2.0.5",
        "which-boxed-primitive": "^1.1.0",
        "which-collection": "^1.0.2",
        "which-typed-array": "^1.1.16"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/which-collection": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/which-collection/-/which-collection-1.0.2.tgz",
      "integrity": "sha512-K4jVyjnBdgvc86Y6BkaLZEN933SwYOuBFkdmBu9ZfkcAbdVbpITnDmjvZ/aQjRXQrv5EPkTnD1s39GiiqbngCw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-map": "^2.0.3",
        "is-set": "^2.0.3",
        "is-weakmap": "^2.0.2",
        "is-weakset": "^2.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/which-typed-array": {
      "version": "1.1.20",
      "resolved": "https://registry.npmjs.org/which-typed-array/-/which-typed-array-1.1.20.tgz",
      "integrity": "sha512-LYfpUkmqwl0h9A2HL09Mms427Q1RZWuOHsukfVcKRq9q95iQxdw0ix1JQrqbcDR9PH1QDwf5Qo8OZb5lksZ8Xg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "available-typed-arrays": "^1.0.7",
        "call-bind": "^1.0.8",
        "call-bound": "^1.0.4",
        "for-each": "^0.3.5",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-tostringtag": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/why-is-node-running": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/why-is-node-running/-/why-is-node-running-2.3.0.tgz",
      "integrity": "sha512-hUrmaWBdVDcxvYqnyh09zunKzROWjbZTiNy8dBEjkS7ehEDQibXJ7XvlmtbwuTclUiIyN+CyXQD4Vmko8fNm8w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "siginfo": "^2.0.0",
        "stackback": "0.0.2"
      },
      "bin": {
        "why-is-node-running": "cli.js"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/word-wrap": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.5.tgz",
      "integrity": "sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "license": "ISC"
    },
    "node_modules/yallist": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
      "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/yaml": {
      "version": "2.8.2",
      "resolved": "https://registry.npmjs.org/yaml/-/yaml-2.8.2.tgz",
      "integrity": "sha512-mplynKqc1C2hTVYxd0PU2xQAc22TI1vShAYGksCCfxbn/dFwnHTNi1bvYsBTkhdUNtGIf5xNOg938rrSSYvS9A==",
      "license": "ISC",
      "bin": {
        "yaml": "bin.mjs"
      },
      "engines": {
        "node": ">= 14.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/eemeli"
      }
    },
    "node_modules/yocto-queue": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
      "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/zod": {
      "version": "4.3.6",
      "resolved": "https://registry.npmjs.org/zod/-/zod-4.3.6.tgz",
      "integrity": "sha512-rftlrkhHZOcjDwkGlnUtZZkvaPHCsDATp4pGpuOOMDaTdDDXF91wuVDJoWoPsKX/3YPQ5fHuF3STjcYyKr+Qhg==",
      "license": "MIT",
      "peer": true,
      "funding": {
        "url": "https://github.com/sponsors/colinhacks"
      }
    },
    "node_modules/zod-validation-error": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/zod-validation-error/-/zod-validation-error-4.0.2.tgz",
      "integrity": "sha512-Q6/nZLe6jxuU80qb/4uJ4t5v2VEZ44lzQjPDhYJNztRQ4wyWc6VF3D3Kb/fAuPetZQnhS3hnajCf9CsWesghLQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18.0.0"
      },
      "peerDependencies": {
        "zod": "^3.25.0 || ^4.0.0"
      }
    }
  }
}


===== FILE: package.json =====
{
  "name": "lms_219",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:e2e": "playwright test",
    "test:e2e:headed": "playwright test --headed",
    "cli": "node --import tsx ./src/cli/main.ts"
  },
  "dependencies": {
    "@hookform/resolvers": "^5.2.2",
    "@node-rs/argon2": "^2.0.2",
    "better-sqlite3": "^12.6.2",
    "commander": "^14.0.3",
    "cosmiconfig": "^9.0.0",
    "next": "16.1.6",
    "pino": "^10.3.1",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-hook-form": "^7.71.1",
    "yaml": "^2.8.2",
    "zod": "^4.3.6"
  },
  "devDependencies": {
    "@playwright/test": "^1.58.2",
    "@tailwindcss/postcss": "^4",
    "@types/better-sqlite3": "^7.6.13",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/yaml": "^1.9.6",
    "eslint": "^9",
    "eslint-config-next": "16.1.6",
    "tailwindcss": "^4",
    "tsx": "^4.21.0",
    "typescript": "^5",
    "vitest": "^4.0.18"
  }
}


===== FILE: playwright.config.ts =====
import { defineConfig } from "@playwright/test";

export default defineConfig({
  testDir: "./e2e",
  use: {
    baseURL: "http://localhost:3000",
    trace: "on-first-retry",
  },
  webServer: {
    command: "npm run dev",
    url: "http://localhost:3000",
    reuseExistingServer: true,
  },
});


===== FILE: postcss.config.mjs =====
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;


===== FILE: project_management/letter1.md =====
CLI Spec v0.1 — “Super Admin Control Plane”
1) Purpose
Why this exists
A repo-shipped CLI that provides repeatable, auditable, safe operations for:
DB lifecycle (migrate/seed/health/backup/restore)
Super-admin user/role operations (create/disable/promote)
Event lifecycle (create/publish/cancel)
Registration operations (add/check-in/export)
Strategic intent
Phase 1: CLI is the source of truth for “admin control plane” operations.
Phase 2: Build API endpoints that call the same domain services.
Phase 3: Build web UI + admin UI on top of those endpoints.
The CLI remains the only place for super-admin and dangerous ops.
2) Core principles and invariants
Invariants
No duplicated business logic: CLI calls the same domain service layer that API routes will call later.
Audit required: Every state-changing command emits an AuditLog record. If audit write fails, the command fails (fail-closed).
Idempotent by default: re-running migrate, seed, role add, publish should not produce duplicates or corruption.
Safety rails for production: dangerous commands require explicit flags + super-admin token.
Scope boundaries (v0.1)
Included:
DB: status/migrate/seed/backup/restore/doctor
Auth support: service token create/revoke (for CLI super-admin auth)
Users: create/list/show/disable/enable/role add/remove
Events: create/update/publish/cancel/list
Registrations: add/remove/list/checkin/export
Not included (future):
Email sending, notifications, payment, invitations, OAuth provider configuration, multi-tenant, multi-instance scaling.
3) Runtime + dependencies
Runtime
Node 20+
TypeScript
Recommended libraries (implementation guidance)
CLI framework: Commander
Validation: Zod
Config loading: cosmiconfig
Logging (structured): Pino
ORM + migrations: Drizzle ORM + drizzle-kit
SQLite driver (single-node prod): better-sqlite3
(Optional migration path: libSQL)
Auth integration later can be via Auth.js, but v0.1 CLI auth is token-based (below).
4) Environments and config
Environments
local, staging, prod
Config precedence
CLI flags → 2) env vars → 3) config file → 4) defaults
Config file
.appctlrc (JSON/YAML) or appctl.config.json
Minimum config fields:
env: default env
db:
mode: sqlite
file: absolute or repo-relative path (prod must be explicit)
busyTimeoutMs: default 5000–10000
security:
requireTokenInStaging: true
requireTokenInProd: true
dangerousOpsRequireExplicitProd: true
audit:
strict: true (fail if audit insert fails)
output:
defaultFormat: text | json
5) SQLite production operating profile (v0.1 requirement)
When env=prod, the CLI (and app runtime) must enforce/verify:
WAL mode enabled
foreign keys enabled
busy timeout set
journaling + sync policy set for production (documented)
DB file location is persistent (not in ephemeral deploy dir)
single-instance assumption: one app process is the writer
Required CLI checks
doctor must validate:
DB reachable
schema up to date
WAL + foreign keys active
file path resolves to expected location
ability to write (permissions)
Required CLI operations
db backup must use a safe backup method (not a naive random file copy)
db restore is local/staging only by default; production restore requires explicit override + token
6) Security model (super-admin stays CLI-only)
Super-admin authentication
Privileged commands require a service token:
Provided via CLI_ADMIN_TOKEN env var (or --token)
Token stored hashed in DB (never plaintext at rest)
Token shown once upon creation
Tokens can be revoked
Role model
USER
ADMIN
SUPER_ADMIN (optional in UI later, but enforced in CLI now)
Rule:
UI-admin features eventually map to ADMIN.
CLI-only dangerous ops require SUPER_ADMIN token.
7) Data model (minimum viable tables)
v0.1 tables:
User: id, email (unique), status (ACTIVE/DISABLED/PENDING), created_at, updated_at
Role: id, name (USER/ADMIN/SUPER_ADMIN)
UserRole: user_id, role_id, unique(user_id, role_id)
ServiceToken: id, name, token_hash, created_at, revoked_at, last_used_at
Event: id, slug (unique), title, start_at, end_at, timezone, status (DRAFT/PUBLISHED/CANCELLED), capacity nullable, created_by nullable, created_at/updated_at
EventRegistration: id, event_id, user_id, status (REGISTERED/WAITLISTED/CANCELLED/CHECKED_IN), unique(event_id, user_id)
AuditLog: id, actor_type, actor_id nullable, action, target_type, target_id, metadata json, created_at, request_id
Notes:
Auth provider/session tables can be added later without breaking this core.
8) CLI interface contract
Binary name
appctl (placeholder)
Global flags
--env <local|staging|prod>
--json
--quiet
--no-color
--trace
--dry-run
--yes
--token <token> (overrides env var)
Exit codes
0 success
2 validation/usage error
3 auth/permission error
4 not found
5 conflict/already exists
6 precondition failed (e.g., migrations not run)
1 other error
Output rules
default: human readable (tables, one-line summaries)
--json: strict JSON object with:
ok, command, env, data, warnings[], errors[], request_id
9) Command set v0.1
9.1 Bootstrap / health
appctl init
creates config scaffold (non-destructive)
appctl doctor
verifies config, DB reachability, schema current, SQLite pragmas, permissions
9.2 Database lifecycle
appctl db status
shows current migration + pending count
appctl db migrate
applies migrations (idempotent), audit db.migrate
appctl db seed [--fixture <name>]
seeds roles + optional initial admin user, audit db.seed
appctl db backup --out <file>
produces consistent backup artifact, audit db.backup
appctl db restore --from <file>
local/staging only unless --env prod --force-prod + token, audit db.restore
CLI-only dangerous (optional v0.1):
appctl db reset
local only by default; requires --yes
9.3 Super-admin tokens (CLI-only)
appctl auth token create --name <label> [--ttl-days <n>]
prints token once; stores hash; audit auth.token.create
appctl auth token revoke --id <tokenId>
audit auth.token.revoke
9.4 Users (admin & super-admin)
appctl user create --email <email> [--status <PENDING|ACTIVE>]
audit user.create
appctl user list [--role <ROLE>] [--status <STATUS>] [--search <q>]
appctl user show --id <id> | --email <email>
appctl user disable --id <id> [--reason <text>]
audit user.disable
appctl user enable --id <id>
audit user.enable
appctl user role add --id <id> --role <ROLE>
audit user.role.add
appctl user role remove --id <id> --role <ROLE>
audit user.role.remove
9.5 Events (admin)
appctl event create --slug <slug> --title <title> --start <iso> --end <iso> --tz <IANA> [--capacity <n>]
creates DRAFT; audit event.create
appctl event update --slug <slug> [--title ...] [--start ...] [--end ...] [--capacity ...]
audit event.update
appctl event publish --slug <slug>
audit event.publish
appctl event cancel --slug <slug> --reason <text>
audit event.cancel
appctl event list [--status <...>] [--from <date>] [--to <date>]
9.6 Registrations (admin)
appctl reg add --event <slug> --user <email|id>
respects capacity; if full → WAITLISTED; audit registration.add
appctl reg remove --event <slug> --user <email|id> [--reason <text>]
sets status CANCELLED (no hard delete); audit registration.cancel
appctl reg list --event <slug> [--status <...>]
appctl checkin --event <slug> --user <email|id>
sets CHECKED_IN; audit registration.checkin
appctl event export --slug <slug> --format <csv|json> --out <file> [--include-email]
--include-email requires token outside local; audit event.export
10) Service layer contract (the “future UI bridge”)
The CLI must call domain services with stable interfaces (names illustrative):
DbService (migrate/seed/status/backup/restore)
UserService (create/disable/enable/assignRole)
EventService (create/update/publish/cancel/list)
RegistrationService (add/cancel/list/checkin/export)
AuditService (append + query later)
Phase 2+ requirement: API routes must call these same services. The UI never talks to DB directly.
11) Safety rails and permissions matrix
Default permission rules
In local: read commands allowed without token; write commands allowed without token (configurable)
In staging/prod: any write command requires token
Dangerous ops in prod require: token + --force-prod + --yes
Redaction rules
In staging/prod without token: never print PII (emails), never export PII
With token: PII allowed only when explicitly requested (e.g., --include-email)
12) Test and acceptance criteria (v0.1 “done means”)
Required automated checks:
Command help snapshots (stable CLI UX)
db seed idempotency test
event publish is idempotent and audited
capacity rule: when full → WAITLISTED
audit fail-closed: if audit insert fails, command fails and DB mutation is rolled back
doctor detects incorrect SQLite pragmas and schema mismatch
Operational checks:
backup/restore round-trip in CI (local env)
migration forward-only discipline enforced
13) Roadmap alignment (how v0.1 evolves)
v0.2–v0.3
Add “admin API endpoints” mirroring CLI operations (minus dangerous ops)
Add web admin UI pages for events/registrations/users
CLI stays “super-admin only” for:
token creation/revoke
DB backup/restore/reset
role elevation to SUPER_ADMIN
emergency disable users / emergency cancel event
v1.0
Formalize permissions, rate-limits, audit query UI, export governance, and data migration utilities to Postgres

===== FILE: project_management/letter2.md =====


===== FILE: project_management/letter3.md =====
Letter to AI Coding Agent — UI Phase (Consume API + Prepare for Production)
Team,
We have API Foundation + Auth Session + Users/Events/Registrations APIs + Hardening/Release completed and verified. Key invariants we must preserve:
UI must treat /api/v1 as the discoverable entry point and follow HAL _links affordances. 
sprint-07-api-foundation
Auth is browser-ready session-based with secure cookies + CSRF-safe mutations and role-aware HAL affordances via /api/v1/me. 
sprint-08-auth-session
 
sprint-08-auth-session
Events have state-driven HATEOAS action links (DRAFT→publish, PUBLISHED→cancel). 
sprint-10-events-api
Registrations must preserve WAITLISTED / CANCELLED / CHECKED_IN transitions and export governance (PII constraints). 
sprint-11-registrations-api
 
sprint-11-registrations-api
Hardening includes rate limiting and handler-level auth enforcement; UI should degrade gracefully and show Problem Details errors. 
sprint-12-api-hardening-release
Super-admin remains CLI-only (token issuance + DB backup/restore/dangerous ops do not get UI surfaces). 
sprint-03-auth-users
 
sprint-06-hardening-release
Our goal now: implement the UI (user-facing + admin console) in the Next.js App Router, consuming the API as a client.
0) UI Tech Choices (industry standard)
Use a conventional Next.js UI stack:
Next.js App Router for layouts/pages and server components where useful (official docs)
Auth.js integration already exists; follow Next.js auth guidance for App Router concepts
React Hook Form + Zod for forms + validation (single schema reuse where possible).
TanStack Query for client-side caching + mutation orchestration, with a thin HAL client underneath (keep HAL/HATEOAS central). (TanStack Query is a common production default; keep the integration minimal and well-contained.)
Tailwind + shadcn/ui (or Radix primitives) for fast, consistent, accessible components (buttons, dialogs, tables, toasts).
1) Non-negotiable UI Contracts
1.1 HATEOAS-first navigation
The UI must not hardcode action routes like “publish = POST /events/{slug}/publish”. Instead:
Fetch event resource → read _links["app:publish"].href (if present) → POST there.
Same for cancel, export, registrations links, etc.
This aligns with Sprint 10’s state-driven affordance contract. 
sprint-10-events-api
1.2 Error handling
All non-2xx responses are application/problem+json per the API contract. UI must:
Ren
sprint-10-events-api
alidation errors[] if present
Show request_id to the user (copy button) for support/debugging
This is grounded in Sprint 07’s Problem Details contract. 
sprint-07-api-foundation
 
sprint-07-api-foundation
1.3 Role gating via /api/v1/me
UI route access is driven by:
session presen
sprint-07-api-foundation
u
sprint-07-api-foundation
ities) 
sprint-08-auth-session
 
sprint-08-auth-session
1.4 Respect hardening behavior
If rate-limited (Sprint 12), UI must show a fri
sprint-08-auth-session
n
sprint-08-auth-session

sprint-12-api-hardening-release
2) UI Information Architecture
2.1 Public / User-facing
Routes (App Router):
/ → Landing (or redire
sprint-12-api-hardening-release
 → Published events list
/events/[slug] → Event detail (register/cancel if allowed)
/login, /register
/account → “My info” + “My registrations” (optional but recommended)
Behaviors:
Anonymous users can view published events and event details.
Authenticated users can register; if full, show WAITLISTED state. 
sprint-11-registrations-api
Users can cancel their registration (transitions to CANCELLED, no hard delete). 
sprint-11-registrations-api
  
sprint-11-registrations-api
es:
/admin → dashboard
/admin/events → list + create
/admin/events/[slug]
sprint-11-registrations-api
ons (only if links exist)
/admin/events/[slug]/registrations → list + add/cancel + check-in
/admin/events/[slug]/export → export UI (respect include_email governance)
/admin/users → list/show/status/role mgmt (no SUPER_ADMIN changes) 
sprint-09-users-api
Important:
Admin UI must never surface CLI-only operations (token create/revoke; db backup/restore). 
sprint-03-auth-users

sprint-09-users-api

sprint-06-hardening-release
3) The HAL Client (small but crucial)
Create lib/halClient with:
`getRoot()
sprint-03-auth-users
i
sprint-06-hardening-release

sprint-07-api-foundation
follow(resource, rel) → returns { href, method? }
request(relOrHref, {method, body}) → fetch wrapper th
sprint-07-api-foundation
 - sets accept headers (application/hal+json, application/problem+json)
parses Problem Details
returns typed Ok | Err(problem) shape for UI
This is what makes “HATEOAS real” rather than a decorative API format.
4) UI Security & Hygiene
Cookies are HttpOnly, so UI cannot read tokens; it just uses fetch(..., { credentials: 'include' }). 
sprint-08-auth-session
All mutations must be CSRF-safe (follow the existing server pattern; do not bypass by calling service methods d
sprint-08-auth-session

sprint-08-auth-session
Prevent privilege escalation:
never render role-grant UI for SUPER_ADMIN
rely on API denial as final ga
sprint-08-auth-session

sprint-09-users-api
5) UI Test Strategy (must match our engineering culture)
Component tests for critical forms and error rend
sprint-09-users-api
ensuring we follow _links (mock HAL resources)
E2E tests (Playwright recommended) covering:
register/login/logout
browse events
register/waitlist/cancel
admin event create→publish→cancel with state-dependent links 
sprint-10-events-api
registrations + check-in flows 
sprint-11-registrations-api
export governance (include_email blocked un
sprint-10-events-api

sprint-11-registrations-api
Proposed U
sprint-11-registrations-api
 — UI Foundation + Design System
App Router layouts, navigation, 
sprint-11-registrations-api
t + Problem Details renderer (with request_id)
Protected route scaffolding for /admin/* using /api/v1/me links 
sprint-08-auth-session
Sprint 14 — Public Events UI
/events list + paging/filter controls (based on HAL)
/events/[slug] det
sprint-08-auth-session
us and available actions via _links 
sprint-10-events-api
Sprint 15 — Auth Pages + Account
/login, /register, /account
Use API endpoints from Sprint 08; han
sprint-10-events-api
ils 
sprint-08-auth-session
 
sprint-12-api-hardening-release
Sprint 16 — Registration UX
Register from event page
Show WAITLISTED / REGIS
sprint-08-auth-session
a
sprint-12-api-hardening-release
ard delete) 
sprint-11-registrations-api
Sprint 17 — Admin Events Console
/admin/events list + create
/admin/events/[slug] edit + publish/can
sprint-11-registrations-api
appear only if the HAL links exist (state-driven affordances) 
sprint-10-events-api
Sprint 18 — Admin Registrations + Check-in + Export
Registrations list + add/cancel + check-in
Export UI
sprint-10-events-api
 (include_email gating) 
sprint-11-registrations-api
 
sprint-11-registrations-api
Sprint 19 — Admin Users UI
List/search users
Enable/disable
Add/remove r
sprint-11-registrations-api
d
sprint-11-registrations-api

sprint-09-users-api
Sprint 20 — UI Hardening + E2E + Release Gate
Playwright suite
Accessibility pass (keyboard nav, labels,
sprint-09-users-api
polish (Problem Details everywhere)
Ensure no new escalation surfaces (SUPER_ADMIN remains CLI-only) 
sprint-03-auth-users
Exit Gate for “UI Phase 1”
We consider UI Phase 1 complete when:
All public flows work end-to-end agains
sprint-03-auth-users
 not hardcoded routes 
sprint-07-api-foundation
Admin can run the full lifecycle: create → publish → registrations → check-in → export (with governance) 
sprint-10-events-api

sprint-07-api-foundation

sprint-11-registrations-api
E2E tests pass and capture request_id on failures
No UI surface exists for CLI-on
sprint-10-events-api

sprint-06-hardening-release

sprint-11-registrations-api
—End of letter.

===== FILE: project_management/letter4.md =====
Here’s a comprehensive **positive + negative E2E test inventory** for everything that’s web-accessible today (UI + HTTP API), plus a set of **missing “complete app” features** and the E2E tests you’d add if you decide to ship them.

I’m assuming you’ll run these with Playwright (as implied by the UI hardening sprint). 

---

## Test data setup you should standardize (so E2E is deterministic)

Create fixtures/seeds for E2E that always include:

* Users: `userA` (USER), `adminA` (ADMIN), optionally `staffA` if you have STAFF flows.
* Events:

  1. `published-open` (PUBLISHED, capacity available)
  2. `published-full` (PUBLISHED, capacity full)
  3. `draft-event` (DRAFT, admin-visible)
  4. `cancelled-event` (CANCELLED, read-only)
* Registrations:

  * `userA` registered for `published-open` (REGISTERED)
  * `published-full` already at capacity so new adds become WAITLISTED
    This aligns with the domain transitions and UI expectations in the events + registration sprints.   

---

# A) E2E tests for CURRENT FEATURES

## 1) API foundation & contracts (smoke + regression)

These validate the API is “UI consumable” and stable.

### Positive

1. **API root is discoverable**

   * `GET /api/v1` returns `application/hal+json` and contains `_links.self` + navigation links. 
2. **Docs endpoint exists**

   * `GET /api/v1/docs` returns OpenAPI skeleton (or real spec) with 200. 
3. **Request correlation present**

   * Trigger any known error and verify `request_id` is returned (header + body extension on Problem Details). 

### Negative

4. **Problem Details contract always used**

   * Call a missing endpoint → verify `application/problem+json` with `type/title/status/detail/instance` and `request_id`. 
5. **Content-type correctness**

   * Ensure success responses are `application/hal+json` and errors are `application/problem+json` across representative endpoints. 

---

## 2) Auth & session (web)

These map directly to `/register`, `/login`, `/logout`, `/account`, and the underlying auth endpoints.

### Positive

1. **Register → login session established**

   * UI: `/register` create account → redirect / navigate to authenticated state → `/account` accessible. 
2. **Login sets session**

   * UI: `/login` valid creds → `/account` loads and shows `/api/v1/me` info.  
3. **Logout clears session**

   * UI: logout → `/account` becomes gated and redirects/blocks. 
4. **Role-aware affordances**

   * `GET /api/v1/me` returns role-aware HAL links (admin sees admin affordances). 

### Negative

5. **Invalid credentials**

   * UI login with wrong password → renders Problem Details (friendly) and displays `request_id`. 
6. **Rate limited login/register**

   * Rapid-fire login/register attempts → 429 surfaced with friendly UI + request_id.  
7. **CSRF-safe mutation behavior**

   * Attempt cross-site/invalid CSRF mutation pattern (where applicable) → blocked; UI shows Problem Details. 
8. **Session expiry behavior**

   * Simulate expired session (clear cookie) → `/account` gated; admin pages gated. 

---

## 3) Public events browsing (anonymous + logged-in)

### Positive

1. **Events list renders**

   * `/events` loads from API, supports paging/filter controls (as implemented). 
2. **Event detail renders**

   * `/events/[slug]` loads and shows event info and state. 

### Negative

3. **Non-existent event slug**

   * `/events/bad-slug` → show 404-like UX via Problem Details renderer + request_id.  
4. **API failure surfaced cleanly**

   * Force API 500 (or intercept) → UI shows consistent error and request_id. 

---

## 4) HATEOAS compliance in UI (critical)

These ensure the UI truly follows HAL `_links`, not hardcoded endpoints.

### Positive

1. **Admin publish/cancel controls only appear when links exist**

   * Admin opens DRAFT event: Publish button visible.
   * Admin opens PUBLISHED event: Cancel visible.
   * Admin opens CANCELLED event: neither visible.  
2. **UI performs actions via the HAL href**

   * Intercept the HAL response and modify the publish/cancel link href (test server or Playwright route) → verify UI posts to that href (not the default path). This is the strongest “HATEOAS proof.”  

### Negative

3. **Affordance removed ⇒ action blocked**

   * Return an event without `app:publish` link → publish action must not be possible (no button; no request). 
4. **Stale UI (race)**

   * Publish in one tab; other tab still shows publish button → next click should fail gracefully (Problem Details), refresh state, remove button. 

---

## 5) User registration UX on event detail

### Positive

1. **Register for open event ⇒ REGISTERED**

   * User registers on `published-open` → shows REGISTERED badge/state. 
2. **Register for full event ⇒ WAITLISTED**

   * User registers on `published-full` → shows WAITLISTED.  
3. **Cancel registration**

   * Cancel action transitions to CANCELLED state (no hard delete).  

### Negative

4. **Duplicate registration attempt**

   * Try registering twice → conflict or “already registered” UX; no duplicate state created. 
5. **Register while logged out**

   * Attempt register action → redirected to login or blocked with message. 
6. **Cancel when not registered**

   * UI should hide cancel or show controlled error. 

---

## 6) Admin events console

### Positive

1. **Admin access gate**

   * Non-admin visits `/admin/events` → blocked/redirected.  
2. **Create event**

   * Valid create form → new DRAFT event appears in list. 
3. **Edit event**

   * Update title/time/capacity → persists and reflected on reload. 
4. **Publish event (idempotent)**

   * Publish once succeeds; publish again either hidden (link removed) or safe. 
5. **Cancel event with reason**

   * Cancel requires reason; status changes to CANCELLED. 

### Negative

6. **Create validation errors**

   * Missing fields/invalid ISO times → Problem Details field errors displayed. 
7. **Slug conflict**

   * Create event with existing slug → conflict error displayed. 
8. **Cancel without reason**

   * Should fail and show validation error. 

---

## 7) Admin registrations, check-in, export

### Positive

1. **Registrations list loads**

   * `/admin/events/[slug]/registrations` shows current registrations + statuses. 
2. **Admin adds registration**

   * Add user to event; if full ⇒ WAITLISTED.  
3. **Admin cancels registration (soft)**

   * Cancel sets CANCELLED, history retained. 
4. **Check-in allowed transitions**

   * Check-in changes to CHECKED_IN from allowed states. 
5. **Export CSV/JSON**

   * Export from `/admin/events/[slug]/export` succeeds for csv/json formats.  
6. **Request IDs visible on blocked export**

   * Trigger a blocked include_email case; verify Problem Details + request_id shown in UI.  

### Negative

7. **Check-in invalid state**

   * Attempt check-in for CANCELLED (or disallowed) → blocked with Problem Details. 
8. **Export include_email governance**

   * Outside local or without token/permission, include_email must be denied; UI displays governance error.  
9. **Export rate limiting**

   * Rapid export requests trigger 429 and UI handles it. 
10. **Add registration for unknown user**

* Should fail with not-found Problem Details. 

---

## 8) Admin users UI (non-escalation)

### Positive

1. **Users list/search/filter**

   * `/admin/users` loads list; search works. 
2. **Enable/disable user**

   * Disable a user, verify they can’t log in; enable restores.  
3. **Add/remove ADMIN role (idempotent)**

   * Add role twice: second is no-op; remove twice: second no-op. 

### Negative

4. **No SUPER_ADMIN escalation in UI**

   * Confirm no UI control exists to add/remove SUPER_ADMIN. 
5. **Attempt SUPER_ADMIN escalation via API denied**

   * Direct API request as admin tries to grant SUPER_ADMIN → denied. 
6. **Unauthorized access**

   * USER tries `/admin/users` directly → gated/redirected. 

---

## 9) Security + hardening behaviors (UI-visible)

### Positive

1. **Handler-level auth enforcement**

   * Try accessing admin mutation endpoints without session → 401/403 with Problem Details. 
2. **No-store caching on auth/user endpoints**

   * Verify `Cache-Control: no-store` on `/api/v1/me` and auth endpoints (helps prevent leakage). 

### Negative

3. **Rate limiting behavior visible**

   * Login/register/export 429 surfaced in UI without crashes. 
4. **Escalation-surface check**

   * Confirm UI does not expose CLI-only dangerous ops (db backup/restore, token issuance).   

---

## 10) “Release gate” journeys (the big end-to-end paths)

These are the journeys Sprint 20 calls out as required for release. 

### Positive

1. **Public journey**

   * Browse `/events` → open detail → register → see status → cancel → see CANCELLED. 
2. **Admin journey**

   * Admin create event → publish → add registration → check-in → export. 
3. **Supportability**

   * Force an API error anywhere in journey and verify UI shows `request_id`.  

### Negative

4. **Regression journey: role downgrade mid-session**

   * Admin loses role (via API/fixture) and refreshes admin page → must lose access immediately. 

---

# B) “Missing features” for a truly complete event app (and the E2E tests they imply)

Your current system is already a coherent “MVP event platform” (auth, RBAC, events, registrations, check-in, export). What’s *commonly required* for a “complete application” depends on your target (internal events vs public production). Below are the typical gaps and their test inventories.

## 1) Password reset / account recovery (missing)

**Why it matters:** Without it, users who forget passwords are stuck.

### E2E tests

* Positive: request reset → receive token/link (test inbox or token capture) → set new password → login works.
* Negative: expired token, reused token, invalid email, rate-limited reset requests.

## 2) Email verification (optional but common)

**Why it matters:** Prevents fake signups and improves deliverability.

### E2E tests

* Positive: register → verification required → verify link → account becomes ACTIVE.
* Negative: unverified user cannot register for events; expired verification link; resend verification rate limit.

## 3) Admin invitation flows (missing)

Right now admins are managed via admin UI/CLI rules (and SUPER_ADMIN is blocked in UI).  
For a “complete app,” you often need an “invite admin” flow (without opening escalation holes).

### E2E tests

* Positive: admin sends invite → invited user accepts → gains ADMIN (not SUPER_ADMIN).
* Negative: invite reuse, invite expiry, invite sent to existing account, unauthorized invite attempt.

## 4) User “My registrations” / receipts / confirmations (partial)

Sprint 15 mentions `/account` and a “basic registration summary.” 
If you want completeness, formalize it.

### E2E tests

* Positive: user sees all registrations across events; status updates live after cancel/check-in.
* Negative: privacy—user cannot see other users’ registrations.

## 5) Event discovery quality (search, tags, calendar)

Not required, but often expected.

### E2E tests

* Search by title/location/tags (if added), filters persist in URL, pagination stable.
* Calendar export (ICS) if you add it: link downloads valid ICS; timezones correct.

## 6) Audit log UI (missing, but “enterprise complete”)

You already rely on audit for fail-closed mutations at the domain level.  
If you want a complete admin experience, add an audit viewer.

### E2E tests

* Positive: admin views audit entries for publish/cancel/export, filters by actor/action.
* Negative: non-admin cannot access; PII redaction in audit metadata as needed.

## 7) Compliance basics (Terms/Privacy, data retention)

Often needed for real public use.

### E2E tests

* Terms/privacy pages accessible; registration requires checkbox acknowledgement (if implemented).
* Data export retention rules, and “delete account” flow (if you add it).

---

# Minimal “E2E completeness checklist” (if you want to call this “done”)

If you implement E2E for all items in section A, you will cover:

* Auth/session lifecycle + hardening behaviors  
* Public events browse/detail + HAL-driven affordances  
* Registration transitions (REGISTERED/WAITLISTED/CANCELLED/CHECKED_IN)  
* Admin event lifecycle and admin operations  
* Non-escalation and CLI-only boundaries   

If you also add the “missing” features in section B, you’ll be closer to a fully public “complete app” rather than a tight MVP.

If you want, I can turn this list into a **test plan artifact** with: IDs, prerequisites (seed state), steps, and expected results (including the exact Problem Details fields you should assert).


===== FILE: project_management/sprints/completed/all-sprints-combined.md =====
# sprint-01-foundation.md

# Sprint 01 — Foundation & Test Harness

## Goal
Establish a production-grade CLI foundation (`appctl`) with a strict TDD workflow, stable command UX, config loading precedence, validation, logging, and deterministic test infrastructure.

## Scope
- Initialize CLI runtime with TypeScript + Node 20.
- Add command framework (`Commander`) and global flags contract.
- Implement config loading precedence:
  1. CLI flags
  2. environment variables
  3. config file
  4. defaults
- Implement baseline output contract:
  - human-readable default
  - `--json` strict response shape
- Implement exit code mapping contract.
- Add command help and usage snapshots.
- Add shared test utilities for CLI execution and fixtures.

## TDD Process
For every feature in this sprint:
1. Write failing tests/spec first.
2. Implement minimum code to pass.
3. Refactor while preserving green tests.
4. Commit only when all tests pass locally.

Required test layers:
- Unit tests: parsing, config merge, output formatting, exit-code mapper.
- Contract tests: global flags and JSON envelope schema.
- Snapshot tests: command help output.

## Stories
- As an operator, I can run `appctl --help` and see stable command docs.
- As an operator, I can pass `--env` and `--json` globally.
- As a developer, I can rely on deterministic config precedence.
- As CI, I can fail fast on contract regressions.

## Acceptance Criteria
- `appctl --help` returns exit code `0` and matches approved snapshot.
- Global flags parse correctly and are available to command handlers.
- `--json` output always returns:
  - `ok`, `command`, `env`, `data`, `warnings[]`, `errors[]`, `request_id`.
- Usage/validation errors exit with code `2`.
- Unexpected errors exit with code `1`.
- Config precedence behaves exactly as specified.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test
npm run lint
npm run build
npm run cli -- --help
npm run cli -- --json --env local doctor
```

Pass condition (required to close sprint):
- 100% of Sprint 01 tests pass.
- All verification commands exit `0`.
- No snapshot diffs unless intentionally updated and approved.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint CLI verification passes.
- Open defects for sprint scope = 0.


---

# sprint-02-db-core.md

# Sprint 02 — Database Core (Status, Migrate, Seed, Doctor)

## Goal
Deliver reliable DB lifecycle primitives with idempotent behavior and strict health checks for SQLite production profile.

## Scope
- Implement `db status`, `db migrate`, `db seed`, `doctor`.
- Integrate Drizzle ORM + drizzle-kit migrations.
- Enforce/verify SQLite requirements (WAL, FK, busy timeout, path validity).
- Ensure seed is idempotent (roles and bootstrap data).
- Add fail-closed audit behavior for state-changing commands.

## TDD Process
For each command/edge case:
1. Write failing tests for success path and invariant violations.
2. Implement minimal behavior.
3. Add idempotency and rollback tests.
4. Refactor service interfaces with tests green.

Required test layers:
- Unit tests: pragma checks, migration status resolver.
- Integration tests: migrate/seed idempotency, doctor validation.
- Failure-path tests: audit failure causes command failure.

## Stories
- As an operator, I can confirm schema status before writes.
- As an operator, I can run migrations safely multiple times.
- As an operator, I can seed without duplicate corruption.
- As an operator, I can detect bad SQLite runtime settings.

## Acceptance Criteria
- `db migrate` is idempotent and audited.
- `db seed` is idempotent and audited.
- `doctor` fails when WAL/FK are not enabled.
- `doctor` fails on schema mismatch.
- Any audit write failure aborts mutation (fail-closed).
- Precondition failures return exit code `6`.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- db
npm run cli -- db status --env local
npm run cli -- db migrate --env local
npm run cli -- db migrate --env local
npm run cli -- db seed --env local
npm run cli -- db seed --env local
npm run cli -- doctor --env local --json
```

Pass condition (required to close sprint):
- 100% of Sprint 02 DB tests pass.
- Re-running migrate/seed yields no duplicates or corruption.
- All verification commands exit `0` for healthy setup.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint CLI verification passes.
- Idempotency evidence is attached in sprint notes.


---

# sprint-03-auth-users.md

# Sprint 03 — Auth Tokens & User Management

## Goal
Implement super-admin token operations and user/role commands with permission rails aligned to environment policy.

## Scope
- Implement token commands:
  - `auth token create`
  - `auth token revoke`
- Implement user commands:
  - `user create`, `user list`, `user show`
  - `user disable`, `user enable`
  - `user role add`, `user role remove`
- Enforce role and token checks for write operations in staging/prod.
- Ensure token hashing at rest and one-time token display.
- Audit all state mutations.

## TDD Process
- Write failing tests for each command and permission branch first.
- Add tests for token hashing and revocation behavior.
- Add tests for role assignment uniqueness and conflict handling.
- Refactor services only with green test suite.

Required test layers:
- Unit tests: permission guard, role resolver, token verifier.
- Integration tests: command-to-service wiring, audit writes.
- Security tests: no plaintext token persistence.

## Stories
- As a super-admin, I can issue and revoke service tokens.
- As an admin, I can create and manage user status.
- As a super-admin, I can assign/revoke roles safely.
- As operator, I can trust mutation auditability.

## Acceptance Criteria
- Token is shown once on create; only hash stored.
- Revoked token cannot authorize writes.
- User create enforces unique email.
- Role add/remove are idempotent and audited.
- Staging/prod write commands fail with exit code `3` when unauthorized.
- Not-found and conflict paths return specified exit codes.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- auth user
npm run cli -- auth token create --name sprint3 --env local --json
npm run cli -- user create --email admin@example.com --status ACTIVE --env local
npm run cli -- user role add --id <USER_ID> --role ADMIN --env local
npm run cli -- user disable --id <USER_ID> --reason "verification" --env local
npm run cli -- auth token revoke --id <TOKEN_ID> --env local
```

Pass condition (required to close sprint):
- 100% of Sprint 03 tests pass.
- Authorization and revocation checks behave as expected.
- All verification commands exit `0` for expected paths.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint CLI verification passes.
- Security review checklist items are complete.


---

# sprint-04-events.md

# Sprint 04 — Event Lifecycle

## Goal
Deliver robust event lifecycle commands with validation, idempotent publish behavior, and full mutation auditing.

## Scope
- Implement commands:
  - `event create`
  - `event update`
  - `event publish`
  - `event cancel`
  - `event list`
- Enforce slug uniqueness and time validation.
- Ensure publish is idempotent and audited.
- Ensure cancellation reason requirements and audit metadata.

## TDD Process
- Start each command with failing contract tests.
- Add edge-case tests for date/timezone and conflict behavior.
- Add idempotency tests for repeated publish/cancel attempts.
- Refactor service layer with unchanged command contract.

Required test layers:
- Unit tests: input validation and state transitions.
- Integration tests: create→update→publish→cancel flow.
- Audit tests: every mutation creates audit log.

## Stories
- As an admin, I can create events in `DRAFT` state.
- As an admin, I can publish an event safely once.
- As an admin, I can cancel with an explicit reason.
- As an operator, I can list by status/date filters.

## Acceptance Criteria
- Event create enforces required fields and valid ISO times.
- Update modifies only provided fields.
- Publish is idempotent and audited.
- Cancel sets `CANCELLED` and stores audit reason metadata.
- List supports status/from/to filters.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- event
npm run cli -- event create --slug spring-launch --title "Spring Launch" --start 2026-04-01T14:00:00Z --end 2026-04-01T15:00:00Z --tz UTC --env local
npm run cli -- event publish --slug spring-launch --env local
npm run cli -- event publish --slug spring-launch --env local
npm run cli -- event cancel --slug spring-launch --reason "verification" --env local
npm run cli -- event list --status CANCELLED --env local --json
```

Pass condition (required to close sprint):
- 100% of Sprint 04 tests pass.
- Repeated publish does not duplicate or corrupt state.
- All verification commands exit `0` for expected paths.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint CLI verification passes.
- Event domain invariants are documented.


---

# sprint-05-registrations-export.md

# Sprint 05 — Registrations, Check-in, Export

## Goal
Implement registration workflows with capacity/waitlist behavior, check-in flow, and governed export outputs with PII controls.

## Scope
- Implement commands:
  - `reg add`, `reg remove`, `reg list`
  - `checkin`
  - `event export`
- Enforce capacity rule: full event => `WAITLISTED`.
- Enforce no hard delete on remove (`CANCELLED` state transition).
- Implement export to CSV/JSON with security redaction rules.
- Require token for `--include-email` outside local.

## TDD Process
- Begin with failing tests for capacity and state transitions.
- Add regression tests for duplicate registration attempts.
- Add authorization/redaction tests for PII export paths.
- Refactor internals with no contract breakage.

Required test layers:
- Unit tests: status transitions and export formatter.
- Integration tests: event capacity scenarios and check-in behavior.
- Security tests: PII redaction without proper token context.

## Stories
- As an admin, I can register users and respect capacity limits.
- As an admin, I can cancel registrations without deleting history.
- As staff, I can check users in at event time.
- As operator, I can export registration data safely.

## Acceptance Criteria
- Full events place new registrations in `WAITLISTED`.
- `reg remove` transitions status to `CANCELLED`.
- `checkin` transitions to `CHECKED_IN` from allowed states.
- Export supports CSV/JSON and writes file correctly.
- PII behavior follows token + environment rules.
- All mutations are audited.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- registration export
npm run cli -- reg add --event spring-launch --user admin@example.com --env local
npm run cli -- reg list --event spring-launch --env local --json
npm run cli -- checkin --event spring-launch --user admin@example.com --env local
npm run cli -- event export --slug spring-launch --format csv --out ./tmp/spring-launch.csv --env local
npm run cli -- event export --slug spring-launch --format json --out ./tmp/spring-launch.json --env local
```

Pass condition (required to close sprint):
- 100% of Sprint 05 tests pass.
- Capacity/waitlist and check-in rules behave correctly.
- All verification commands exit `0` and output files are generated.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint CLI verification passes.
- Export governance checks are documented and approved.


---

# sprint-06-hardening-release.md

# Sprint 06 — Backup/Restore Hardening, CI, Release Readiness

## Goal
Finalize operational safety for dangerous commands, validate backup/restore reliability, and enforce release gates in CI.

## Scope
- Implement and harden:
  - `db backup`
  - `db restore`
  - optional `db reset` safety rails
- Enforce dangerous-op rules in prod:
  - token required
  - `--force-prod`
  - `--yes`
- Add backup/restore round-trip checks in CI.
- Ensure migration forward-only discipline guardrails.
- Finalize docs/runbooks for operational usage.

## TDD Process
- Write failing tests for each dangerous command guard.
- Add tests for local/staging/prod behavior differences.
- Add round-trip restore verification tests.
- Refactor only with green full-suite and CLI smoke tests.

Required test layers:
- Unit tests: guard rails, confirmation flags, env gating.
- Integration tests: backup artifact + restore round-trip.
- CI workflow tests: sprint-close gate script.

## Stories
- As a super-admin, I can create reliable backups.
- As a super-admin, I can restore safely with explicit intent.
- As operator, I can trust CI to block unsafe regressions.
- As team, I can release only with verified CLI correctness.

## Acceptance Criteria
- Backup uses safe method and produces valid artifact.
- Restore default is local/staging only; prod requires explicit overrides.
- Dangerous commands in prod fail without all required flags/token.
- Round-trip backup/restore passes in CI local profile.
- Full CLI contract tests pass (help, JSON shape, exit codes).

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test
npm run lint
npm run build
npm run cli -- db backup --out ./tmp/backup.db --env local
npm run cli -- db restore --from ./tmp/backup.db --env local --yes
npm run cli -- doctor --env local --json
```

Pass condition (required to close sprint):
- 100% of Sprint 06 tests pass.
- Full project CI-equivalent command set exits `0`.
- Backup/restore round-trip verified and documented.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint CLI verification passes.
- Release checklist is fully green.


---

# sprint-07-api-foundation.md

# Sprint 07 — API Foundation (HAL + Problem Details + OpenAPI Skeleton)

## Goal
Establish the HTTP transport foundation for `/api/v1` with HAL success responses, RFC 9457 Problem Details errors, request correlation, and initial OpenAPI 3.1 contract publication.

## Scope
- Create base route scaffolding for Next.js Route Handlers under `/api/v1`.
- Add shared response builders:
  - HAL (`application/hal+json`)
  - Problem Details (`application/problem+json`)
- Implement request correlation (`request_id`) in headers and error bodies.
- Implement API root discoverability endpoint: `GET /api/v1`.
- Add OpenAPI 3.1 skeleton endpoint: `GET /api/v1/docs`.
- Add transport-layer guardrails: no business logic in handlers.

## TDD Process
For every endpoint and shared builder:
1. Write failing contract tests first.
2. Implement minimal transport behavior.
3. Refactor with strict backward-compatibility on response contracts.
4. Keep green tests before merging.

Required test layers:
- Contract tests for HAL response shape and required `_links`.
- Contract tests for Problem Details fields (`type/title/status/detail/instance` + `request_id`).
- Tests for content-type correctness per endpoint.

## Stories
- As a UI client, I can discover API entry links from `/api/v1`.
- As an integrator, I receive standardized error payloads.
- As ops, I can correlate errors using `request_id`.
- As developers, we have a single response formatting foundation.

## Acceptance Criteria
- `/api/v1` returns `application/hal+json` with `_links.self` and top-level navigation links.
- Errors return `application/problem+json` and RFC 9457 canonical fields.
- Every error body includes `request_id` extension member.
- OpenAPI skeleton is accessible at `/api/v1/docs`.
- Route handlers call shared builders and avoid direct business-rule duplication.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- api foundation
npm run lint
npm run build
npm run dev
# then manually verify:
# GET /api/v1
# GET /api/v1/docs
```

Pass condition (required to close sprint):
- 100% of Sprint 07 tests pass.
- HAL and Problem Details contracts are stable and validated.
- `/api/v1` and `/api/v1/docs` return expected payload shapes.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint verification passes.
- API contract snapshot changes are reviewed/approved.


---

# sprint-08-auth-session.md

# Sprint 08 — Auth & Session (UI-Ready)

## Goal
Implement secure browser-ready authentication and identity endpoints (`register/login/logout/me`) with session cookies, CSRF-safe mutation patterns, and role-aware HAL affordances.

## Scope
- Integrate Auth.js credentials flow for session-based auth.
- Implement password hashing (argon2id preferred, fallback bcrypt only if justified).
- Build endpoints:
  - `POST /api/v1/auth/register`
  - `POST /api/v1/auth/login`
  - `POST /api/v1/auth/logout`
  - `GET /api/v1/me`
- Configure secure cookie policy:
  - `HttpOnly`
  - `Secure` in prod
  - `SameSite=Lax` (or stricter where validated)
- Ensure CSRF-safe mutation behavior.
- Ensure no super-admin escalation paths via API.

## TDD Process
For each endpoint and auth guard:
1. Write failing auth/session contract tests.
2. Implement minimal pass behavior.
3. Add CSRF and cookie-flag regression tests.
4. Refactor with green tests and unchanged contracts.

Required test layers:
- Contract tests for auth endpoint responses and status codes.
- Security tests for cookie flags and session lifecycle.
- RBAC tests for `/me` affordance links.

## Stories
- As a user, I can register and login through browser-safe sessions.
- As a user, I can logout and invalidate my session.
- As a client app, I can query `/me` and discover allowed actions.
- As security reviewers, we can verify cookie and CSRF protections.

## Acceptance Criteria
- Register creates `USER` role account with expected status.
- Login sets correct secure session cookie semantics.
- Logout clears session.
- `/me` returns role-aware HAL links.
- Mutating auth routes are CSRF-safe.
- No endpoint grants SUPER_ADMIN or token issuance via HTTP API.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- auth session me
npm run lint
npm run build
npm run dev
# manual/API checks:
# POST /api/v1/auth/register
# POST /api/v1/auth/login
# GET /api/v1/me
# POST /api/v1/auth/logout
```

Pass condition (required to close sprint):
- 100% of Sprint 08 tests pass.
- Session lifecycle and cookie security checks pass.
- `/me` links correctly reflect role permissions.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint verification passes.
- Security checklist for auth/session is fully green.


---

# sprint-09-users-api.md

# Sprint 09 — Users API (Admin)

## Goal
Deliver admin user-management HTTP endpoints aligned with CLI invariants and non-escalation rules, including RBAC enforcement and audited mutations.

## Scope
- Implement endpoints:
  - `GET /api/v1/users`
  - `GET /api/v1/users/{id}`
  - `PATCH /api/v1/users/{id}`
  - `POST /api/v1/users/{id}/roles`
  - `DELETE /api/v1/users/{id}/roles/{role}`
- Reuse existing domain/service logic from CLI-backed services.
- Enforce non-escalation rule:
  - No SUPER_ADMIN role grant/revoke via HTTP API.
- Add HAL links for admin affordances.
- Ensure all mutations are audited and fail-closed on audit failure.

## TDD Process
1. Write failing endpoint contract tests.
2. Implement minimal handler + service integration.
3. Add RBAC matrix tests (USER/ADMIN/STAFF where applicable).
4. Refactor with contract snapshots stable.

Required test layers:
- Response contract tests (HAL + Problem Details).
- RBAC matrix tests for each endpoint.
- Idempotency tests for role add/remove.

## Stories
- As an admin, I can list/filter users.
- As an admin, I can inspect and update user status.
- As an admin, I can add/remove non-super roles idempotently.
- As security, I can verify API cannot escalate SUPER_ADMIN.

## Acceptance Criteria
- Unique email and user integrity rules remain enforced.
- Role add/remove remain idempotent.
- SUPER_ADMIN role changes via API are denied.
- Not-found/conflict errors use Problem Details consistently.
- Mutation endpoints produce audit records.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- users api rbac
npm run lint
npm run build
npm run dev
# manual/API checks:
# GET /api/v1/users
# GET /api/v1/users/{id}
# PATCH /api/v1/users/{id}
# POST /api/v1/users/{id}/roles
# DELETE /api/v1/users/{id}/roles/{role}
```

Pass condition (required to close sprint):
- 100% of Sprint 09 tests pass.
- RBAC matrix and non-escalation behavior are validated.
- All user mutation paths are audited.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint verification passes.
- Non-escalation controls are explicitly documented.


---

# sprint-10-events-api.md

# Sprint 10 — Events API (Admin + Public Read)

## Goal
Expose event lifecycle over HTTP while preserving Sprint 04 domain invariants and state-driven HATEOAS affordances.

## Scope
- Implement endpoints:
  - `GET /api/v1/events` (filter + paging)
  - `POST /api/v1/events`
  - `GET /api/v1/events/{slug}`
  - `PATCH /api/v1/events/{slug}`
  - `POST /api/v1/events/{slug}/publish`
  - `POST /api/v1/events/{slug}/cancel`
- Preserve event lifecycle invariants from CLI domain services.
- Implement state-dependent HAL action links:
  - DRAFT => `app:publish`
  - PUBLISHED => `app:cancel`
  - CANCELLED => read-only links
- Ensure mutation paths are audited.

## TDD Process
1. Write failing contract tests for each endpoint + state link matrix.
2. Implement minimal handlers calling shared services.
3. Add idempotency tests for publish.
4. Refactor while keeping HAL/Problem contracts stable.

Required test layers:
- HAL link relation tests by event status.
- Validation tests for event updates and cancel reason.
- RBAC tests for write endpoints.

## Stories
- As an admin, I can create/update/publish/cancel events via API.
- As a client, I can discover allowed actions through `_links`.
- As operators, we retain audit trail for event mutations.

## Acceptance Criteria
- Event lifecycle semantics match Sprint 04 behavior.
- Publish remains idempotent.
- Cancel requires reason and stores audit metadata.
- List endpoint supports filters and paging metadata.
- HAL links correctly reflect event state.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- events api hateoas
npm run lint
npm run build
npm run dev
# manual/API checks:
# GET /api/v1/events?status=DRAFT
# POST /api/v1/events
# POST /api/v1/events/{slug}/publish
# POST /api/v1/events/{slug}/cancel
# GET /api/v1/events/{slug}
```

Pass condition (required to close sprint):
- 100% of Sprint 10 tests pass.
- HAL link matrix by state is correct.
- Event mutation audit coverage is complete.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint verification passes.
- Event API contract snapshots are approved.


---

# sprint-11-registrations-api.md

# Sprint 11 — Registrations, Check-in, Export API

## Goal
Expose registration/check-in/export API endpoints that preserve Sprint 05 business rules, redaction governance, and audit guarantees.

## Scope
- Implement endpoints:
  - `GET /api/v1/events/{slug}/registrations`
  - `POST /api/v1/events/{slug}/registrations`
  - `DELETE /api/v1/events/{slug}/registrations/{userId}`
  - `POST /api/v1/events/{slug}/checkins`
  - `GET /api/v1/events/{slug}/export?format=csv|json&include_email=...`
- Preserve capacity/waitlist behavior.
- Preserve cancellation semantics (state transition, no hard delete).
- Preserve check-in transition rules.
- Enforce export PII governance and role/token restrictions.
- Ensure all mutation and export actions are audited.

## TDD Process
1. Write failing contract and rules tests first.
2. Implement minimal handler + service integration.
3. Add security tests for `include_email` governance.
4. Refactor while preserving HAL/Problem contracts.

Required test layers:
- Capacity/waitlist transition tests.
- Export format and redaction tests.
- Authorization and audit tests for export/check-in/mutation paths.

## Stories
- As admin/staff, I can manage registrations and check-ins safely.
- As operator, I can export event data with governance controls.
- As security, I can verify PII is not exposed without proper authorization.

## Acceptance Criteria
- Full events push new registrations to WAITLISTED.
- Delete endpoint transitions registrations to CANCELLED.
- Check-in transitions to CHECKED_IN only from allowed states.
- Export supports CSV and JSON streaming/output.
- `include_email` behavior follows environment + token rules.
- All mutation/export actions are audited.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- registrations api export
npm run lint
npm run build
npm run dev
# manual/API checks:
# POST /api/v1/events/{slug}/registrations
# GET /api/v1/events/{slug}/registrations
# POST /api/v1/events/{slug}/checkins
# GET /api/v1/events/{slug}/export?format=csv
# GET /api/v1/events/{slug}/export?format=json&include_email=true
```

Pass condition (required to close sprint):
- 100% of Sprint 11 tests pass.
- Transition rules and export governance are validated.
- Audit coverage is complete for registration/check-in/export actions.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint verification passes.
- Data export governance checks are explicitly documented.


---

# sprint-12-api-hardening-release.md

# Sprint 12 — API Hardening, Security Regression, Release Readiness

## Goal
Harden API operations for production with abuse controls, defense-in-depth authorization enforcement, and release-ready operational runbooks.

## Scope
- Implement initial rate limiting for:
  - login
  - register
  - export endpoints
- Enforce security headers and no-store cache rules for auth/user endpoints.
- Ensure authorization checks are enforced in handlers (not middleware-only reliance).
- Add API-focused production runbooks and release checklist.
- Expand regression suite for auth bypass and edge-case security paths.

## TDD Process
1. Write failing security/abuse tests first.
2. Implement minimal controls to satisfy contracts.
3. Add regression tests for bypass patterns.
4. Refactor with full-suite green and no contract drift.

Required test layers:
- Rate-limit behavior tests.
- Handler-level auth enforcement tests.
- Problem Details consistency tests for blocked requests.

## Stories
- As security, I can trust handler-level access controls.
- As operations, I can mitigate abuse through rate limiting.
- As release managers, I have a clear API hardening signoff checklist.

## Acceptance Criteria
- Rate limits are enforced for targeted endpoints.
- Authorization logic is validated inside handlers.
- Security headers and cache controls are correctly applied.
- Regression tests cover known bypass classes.
- OpenAPI and docs reflect final API behavior.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test
npm run lint
npm run build
npm run dev
# manual/API checks:
# rate-limit protected endpoint behavior
# auth-protected endpoint behavior
# /api/v1/docs contract consistency
```

Pass condition (required to close sprint):
- 100% of Sprint 12 tests pass.
- Security and operational hardening checks pass.
- Release checklist is fully green.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint verification passes.
- Release signoff document is completed.


---

# sprint-13-ui-foundation-design-system.md

# Sprint 13 — UI Foundation + Design System

## Goal
Establish the Next.js App Router UI foundation with a reusable HAL client, Problem Details renderer, and protected route scaffolding for admin surfaces.

## Scope
- Create App Router shell and shared layouts/navigation.
- Add UI component baseline (forms, tables, dialogs, toasts) using existing Tailwind/UI primitives.
- Build `lib/halClient` with:
  - root discovery (`/api/v1`)
  - link following by relation
  - standardized fetch wrapper for HAL and Problem Details.
- Implement global Problem Details error UI with `request_id` display/copy.
- Add admin route protection driven by `/api/v1/me` and role-aware affordances.

## TDD Process
1. Write failing unit tests for HAL client parsing and link-follow behavior.
2. Write failing component tests for Problem Details rendering and request_id visibility.
3. Write failing integration tests for admin-route gating.
4. Implement minimally, then refactor with tests green.

## Stories
- As a user, I get consistent UI shell and feedback patterns.
- As a developer, I can consume API links without hardcoding transport paths.
- As support, I can capture request correlation IDs from UI errors.

## Acceptance Criteria
- HAL client consumes `_links` and supports relation-driven actions.
- Problem Details renderer handles non-2xx with clear messaging and `request_id`.
- Admin routes are denied when `/api/v1/me` does not grant required affordances.
- No UI hardcoding of event action routes (publish/cancel/export/registrations).

## End-of-Sprint Verification
```bash
npm run test -- ui-foundation hal-client
npm run lint
npm run build
```
Manual checks:
- Open protected admin route when logged out (must gate).
- Trigger a problem response and verify `request_id` appears.

Pass condition:
- All Sprint 13 tests pass.
- HAL + error contract behavior is verified.

## Exit Gate
Move sprint only when all acceptance criteria and verification checks pass.


---

# sprint-14-public-events-ui.md

# Sprint 14 — Public Events UI

## Goal
Deliver public events browsing and detail pages that consume HAL resources and state-dependent affordances.

## Scope
- Implement `/events` list page with paging/filter controls from API metadata.
- Implement `/events/[slug]` detail page.
- Render available actions strictly from HAL links.
- Display event state and user-specific affordances.

## TDD Process
1. Write failing page/component tests for list/detail render paths.
2. Write failing integration tests for HAL-link-driven actions visibility.
3. Implement minimal data-fetch and render logic.
4. Refactor for shared UI patterns with tests green.

## Stories
- As a visitor, I can browse published events.
- As a user, I can see allowed actions on event detail from API affordances.

## Acceptance Criteria
- `/events` renders from API response, including empty/error states.
- `/events/[slug]` renders detail and action controls from `_links`.
- UI does not assume `publish/cancel` endpoints; it follows affordances.
- Problem Details are shown through the global renderer.

## End-of-Sprint Verification
```bash
npm run test -- public-events-ui
npm run lint
npm run build
```
Manual checks:
- Navigate list -> detail.
- Confirm action controls change with event state/affordances.

Pass condition:
- All Sprint 14 tests pass.
- HAL-driven navigation validated.

## Exit Gate
Move sprint only when acceptance criteria and verification pass.


---

# sprint-15-auth-pages-account.md

# Sprint 15 — Auth Pages + Account

## Goal
Implement UI auth entry points and account surfaces using session-based API flows and robust Problem Details handling.

## Scope
- Implement `/login` and `/register` using React Hook Form + Zod.
- Implement `/account` page for current user profile and basic registration summary.
- Handle auth/session transitions cleanly (logged in/out states).
- Surface rate-limit and auth errors with friendly messages and request IDs.

## TDD Process
1. Write failing form validation tests for login/register.
2. Write failing integration tests for success/error auth flows.
3. Write failing tests for `/account` authenticated gating.
4. Implement and refactor with green tests.

## Stories
- As a new user, I can register and sign in.
- As an existing user, I can log in and access my account.
- As a user, I receive clear errors for invalid credentials and throttling.

## Acceptance Criteria
- Login/register submit to API and handle Problem Details consistently.
- `/account` requires session and renders user data from `/api/v1/me`.
- Rate-limit (`429`) feedback is user-friendly.
- Request IDs are visible on surfaced errors.

## End-of-Sprint Verification
```bash
npm run test -- auth-ui account-ui
npm run lint
npm run build
```
Manual checks:
- Register -> login -> account.
- Verify invalid credentials and rate-limit UX.

Pass condition:
- All Sprint 15 tests pass.
- Auth/session UX contract validated.

## Exit Gate
Move sprint only when acceptance criteria and verification pass.


---

# sprint-16-registration-ux.md

# Sprint 16 — Registration UX

## Goal
Deliver event registration UX preserving domain transitions: REGISTERED, WAITLISTED, CANCELLED, and CHECKED_IN visibility.

## Scope
- Add registration action on event detail.
- Show current registration status badges and transitions.
- Implement cancel action as state transition (no hard delete semantics in UI).
- Provide clear user feedback for waitlist outcomes.

## TDD Process
1. Write failing tests for register/cancel interaction flows.
2. Write failing tests for WAITLISTED behavior when capacity is full.
3. Write failing tests for status rendering and action availability.
4. Implement/refactor with green tests.

## Stories
- As a user, I can register for an event and see if I am waitlisted.
- As a user, I can cancel and see cancelled state reflected.

## Acceptance Criteria
- Register action reflects REGISTERED or WAITLISTED response.
- Cancel action transitions status to CANCELLED in UI state.
- UI state aligns with API status transitions.
- Problem responses are rendered consistently.

## End-of-Sprint Verification
```bash
npm run test -- registration-ui
npm run lint
npm run build
```
Manual checks:
- Register on available event.
- Register on full event and verify WAITLISTED.
- Cancel and verify CANCELLED status.

Pass condition:
- All Sprint 16 tests pass.
- Transition semantics verified against API behavior.

## Exit Gate
Move sprint only when acceptance criteria and verification pass.


---

# sprint-17-admin-events-console.md

# Sprint 17 — Admin Events Console

## Goal
Implement admin event management UI for list/create/edit and state-driven publish/cancel actions.

## Scope
- Implement `/admin/events` list + create flow.
- Implement `/admin/events/[slug]` detail/edit flow.
- Render publish/cancel controls only when corresponding HAL links exist.
- Support create/update validation feedback and problem rendering.

## TDD Process
1. Write failing tests for admin list/create/edit UI.
2. Write failing tests for HAL-driven publish/cancel action visibility.
3. Write failing integration tests for lifecycle transitions in UI.
4. Implement/refactor with tests green.

## Stories
- As an admin, I can create and edit events.
- As an admin, I can publish/cancel only when affordances are present.

## Acceptance Criteria
- `/admin/events` supports listing and creation.
- `/admin/events/[slug]` supports editing.
- Publish/cancel buttons are conditioned by `_links`.
- Error states use Problem Details renderer with request_id.

## End-of-Sprint Verification
```bash
npm run test -- admin-events-ui
npm run lint
npm run build
```
Manual checks:
- Create event, publish it, then cancel it via available links.
- Confirm button visibility changes by state.

Pass condition:
- All Sprint 17 tests pass.
- State-driven affordance behavior is verified.

## Exit Gate
Move sprint only when acceptance criteria and verification pass.


---

# sprint-18-admin-registrations-checkin-export.md

# Sprint 18 — Admin Registrations + Check-in + Export

## Goal
Implement admin registration operations, check-in workflows, and export UI with governance constraints.

## Scope
- Implement `/admin/events/[slug]/registrations` for list/add/cancel/check-in.
- Implement `/admin/events/[slug]/export` UI for csv/json exports.
- Enforce include-email governance behavior in UI.
- Display transitions and operation outcomes clearly.

## TDD Process
1. Write failing tests for registrations list/add/cancel/check-in.
2. Write failing tests for export format options and responses.
3. Write failing tests for include-email governance behavior.
4. Implement/refactor with tests green.

## Stories
- As an admin, I can manage registrations and check-ins.
- As an admin, I can export data while respecting governance constraints.

## Acceptance Criteria
- Registrations view supports add/cancel/check-in and status updates.
- Export supports csv/json and handles blocked include-email cases.
- UI follows API links and renders Problem Details for blocked actions.
- Request IDs are visible for operational troubleshooting.

## End-of-Sprint Verification
```bash
npm run test -- admin-registrations-ui export-ui
npm run lint
npm run build
```
Manual checks:
- Add/cancel/check-in registration.
- Export csv/json and validate include-email restrictions outside local.

Pass condition:
- All Sprint 18 tests pass.
- Governance behavior validated.

## Exit Gate
Move sprint only when acceptance criteria and verification pass.


---

# sprint-19-admin-users-ui.md

# Sprint 19 — Admin Users UI

## Goal
Deliver admin users management UI aligned with API RBAC and non-escalation rules.

## Scope
- Implement `/admin/users` list/search/filter.
- Implement user detail/status enable-disable interactions.
- Implement role add/remove UI for allowed roles.
- Explicitly block/remove SUPER_ADMIN role mutation controls in UI.

## TDD Process
1. Write failing tests for users list/search/detail interactions.
2. Write failing tests for enable/disable flows.
3. Write failing tests for role add/remove idempotency and SUPER_ADMIN exclusion.
4. Implement/refactor with tests green.

## Stories
- As an admin, I can manage user status and roles safely.
- As a security reviewer, I can confirm UI has no SUPER_ADMIN escalation surface.

## Acceptance Criteria
- Users list/search/detail works from API responses.
- Enable/disable actions update UI state accurately.
- Role add/remove works for permitted roles.
- No UI control allows SUPER_ADMIN role changes.

## End-of-Sprint Verification
```bash
npm run test -- admin-users-ui
npm run lint
npm run build
```
Manual checks:
- Add/remove ADMIN role and verify idempotent behavior.
- Confirm SUPER_ADMIN controls do not appear.

Pass condition:
- All Sprint 19 tests pass.
- Non-escalation UI constraints are validated.

## Exit Gate
Move sprint only when acceptance criteria and verification pass.


---

# sprint-20-ui-hardening-e2e-release.md

# Sprint 20 — UI Hardening + E2E + Release Gate

## Goal
Finalize UI for production readiness with end-to-end coverage, accessibility pass, and escalation-surface checks.

## Scope
- Build Playwright E2E suite for critical public + admin flows.
- Add accessibility pass for keyboard navigation, labels, and focus behavior.
- Ensure consistent Problem Details UX with request_id propagation.
- Verify no CLI-only super-admin/dangerous operations are exposed in UI.

## TDD Process
1. Write failing E2E tests for end-to-end user/admin journeys.
2. Write failing accessibility and error rendering checks.
3. Implement minimal fixes to pass release criteria.
4. Refactor while preserving behavior and full green suite.

## Stories
- As a release owner, I can trust core UI flows through automated E2E coverage.
- As support, I can diagnose failures via request_id surfaced in UI.

## Acceptance Criteria
- E2E flows pass:
  - register/login/logout
  - browse events
  - register/waitlist/cancel
  - admin create→publish→registrations→check-in→export.
- Accessibility checks pass for critical routes.
- Problem Details and request_id are consistently displayed.
- No UI surface exposes CLI-only operations.

## End-of-Sprint Verification
```bash
npm run test -- e2e ui-hardening
npm run lint
npm run build
```
Manual checks:
- Spot-check critical public/admin flows in browser.
- Confirm no SUPER_ADMIN/CLI-only operation surfaces.

Pass condition:
- All Sprint 20 tests pass.
- Release checklist is fully green.

## Exit Gate
UI Phase 1 is complete only when all criteria above pass and regression suite is green.


---

# sprint-21-e2e-api-foundation-contracts.md

# Sprint 21 — E2E API Foundation + Contracts

## Goal
Implement deterministic E2E coverage for API discoverability, docs, content types, and Problem Details contract consistency.

## Scope
- Add Playwright/API E2E tests for `GET /api/v1` and `GET /api/v1/docs`.
- Add negative tests for missing endpoints returning RFC 9457 Problem Details with `request_id`.
- Assert representative success/error content types (`application/hal+json` and `application/problem+json`).
- Standardize E2E fixtures for users/events/registrations baseline.

## TDD Process
1. Write failing E2E tests for root/docs/content-type and problem-shape.
2. Add deterministic seed/fixture loader for E2E suite.
3. Implement minimal fixes until all tests pass.
4. Refactor tests for readability and stability.

## Stories
- As a UI client, I can rely on stable API contracts.
- As support, I always receive `request_id` for failed requests.

## Acceptance Criteria
- Root/docs discovery tests pass.
- Missing endpoint test validates full Problem Details contract + `request_id`.
- Content-type tests pass across representative endpoints.
- Shared E2E fixture setup is committed and reusable.

## End-of-Sprint Verification
```bash
npm run test -- e2e api-foundation
npm run lint
npm run build
```

Pass condition:
- All Sprint 21 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


---

# sprint-22-e2e-auth-session-hardening.md

# Sprint 22 — E2E Auth + Session Hardening

## Goal
Deliver complete positive/negative E2E coverage for register/login/logout/account/session expiry/CSRF/rate-limit behavior.

## Scope
- Add UI E2E tests for register → login → account and logout gating.
- Add negative tests for invalid credentials and friendly Problem Details rendering with `request_id`.
- Add E2E coverage for rate-limited login/register flows.
- Add E2E coverage for expired session and CSRF-safe mutation blocking behavior.

## TDD Process
1. Write failing tests for happy path auth journey.
2. Write failing tests for invalid credentials, 429, CSRF, and session expiry.
3. Implement minimal app/test harness updates for deterministic pass.
4. Refactor selectors, fixture helpers, and retries.

## Stories
- As a user, I can authenticate reliably.
- As a security reviewer, I can validate hardening behavior from the UI.

## Acceptance Criteria
- Register/login/logout/account E2E flow passes.
- Invalid auth + rate-limit + CSRF + expiry behaviors are covered and pass.
- Every surfaced auth error includes request correlation in UI.

## End-of-Sprint Verification
```bash
npm run test -- e2e auth session
npm run lint
npm run build
```

Pass condition:
- All Sprint 22 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


---

# sprint-23-e2e-public-events-hal.md

# Sprint 23 — E2E Public Events + HAL Compliance

## Goal
Validate public event browsing and strict HATEOAS behavior from UI consumers.

## Scope
- Add E2E coverage for `/events` list and `/events/[slug]` detail.
- Add negative tests for bad slug and forced API failure UX with Problem Details + `request_id`.
- Add HAL affordance tests for state-dependent publish/cancel visibility in admin event detail.
- Add strongest HATEOAS proof test: modified HAL href is the URL used by UI actions.
- Add stale UI/race behavior test (action fails gracefully and UI refreshes state).

## TDD Process
1. Write failing browse/detail + negative slug tests.
2. Write failing HAL affordance and dynamic-href action tests.
3. Implement/refine UI or helpers to honor HAL links only.
4. Refactor for deterministic race handling in tests.

## Stories
- As a user, I can browse event data safely.
- As an API architect, I can confirm UI is link-driven, not hardcoded.

## Acceptance Criteria
- Public list/detail E2E tests pass.
- Negative public error rendering tests pass with request correlation.
- HAL affordance + dynamic href usage tests pass.
- Stale-action race test passes with graceful recovery behavior.

## End-of-Sprint Verification
```bash
npm run test -- e2e events hal
npm run lint
npm run build
```

Pass condition:
- All Sprint 23 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


---

# sprint-24-e2e-admin-operations-security.md

# Sprint 24 — E2E Admin Operations + Security Boundaries

## Goal
Complete E2E coverage for admin events, registrations/check-in/export, users UI, and non-escalation boundaries.

## Scope
- Add E2E tests for admin event create/edit/publish/cancel + validation/slug conflicts.
- Add E2E tests for admin registrations list/add/cancel/check-in/export + blocked include_email + rate-limit.
- Add E2E tests for admin users list/search/filter, enable/disable, ADMIN role idempotency.
- Add negative tests ensuring no SUPER_ADMIN controls in UI and API escalation attempts are denied.
- Add explicit unauthorized access tests for all admin web surfaces.

## TDD Process
1. Write failing admin events console tests.
2. Write failing registration/check-in/export governance tests.
3. Write failing admin users + non-escalation tests.
4. Implement minimal fixes and refactor shared admin E2E helpers.

## Stories
- As an admin, I can operate event lifecycle safely.
- As security, I can verify escalation controls are enforced.

## Acceptance Criteria
- Admin events/registrations/export/users E2E suites pass.
- Governance and 429 scenarios are covered and pass.
- SUPER_ADMIN and CLI-only boundaries are validated in tests.

## End-of-Sprint Verification
```bash
npm run test -- e2e admin operations security
npm run lint
npm run build
```

Pass condition:
- All Sprint 24 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


---

# sprint-25-e2e-release-journeys-regression.md

# Sprint 25 — E2E Release Journeys + Regression Gate

## Goal
Ship the consolidated release-gate E2E suite with public/admin journeys and supportability regressions.

## Scope
- Build one canonical public journey: browse → detail → register/waitlist/cancel.
- Build one canonical admin journey: create → publish → registration → check-in → export.
- Add supportability assertion that forced failures always display `request_id` in UI.
- Add regression test for role downgrade mid-session (admin loses access on refresh).
- Add CI-ready test grouping/tags and docs for release execution.

## TDD Process
1. Write failing end-to-end journey tests.
2. Add failing supportability + role-downgrade regression tests.
3. Implement minimal fixes for determinism and gating.
4. Refactor and stabilize release test command.

## Stories
- As a release owner, I can trust critical journeys before shipping.
- As support, I can triage using request correlation in failure UX.

## Acceptance Criteria
- Public and admin release journeys pass reliably.
- request_id supportability check passes.
- Role downgrade mid-session regression test passes.
- Release-gate command and docs are updated.

## End-of-Sprint Verification
```bash
npm run test -- e2e release regression
npm run lint
npm run build
```

Pass condition:
- All Sprint 25 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


---

# sprint-26-feature-password-reset-recovery.md

# Sprint 26 — Feature: Password Reset + Recovery E2E

## Goal
Implement password reset/account recovery feature and its complete positive/negative E2E suite.

## Scope
- Add reset request flow (UI + API) and reset confirmation flow.
- Add secure reset token generation, expiry, one-time use, and invalidation.
- Add deterministic test token capture strategy for E2E (test inbox/mock channel).
- Add E2E tests for valid reset, expired token, reused token, unknown email, and rate limits.

## TDD Process
1. Write failing E2E tests for reset request/confirm happy path.
2. Write failing negative token/rate-limit scenarios.
3. Implement minimal backend/UI flow and token lifecycle.
4. Refactor for security and deterministic tests.

## Stories
- As a user, I can recover access when I forget my password.
- As security, I can trust token and abuse controls.

## Acceptance Criteria
- Password reset happy path passes E2E.
- Negative token misuse and abuse-limit tests pass.
- No sensitive token leakage occurs in UI/logs.

## End-of-Sprint Verification
```bash
npm run test -- e2e password-reset
npm run lint
npm run build
```

Pass condition:
- All Sprint 26 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


---

# sprint-27-feature-email-verification.md

# Sprint 27 — Feature: Email Verification + E2E

## Goal
Implement optional/common email verification lifecycle with robust E2E coverage.

## Scope
- Add verification token issue + confirm flow after registration.
- Add account state behavior for unverified/verified users.
- Add resend verification endpoint with rate limiting.
- Add E2E tests for verify success, expired link, resend, and unverified access restrictions.

## TDD Process
1. Write failing tests for verify-required registration behavior.
2. Write failing tests for verification link lifecycle and resend limits.
3. Implement feature minimally in auth/session and UI messaging.
4. Refactor and ensure compatibility with existing auth tests.

## Stories
- As a product owner, I can trust account email ownership before full access.
- As a user, I can recover from expired verification links.

## Acceptance Criteria
- Verification happy/negative paths pass E2E.
- Unverified behavior is explicit and deterministic.
- Resend flow is rate-limited and user-friendly.

## End-of-Sprint Verification
```bash
npm run test -- e2e email-verification
npm run lint
npm run build
```

Pass condition:
- All Sprint 27 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


---

# sprint-28-feature-admin-invitations.md

# Sprint 28 — Feature: Admin Invitations + E2E

## Goal
Add secure admin invitation workflows that grant ADMIN (never SUPER_ADMIN) with full E2E validation.

## Scope
- Add invitation create/send/accept flow for admin role onboarding.
- Enforce invite expiry, one-time use, and existing-account behavior.
- Ensure invite flow cannot assign SUPER_ADMIN.
- Add positive and negative E2E tests for invitation lifecycle and unauthorized attempts.

## TDD Process
1. Write failing tests for admin invite happy path.
2. Write failing tests for reuse/expiry/existing-account/unauthorized invite attempts.
3. Implement invitation model + endpoints + minimal UI surfaces.
4. Refactor security validations and test fixtures.

## Stories
- As an admin, I can onboard another admin safely.
- As security, I can validate non-escalation at all times.

## Acceptance Criteria
- Invite lifecycle tests pass end-to-end.
- SUPER_ADMIN is never assignable in invite flow.
- Unauthorized invite creation is blocked and tested.

## End-of-Sprint Verification
```bash
npm run test -- e2e admin-invitations
npm run lint
npm run build
```

Pass condition:
- All Sprint 28 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


---

# sprint-29-feature-account-registrations-history.md

# Sprint 29 — Feature: Account Registrations History + E2E

## Goal
Upgrade `/account` into a complete “My registrations” experience with privacy-safe E2E coverage.

## Scope
- Add account registrations list/history across events with current status.
- Ensure status updates reflect cancel/check-in lifecycle changes.
- Add clear empty/loading/error states using Problem Details patterns.
- Add privacy tests proving users cannot access other users’ registration data.

## TDD Process
1. Write failing tests for account history rendering and state updates.
2. Write failing privacy/authorization negative tests.
3. Implement account history UI + API integration.
4. Refactor selectors/helpers and stabilize data setup.

## Stories
- As a user, I can view my complete registration history.
- As a privacy reviewer, I can verify strict per-user data isolation.

## Acceptance Criteria
- Account history E2E tests pass for normal and empty datasets.
- Lifecycle state updates are visible without data leakage.
- Privacy negative tests pass.

## End-of-Sprint Verification
```bash
npm run test -- e2e account-registrations
npm run lint
npm run build
```

Pass condition:
- All Sprint 29 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


---

# sprint-30-feature-event-discovery-search-calendar.md

# Sprint 30 — Feature: Event Discovery (Search/Filters/Calendar) + E2E

## Goal
Add richer event discovery quality features and verify them end-to-end.

## Scope
- Add public search/filter controls (title/location/tags as implemented scope).
- Persist filter state in URL and maintain stable pagination behavior.
- Add calendar export (ICS) download path if included in scope.
- Add E2E tests for search/filter/paging and timezone-correct calendar export.

## TDD Process
1. Write failing tests for search/filter/URL state + pagination stability.
2. Write failing tests for calendar export correctness (if implemented).
3. Implement minimal discovery enhancements in API + UI.
4. Refactor for performance and deterministic assertions.

## Stories
- As a visitor, I can find relevant events quickly.
- As a user, I can export events to calendar tools reliably.

## Acceptance Criteria
- Search/filter/pagination E2E tests pass.
- URL persistence behavior is covered and passing.
- ICS export tests pass when feature is enabled.

## End-of-Sprint Verification
```bash
npm run test -- e2e event-discovery
npm run lint
npm run build
```

Pass condition:
- All Sprint 30 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


---

# sprint-31-feature-audit-log-ui.md

# Sprint 31 — Feature: Audit Log UI + E2E

## Goal
Provide an admin audit viewer with enterprise-grade access and filtering, validated by E2E tests.

## Scope
- Add admin audit list view with action/actor/time filters.
- Surface key mutation events (publish/cancel/export/roles) with safe metadata.
- Enforce admin-only access to audit UI.
- Add E2E tests for positive admin visibility and non-admin denial.
- Add negative tests for sensitive field redaction expectations.

## TDD Process
1. Write failing audit viewer access and filter tests.
2. Write failing non-admin denial and redaction tests.
3. Implement minimal audit UI endpoints/pages and filter wiring.
4. Refactor for consistency with existing admin UX.

## Stories
- As an admin, I can inspect operational history confidently.
- As compliance, I can verify least-privilege visibility and redaction.

## Acceptance Criteria
- Audit list/filter tests pass for admin users.
- Non-admin denial tests pass.
- Redaction assertions pass for sensitive metadata.

## End-of-Sprint Verification
```bash
npm run test -- e2e audit-ui
npm run lint
npm run build
```

Pass condition:
- All Sprint 31 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


---

# sprint-32-feature-compliance-retention.md

# Sprint 32 — Feature: Compliance Basics (Terms/Privacy/Retention) + E2E

## Goal
Implement core compliance UX/API surfaces and validate them with E2E release checks.

## Scope
- Add Terms/Privacy routes and link integration in auth/account flows.
- Add registration acknowledgment checkbox flow if required.
- Implement baseline retention-aware account/data handling required by product scope.
- Add E2E tests for policy access, required acknowledgments, and retention/deletion constraints.
- Include final escalation-surface verification (no CLI-only dangerous operations exposed).

## TDD Process
1. Write failing tests for policy page availability and required acknowledgments.
2. Write failing retention/deletion and escalation-surface tests.
3. Implement minimal compliance features and UI affordances.
4. Refactor and run full release regression.

## Stories
- As a user, I can review product policies and consent where required.
- As release/compliance owner, I can validate baseline policy and retention behaviors.

## Acceptance Criteria
- Terms/Privacy and acknowledgment tests pass.
- Retention/deletion behaviors meet defined policy tests.
- Escalation-surface checks pass in final E2E gate.

## End-of-Sprint Verification
```bash
npm run test -- e2e compliance release
npm run lint
npm run build
```

Pass condition:
- All Sprint 32 tests and verification commands pass.
- UI+API E2E backlog from Letter 4 is fully planned and implementable.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.



===== FILE: project_management/sprints/completed/sprint-01-foundation.md =====
# Sprint 01 — Foundation & Test Harness

## Goal
Establish a production-grade CLI foundation (`appctl`) with a strict TDD workflow, stable command UX, config loading precedence, validation, logging, and deterministic test infrastructure.

## Scope
- Initialize CLI runtime with TypeScript + Node 20.
- Add command framework (`Commander`) and global flags contract.
- Implement config loading precedence:
  1. CLI flags
  2. environment variables
  3. config file
  4. defaults
- Implement baseline output contract:
  - human-readable default
  - `--json` strict response shape
- Implement exit code mapping contract.
- Add command help and usage snapshots.
- Add shared test utilities for CLI execution and fixtures.

## TDD Process
For every feature in this sprint:
1. Write failing tests/spec first.
2. Implement minimum code to pass.
3. Refactor while preserving green tests.
4. Commit only when all tests pass locally.

Required test layers:
- Unit tests: parsing, config merge, output formatting, exit-code mapper.
- Contract tests: global flags and JSON envelope schema.
- Snapshot tests: command help output.

## Stories
- As an operator, I can run `appctl --help` and see stable command docs.
- As an operator, I can pass `--env` and `--json` globally.
- As a developer, I can rely on deterministic config precedence.
- As CI, I can fail fast on contract regressions.

## Acceptance Criteria
- `appctl --help` returns exit code `0` and matches approved snapshot.
- Global flags parse correctly and are available to command handlers.
- `--json` output always returns:
  - `ok`, `command`, `env`, `data`, `warnings[]`, `errors[]`, `request_id`.
- Usage/validation errors exit with code `2`.
- Unexpected errors exit with code `1`.
- Config precedence behaves exactly as specified.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test
npm run lint
npm run build
npm run cli -- --help
npm run cli -- --json --env local doctor
```

Pass condition (required to close sprint):
- 100% of Sprint 01 tests pass.
- All verification commands exit `0`.
- No snapshot diffs unless intentionally updated and approved.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint CLI verification passes.
- Open defects for sprint scope = 0.


===== FILE: project_management/sprints/completed/sprint-02-db-core.md =====
# Sprint 02 — Database Core (Status, Migrate, Seed, Doctor)

## Goal
Deliver reliable DB lifecycle primitives with idempotent behavior and strict health checks for SQLite production profile.

## Scope
- Implement `db status`, `db migrate`, `db seed`, `doctor`.
- Integrate Drizzle ORM + drizzle-kit migrations.
- Enforce/verify SQLite requirements (WAL, FK, busy timeout, path validity).
- Ensure seed is idempotent (roles and bootstrap data).
- Add fail-closed audit behavior for state-changing commands.

## TDD Process
For each command/edge case:
1. Write failing tests for success path and invariant violations.
2. Implement minimal behavior.
3. Add idempotency and rollback tests.
4. Refactor service interfaces with tests green.

Required test layers:
- Unit tests: pragma checks, migration status resolver.
- Integration tests: migrate/seed idempotency, doctor validation.
- Failure-path tests: audit failure causes command failure.

## Stories
- As an operator, I can confirm schema status before writes.
- As an operator, I can run migrations safely multiple times.
- As an operator, I can seed without duplicate corruption.
- As an operator, I can detect bad SQLite runtime settings.

## Acceptance Criteria
- `db migrate` is idempotent and audited.
- `db seed` is idempotent and audited.
- `doctor` fails when WAL/FK are not enabled.
- `doctor` fails on schema mismatch.
- Any audit write failure aborts mutation (fail-closed).
- Precondition failures return exit code `6`.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- db
npm run cli -- db status --env local
npm run cli -- db migrate --env local
npm run cli -- db migrate --env local
npm run cli -- db seed --env local
npm run cli -- db seed --env local
npm run cli -- doctor --env local --json
```

Pass condition (required to close sprint):
- 100% of Sprint 02 DB tests pass.
- Re-running migrate/seed yields no duplicates or corruption.
- All verification commands exit `0` for healthy setup.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint CLI verification passes.
- Idempotency evidence is attached in sprint notes.


===== FILE: project_management/sprints/completed/sprint-03-auth-users.md =====
# Sprint 03 — Auth Tokens & User Management

## Goal
Implement super-admin token operations and user/role commands with permission rails aligned to environment policy.

## Scope
- Implement token commands:
  - `auth token create`
  - `auth token revoke`
- Implement user commands:
  - `user create`, `user list`, `user show`
  - `user disable`, `user enable`
  - `user role add`, `user role remove`
- Enforce role and token checks for write operations in staging/prod.
- Ensure token hashing at rest and one-time token display.
- Audit all state mutations.

## TDD Process
- Write failing tests for each command and permission branch first.
- Add tests for token hashing and revocation behavior.
- Add tests for role assignment uniqueness and conflict handling.
- Refactor services only with green test suite.

Required test layers:
- Unit tests: permission guard, role resolver, token verifier.
- Integration tests: command-to-service wiring, audit writes.
- Security tests: no plaintext token persistence.

## Stories
- As a super-admin, I can issue and revoke service tokens.
- As an admin, I can create and manage user status.
- As a super-admin, I can assign/revoke roles safely.
- As operator, I can trust mutation auditability.

## Acceptance Criteria
- Token is shown once on create; only hash stored.
- Revoked token cannot authorize writes.
- User create enforces unique email.
- Role add/remove are idempotent and audited.
- Staging/prod write commands fail with exit code `3` when unauthorized.
- Not-found and conflict paths return specified exit codes.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- auth user
npm run cli -- auth token create --name sprint3 --env local --json
npm run cli -- user create --email admin@example.com --status ACTIVE --env local
npm run cli -- user role add --id <USER_ID> --role ADMIN --env local
npm run cli -- user disable --id <USER_ID> --reason "verification" --env local
npm run cli -- auth token revoke --id <TOKEN_ID> --env local
```

Pass condition (required to close sprint):
- 100% of Sprint 03 tests pass.
- Authorization and revocation checks behave as expected.
- All verification commands exit `0` for expected paths.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint CLI verification passes.
- Security review checklist items are complete.


===== FILE: project_management/sprints/completed/sprint-04-events.md =====
# Sprint 04 — Event Lifecycle

## Goal
Deliver robust event lifecycle commands with validation, idempotent publish behavior, and full mutation auditing.

## Scope
- Implement commands:
  - `event create`
  - `event update`
  - `event publish`
  - `event cancel`
  - `event list`
- Enforce slug uniqueness and time validation.
- Ensure publish is idempotent and audited.
- Ensure cancellation reason requirements and audit metadata.

## TDD Process
- Start each command with failing contract tests.
- Add edge-case tests for date/timezone and conflict behavior.
- Add idempotency tests for repeated publish/cancel attempts.
- Refactor service layer with unchanged command contract.

Required test layers:
- Unit tests: input validation and state transitions.
- Integration tests: create→update→publish→cancel flow.
- Audit tests: every mutation creates audit log.

## Stories
- As an admin, I can create events in `DRAFT` state.
- As an admin, I can publish an event safely once.
- As an admin, I can cancel with an explicit reason.
- As an operator, I can list by status/date filters.

## Acceptance Criteria
- Event create enforces required fields and valid ISO times.
- Update modifies only provided fields.
- Publish is idempotent and audited.
- Cancel sets `CANCELLED` and stores audit reason metadata.
- List supports status/from/to filters.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- event
npm run cli -- event create --slug spring-launch --title "Spring Launch" --start 2026-04-01T14:00:00Z --end 2026-04-01T15:00:00Z --tz UTC --env local
npm run cli -- event publish --slug spring-launch --env local
npm run cli -- event publish --slug spring-launch --env local
npm run cli -- event cancel --slug spring-launch --reason "verification" --env local
npm run cli -- event list --status CANCELLED --env local --json
```

Pass condition (required to close sprint):
- 100% of Sprint 04 tests pass.
- Repeated publish does not duplicate or corrupt state.
- All verification commands exit `0` for expected paths.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint CLI verification passes.
- Event domain invariants are documented.


===== FILE: project_management/sprints/completed/sprint-05-registrations-export.md =====
# Sprint 05 — Registrations, Check-in, Export

## Goal
Implement registration workflows with capacity/waitlist behavior, check-in flow, and governed export outputs with PII controls.

## Scope
- Implement commands:
  - `reg add`, `reg remove`, `reg list`
  - `checkin`
  - `event export`
- Enforce capacity rule: full event => `WAITLISTED`.
- Enforce no hard delete on remove (`CANCELLED` state transition).
- Implement export to CSV/JSON with security redaction rules.
- Require token for `--include-email` outside local.

## TDD Process
- Begin with failing tests for capacity and state transitions.
- Add regression tests for duplicate registration attempts.
- Add authorization/redaction tests for PII export paths.
- Refactor internals with no contract breakage.

Required test layers:
- Unit tests: status transitions and export formatter.
- Integration tests: event capacity scenarios and check-in behavior.
- Security tests: PII redaction without proper token context.

## Stories
- As an admin, I can register users and respect capacity limits.
- As an admin, I can cancel registrations without deleting history.
- As staff, I can check users in at event time.
- As operator, I can export registration data safely.

## Acceptance Criteria
- Full events place new registrations in `WAITLISTED`.
- `reg remove` transitions status to `CANCELLED`.
- `checkin` transitions to `CHECKED_IN` from allowed states.
- Export supports CSV/JSON and writes file correctly.
- PII behavior follows token + environment rules.
- All mutations are audited.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- registration export
npm run cli -- reg add --event spring-launch --user admin@example.com --env local
npm run cli -- reg list --event spring-launch --env local --json
npm run cli -- checkin --event spring-launch --user admin@example.com --env local
npm run cli -- event export --slug spring-launch --format csv --out ./tmp/spring-launch.csv --env local
npm run cli -- event export --slug spring-launch --format json --out ./tmp/spring-launch.json --env local
```

Pass condition (required to close sprint):
- 100% of Sprint 05 tests pass.
- Capacity/waitlist and check-in rules behave correctly.
- All verification commands exit `0` and output files are generated.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint CLI verification passes.
- Export governance checks are documented and approved.


===== FILE: project_management/sprints/completed/sprint-06-hardening-release.md =====
# Sprint 06 — Backup/Restore Hardening, CI, Release Readiness

## Goal
Finalize operational safety for dangerous commands, validate backup/restore reliability, and enforce release gates in CI.

## Scope
- Implement and harden:
  - `db backup`
  - `db restore`
  - optional `db reset` safety rails
- Enforce dangerous-op rules in prod:
  - token required
  - `--force-prod`
  - `--yes`
- Add backup/restore round-trip checks in CI.
- Ensure migration forward-only discipline guardrails.
- Finalize docs/runbooks for operational usage.

## TDD Process
- Write failing tests for each dangerous command guard.
- Add tests for local/staging/prod behavior differences.
- Add round-trip restore verification tests.
- Refactor only with green full-suite and CLI smoke tests.

Required test layers:
- Unit tests: guard rails, confirmation flags, env gating.
- Integration tests: backup artifact + restore round-trip.
- CI workflow tests: sprint-close gate script.

## Stories
- As a super-admin, I can create reliable backups.
- As a super-admin, I can restore safely with explicit intent.
- As operator, I can trust CI to block unsafe regressions.
- As team, I can release only with verified CLI correctness.

## Acceptance Criteria
- Backup uses safe method and produces valid artifact.
- Restore default is local/staging only; prod requires explicit overrides.
- Dangerous commands in prod fail without all required flags/token.
- Round-trip backup/restore passes in CI local profile.
- Full CLI contract tests pass (help, JSON shape, exit codes).

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test
npm run lint
npm run build
npm run cli -- db backup --out ./tmp/backup.db --env local
npm run cli -- db restore --from ./tmp/backup.db --env local --yes
npm run cli -- doctor --env local --json
```

Pass condition (required to close sprint):
- 100% of Sprint 06 tests pass.
- Full project CI-equivalent command set exits `0`.
- Backup/restore round-trip verified and documented.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint CLI verification passes.
- Release checklist is fully green.


===== FILE: project_management/sprints/completed/sprint-07-api-foundation.md =====
# Sprint 07 — API Foundation (HAL + Problem Details + OpenAPI Skeleton)

## Goal
Establish the HTTP transport foundation for `/api/v1` with HAL success responses, RFC 9457 Problem Details errors, request correlation, and initial OpenAPI 3.1 contract publication.

## Scope
- Create base route scaffolding for Next.js Route Handlers under `/api/v1`.
- Add shared response builders:
  - HAL (`application/hal+json`)
  - Problem Details (`application/problem+json`)
- Implement request correlation (`request_id`) in headers and error bodies.
- Implement API root discoverability endpoint: `GET /api/v1`.
- Add OpenAPI 3.1 skeleton endpoint: `GET /api/v1/docs`.
- Add transport-layer guardrails: no business logic in handlers.

## TDD Process
For every endpoint and shared builder:
1. Write failing contract tests first.
2. Implement minimal transport behavior.
3. Refactor with strict backward-compatibility on response contracts.
4. Keep green tests before merging.

Required test layers:
- Contract tests for HAL response shape and required `_links`.
- Contract tests for Problem Details fields (`type/title/status/detail/instance` + `request_id`).
- Tests for content-type correctness per endpoint.

## Stories
- As a UI client, I can discover API entry links from `/api/v1`.
- As an integrator, I receive standardized error payloads.
- As ops, I can correlate errors using `request_id`.
- As developers, we have a single response formatting foundation.

## Acceptance Criteria
- `/api/v1` returns `application/hal+json` with `_links.self` and top-level navigation links.
- Errors return `application/problem+json` and RFC 9457 canonical fields.
- Every error body includes `request_id` extension member.
- OpenAPI skeleton is accessible at `/api/v1/docs`.
- Route handlers call shared builders and avoid direct business-rule duplication.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- api foundation
npm run lint
npm run build
npm run dev
# then manually verify:
# GET /api/v1
# GET /api/v1/docs
```

Pass condition (required to close sprint):
- 100% of Sprint 07 tests pass.
- HAL and Problem Details contracts are stable and validated.
- `/api/v1` and `/api/v1/docs` return expected payload shapes.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint verification passes.
- API contract snapshot changes are reviewed/approved.


===== FILE: project_management/sprints/completed/sprint-08-auth-session.md =====
# Sprint 08 — Auth & Session (UI-Ready)

## Goal
Implement secure browser-ready authentication and identity endpoints (`register/login/logout/me`) with session cookies, CSRF-safe mutation patterns, and role-aware HAL affordances.

## Scope
- Integrate Auth.js credentials flow for session-based auth.
- Implement password hashing (argon2id preferred, fallback bcrypt only if justified).
- Build endpoints:
  - `POST /api/v1/auth/register`
  - `POST /api/v1/auth/login`
  - `POST /api/v1/auth/logout`
  - `GET /api/v1/me`
- Configure secure cookie policy:
  - `HttpOnly`
  - `Secure` in prod
  - `SameSite=Lax` (or stricter where validated)
- Ensure CSRF-safe mutation behavior.
- Ensure no super-admin escalation paths via API.

## TDD Process
For each endpoint and auth guard:
1. Write failing auth/session contract tests.
2. Implement minimal pass behavior.
3. Add CSRF and cookie-flag regression tests.
4. Refactor with green tests and unchanged contracts.

Required test layers:
- Contract tests for auth endpoint responses and status codes.
- Security tests for cookie flags and session lifecycle.
- RBAC tests for `/me` affordance links.

## Stories
- As a user, I can register and login through browser-safe sessions.
- As a user, I can logout and invalidate my session.
- As a client app, I can query `/me` and discover allowed actions.
- As security reviewers, we can verify cookie and CSRF protections.

## Acceptance Criteria
- Register creates `USER` role account with expected status.
- Login sets correct secure session cookie semantics.
- Logout clears session.
- `/me` returns role-aware HAL links.
- Mutating auth routes are CSRF-safe.
- No endpoint grants SUPER_ADMIN or token issuance via HTTP API.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- auth session me
npm run lint
npm run build
npm run dev
# manual/API checks:
# POST /api/v1/auth/register
# POST /api/v1/auth/login
# GET /api/v1/me
# POST /api/v1/auth/logout
```

Pass condition (required to close sprint):
- 100% of Sprint 08 tests pass.
- Session lifecycle and cookie security checks pass.
- `/me` links correctly reflect role permissions.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint verification passes.
- Security checklist for auth/session is fully green.


===== FILE: project_management/sprints/completed/sprint-09-users-api.md =====
# Sprint 09 — Users API (Admin)

## Goal
Deliver admin user-management HTTP endpoints aligned with CLI invariants and non-escalation rules, including RBAC enforcement and audited mutations.

## Scope
- Implement endpoints:
  - `GET /api/v1/users`
  - `GET /api/v1/users/{id}`
  - `PATCH /api/v1/users/{id}`
  - `POST /api/v1/users/{id}/roles`
  - `DELETE /api/v1/users/{id}/roles/{role}`
- Reuse existing domain/service logic from CLI-backed services.
- Enforce non-escalation rule:
  - No SUPER_ADMIN role grant/revoke via HTTP API.
- Add HAL links for admin affordances.
- Ensure all mutations are audited and fail-closed on audit failure.

## TDD Process
1. Write failing endpoint contract tests.
2. Implement minimal handler + service integration.
3. Add RBAC matrix tests (USER/ADMIN/STAFF where applicable).
4. Refactor with contract snapshots stable.

Required test layers:
- Response contract tests (HAL + Problem Details).
- RBAC matrix tests for each endpoint.
- Idempotency tests for role add/remove.

## Stories
- As an admin, I can list/filter users.
- As an admin, I can inspect and update user status.
- As an admin, I can add/remove non-super roles idempotently.
- As security, I can verify API cannot escalate SUPER_ADMIN.

## Acceptance Criteria
- Unique email and user integrity rules remain enforced.
- Role add/remove remain idempotent.
- SUPER_ADMIN role changes via API are denied.
- Not-found/conflict errors use Problem Details consistently.
- Mutation endpoints produce audit records.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- users api rbac
npm run lint
npm run build
npm run dev
# manual/API checks:
# GET /api/v1/users
# GET /api/v1/users/{id}
# PATCH /api/v1/users/{id}
# POST /api/v1/users/{id}/roles
# DELETE /api/v1/users/{id}/roles/{role}
```

Pass condition (required to close sprint):
- 100% of Sprint 09 tests pass.
- RBAC matrix and non-escalation behavior are validated.
- All user mutation paths are audited.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint verification passes.
- Non-escalation controls are explicitly documented.


===== FILE: project_management/sprints/completed/sprint-10-events-api.md =====
# Sprint 10 — Events API (Admin + Public Read)

## Goal
Expose event lifecycle over HTTP while preserving Sprint 04 domain invariants and state-driven HATEOAS affordances.

## Scope
- Implement endpoints:
  - `GET /api/v1/events` (filter + paging)
  - `POST /api/v1/events`
  - `GET /api/v1/events/{slug}`
  - `PATCH /api/v1/events/{slug}`
  - `POST /api/v1/events/{slug}/publish`
  - `POST /api/v1/events/{slug}/cancel`
- Preserve event lifecycle invariants from CLI domain services.
- Implement state-dependent HAL action links:
  - DRAFT => `app:publish`
  - PUBLISHED => `app:cancel`
  - CANCELLED => read-only links
- Ensure mutation paths are audited.

## TDD Process
1. Write failing contract tests for each endpoint + state link matrix.
2. Implement minimal handlers calling shared services.
3. Add idempotency tests for publish.
4. Refactor while keeping HAL/Problem contracts stable.

Required test layers:
- HAL link relation tests by event status.
- Validation tests for event updates and cancel reason.
- RBAC tests for write endpoints.

## Stories
- As an admin, I can create/update/publish/cancel events via API.
- As a client, I can discover allowed actions through `_links`.
- As operators, we retain audit trail for event mutations.

## Acceptance Criteria
- Event lifecycle semantics match Sprint 04 behavior.
- Publish remains idempotent.
- Cancel requires reason and stores audit metadata.
- List endpoint supports filters and paging metadata.
- HAL links correctly reflect event state.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- events api hateoas
npm run lint
npm run build
npm run dev
# manual/API checks:
# GET /api/v1/events?status=DRAFT
# POST /api/v1/events
# POST /api/v1/events/{slug}/publish
# POST /api/v1/events/{slug}/cancel
# GET /api/v1/events/{slug}
```

Pass condition (required to close sprint):
- 100% of Sprint 10 tests pass.
- HAL link matrix by state is correct.
- Event mutation audit coverage is complete.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint verification passes.
- Event API contract snapshots are approved.


===== FILE: project_management/sprints/completed/sprint-11-registrations-api.md =====
# Sprint 11 — Registrations, Check-in, Export API

## Goal
Expose registration/check-in/export API endpoints that preserve Sprint 05 business rules, redaction governance, and audit guarantees.

## Scope
- Implement endpoints:
  - `GET /api/v1/events/{slug}/registrations`
  - `POST /api/v1/events/{slug}/registrations`
  - `DELETE /api/v1/events/{slug}/registrations/{userId}`
  - `POST /api/v1/events/{slug}/checkins`
  - `GET /api/v1/events/{slug}/export?format=csv|json&include_email=...`
- Preserve capacity/waitlist behavior.
- Preserve cancellation semantics (state transition, no hard delete).
- Preserve check-in transition rules.
- Enforce export PII governance and role/token restrictions.
- Ensure all mutation and export actions are audited.

## TDD Process
1. Write failing contract and rules tests first.
2. Implement minimal handler + service integration.
3. Add security tests for `include_email` governance.
4. Refactor while preserving HAL/Problem contracts.

Required test layers:
- Capacity/waitlist transition tests.
- Export format and redaction tests.
- Authorization and audit tests for export/check-in/mutation paths.

## Stories
- As admin/staff, I can manage registrations and check-ins safely.
- As operator, I can export event data with governance controls.
- As security, I can verify PII is not exposed without proper authorization.

## Acceptance Criteria
- Full events push new registrations to WAITLISTED.
- Delete endpoint transitions registrations to CANCELLED.
- Check-in transitions to CHECKED_IN only from allowed states.
- Export supports CSV and JSON streaming/output.
- `include_email` behavior follows environment + token rules.
- All mutation/export actions are audited.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test -- registrations api export
npm run lint
npm run build
npm run dev
# manual/API checks:
# POST /api/v1/events/{slug}/registrations
# GET /api/v1/events/{slug}/registrations
# POST /api/v1/events/{slug}/checkins
# GET /api/v1/events/{slug}/export?format=csv
# GET /api/v1/events/{slug}/export?format=json&include_email=true
```

Pass condition (required to close sprint):
- 100% of Sprint 11 tests pass.
- Transition rules and export governance are validated.
- Audit coverage is complete for registration/check-in/export actions.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint verification passes.
- Data export governance checks are explicitly documented.


===== FILE: project_management/sprints/completed/sprint-12-api-hardening-release.md =====
# Sprint 12 — API Hardening, Security Regression, Release Readiness

## Goal
Harden API operations for production with abuse controls, defense-in-depth authorization enforcement, and release-ready operational runbooks.

## Scope
- Implement initial rate limiting for:
  - login
  - register
  - export endpoints
- Enforce security headers and no-store cache rules for auth/user endpoints.
- Ensure authorization checks are enforced in handlers (not middleware-only reliance).
- Add API-focused production runbooks and release checklist.
- Expand regression suite for auth bypass and edge-case security paths.

## TDD Process
1. Write failing security/abuse tests first.
2. Implement minimal controls to satisfy contracts.
3. Add regression tests for bypass patterns.
4. Refactor with full-suite green and no contract drift.

Required test layers:
- Rate-limit behavior tests.
- Handler-level auth enforcement tests.
- Problem Details consistency tests for blocked requests.

## Stories
- As security, I can trust handler-level access controls.
- As operations, I can mitigate abuse through rate limiting.
- As release managers, I have a clear API hardening signoff checklist.

## Acceptance Criteria
- Rate limits are enforced for targeted endpoints.
- Authorization logic is validated inside handlers.
- Security headers and cache controls are correctly applied.
- Regression tests cover known bypass classes.
- OpenAPI and docs reflect final API behavior.

## End-of-Sprint CLI Verification
Run these commands at sprint end:

```bash
npm run test
npm run lint
npm run build
npm run dev
# manual/API checks:
# rate-limit protected endpoint behavior
# auth-protected endpoint behavior
# /api/v1/docs contract consistency
```

Pass condition (required to close sprint):
- 100% of Sprint 12 tests pass.
- Security and operational hardening checks pass.
- Release checklist is fully green.

## Exit Gate
Sprint can move from `active` to `completed` only if:
- Acceptance criteria are fully met.
- End-of-sprint verification passes.
- Release signoff document is completed.


===== FILE: project_management/sprints/completed/sprint-13-ui-foundation-design-system.md =====
# Sprint 13 — UI Foundation + Design System

## Goal
Establish the Next.js App Router UI foundation with a reusable HAL client, Problem Details renderer, and protected route scaffolding for admin surfaces.

## Scope
- Create App Router shell and shared layouts/navigation.
- Add UI component baseline (forms, tables, dialogs, toasts) using existing Tailwind/UI primitives.
- Build `lib/halClient` with:
  - root discovery (`/api/v1`)
  - link following by relation
  - standardized fetch wrapper for HAL and Problem Details.
- Implement global Problem Details error UI with `request_id` display/copy.
- Add admin route protection driven by `/api/v1/me` and role-aware affordances.

## TDD Process
1. Write failing unit tests for HAL client parsing and link-follow behavior.
2. Write failing component tests for Problem Details rendering and request_id visibility.
3. Write failing integration tests for admin-route gating.
4. Implement minimally, then refactor with tests green.

## Stories
- As a user, I get consistent UI shell and feedback patterns.
- As a developer, I can consume API links without hardcoding transport paths.
- As support, I can capture request correlation IDs from UI errors.

## Acceptance Criteria
- HAL client consumes `_links` and supports relation-driven actions.
- Problem Details renderer handles non-2xx with clear messaging and `request_id`.
- Admin routes are denied when `/api/v1/me` does not grant required affordances.
- No UI hardcoding of event action routes (publish/cancel/export/registrations).

## End-of-Sprint Verification
```bash
npm run test -- ui-foundation hal-client
npm run lint
npm run build
```
Manual checks:
- Open protected admin route when logged out (must gate).
- Trigger a problem response and verify `request_id` appears.

Pass condition:
- All Sprint 13 tests pass.
- HAL + error contract behavior is verified.

## Exit Gate
Move sprint only when all acceptance criteria and verification checks pass.


===== FILE: project_management/sprints/completed/sprint-14-public-events-ui.md =====
# Sprint 14 — Public Events UI

## Goal
Deliver public events browsing and detail pages that consume HAL resources and state-dependent affordances.

## Scope
- Implement `/events` list page with paging/filter controls from API metadata.
- Implement `/events/[slug]` detail page.
- Render available actions strictly from HAL links.
- Display event state and user-specific affordances.

## TDD Process
1. Write failing page/component tests for list/detail render paths.
2. Write failing integration tests for HAL-link-driven actions visibility.
3. Implement minimal data-fetch and render logic.
4. Refactor for shared UI patterns with tests green.

## Stories
- As a visitor, I can browse published events.
- As a user, I can see allowed actions on event detail from API affordances.

## Acceptance Criteria
- `/events` renders from API response, including empty/error states.
- `/events/[slug]` renders detail and action controls from `_links`.
- UI does not assume `publish/cancel` endpoints; it follows affordances.
- Problem Details are shown through the global renderer.

## End-of-Sprint Verification
```bash
npm run test -- public-events-ui
npm run lint
npm run build
```
Manual checks:
- Navigate list -> detail.
- Confirm action controls change with event state/affordances.

Pass condition:
- All Sprint 14 tests pass.
- HAL-driven navigation validated.

## Exit Gate
Move sprint only when acceptance criteria and verification pass.


===== FILE: project_management/sprints/completed/sprint-15-auth-pages-account.md =====
# Sprint 15 — Auth Pages + Account

## Goal
Implement UI auth entry points and account surfaces using session-based API flows and robust Problem Details handling.

## Scope
- Implement `/login` and `/register` using React Hook Form + Zod.
- Implement `/account` page for current user profile and basic registration summary.
- Handle auth/session transitions cleanly (logged in/out states).
- Surface rate-limit and auth errors with friendly messages and request IDs.

## TDD Process
1. Write failing form validation tests for login/register.
2. Write failing integration tests for success/error auth flows.
3. Write failing tests for `/account` authenticated gating.
4. Implement and refactor with green tests.

## Stories
- As a new user, I can register and sign in.
- As an existing user, I can log in and access my account.
- As a user, I receive clear errors for invalid credentials and throttling.

## Acceptance Criteria
- Login/register submit to API and handle Problem Details consistently.
- `/account` requires session and renders user data from `/api/v1/me`.
- Rate-limit (`429`) feedback is user-friendly.
- Request IDs are visible on surfaced errors.

## End-of-Sprint Verification
```bash
npm run test -- auth-ui account-ui
npm run lint
npm run build
```
Manual checks:
- Register -> login -> account.
- Verify invalid credentials and rate-limit UX.

Pass condition:
- All Sprint 15 tests pass.
- Auth/session UX contract validated.

## Exit Gate
Move sprint only when acceptance criteria and verification pass.


===== FILE: project_management/sprints/completed/sprint-16-registration-ux.md =====
# Sprint 16 — Registration UX

## Goal
Deliver event registration UX preserving domain transitions: REGISTERED, WAITLISTED, CANCELLED, and CHECKED_IN visibility.

## Scope
- Add registration action on event detail.
- Show current registration status badges and transitions.
- Implement cancel action as state transition (no hard delete semantics in UI).
- Provide clear user feedback for waitlist outcomes.

## TDD Process
1. Write failing tests for register/cancel interaction flows.
2. Write failing tests for WAITLISTED behavior when capacity is full.
3. Write failing tests for status rendering and action availability.
4. Implement/refactor with green tests.

## Stories
- As a user, I can register for an event and see if I am waitlisted.
- As a user, I can cancel and see cancelled state reflected.

## Acceptance Criteria
- Register action reflects REGISTERED or WAITLISTED response.
- Cancel action transitions status to CANCELLED in UI state.
- UI state aligns with API status transitions.
- Problem responses are rendered consistently.

## End-of-Sprint Verification
```bash
npm run test -- registration-ui
npm run lint
npm run build
```
Manual checks:
- Register on available event.
- Register on full event and verify WAITLISTED.
- Cancel and verify CANCELLED status.

Pass condition:
- All Sprint 16 tests pass.
- Transition semantics verified against API behavior.

## Exit Gate
Move sprint only when acceptance criteria and verification pass.


===== FILE: project_management/sprints/completed/sprint-17-admin-events-console.md =====
# Sprint 17 — Admin Events Console

## Goal
Implement admin event management UI for list/create/edit and state-driven publish/cancel actions.

## Scope
- Implement `/admin/events` list + create flow.
- Implement `/admin/events/[slug]` detail/edit flow.
- Render publish/cancel controls only when corresponding HAL links exist.
- Support create/update validation feedback and problem rendering.

## TDD Process
1. Write failing tests for admin list/create/edit UI.
2. Write failing tests for HAL-driven publish/cancel action visibility.
3. Write failing integration tests for lifecycle transitions in UI.
4. Implement/refactor with tests green.

## Stories
- As an admin, I can create and edit events.
- As an admin, I can publish/cancel only when affordances are present.

## Acceptance Criteria
- `/admin/events` supports listing and creation.
- `/admin/events/[slug]` supports editing.
- Publish/cancel buttons are conditioned by `_links`.
- Error states use Problem Details renderer with request_id.

## End-of-Sprint Verification
```bash
npm run test -- admin-events-ui
npm run lint
npm run build
```
Manual checks:
- Create event, publish it, then cancel it via available links.
- Confirm button visibility changes by state.

Pass condition:
- All Sprint 17 tests pass.
- State-driven affordance behavior is verified.

## Exit Gate
Move sprint only when acceptance criteria and verification pass.


===== FILE: project_management/sprints/completed/sprint-18-admin-registrations-checkin-export.md =====
# Sprint 18 — Admin Registrations + Check-in + Export

## Goal
Implement admin registration operations, check-in workflows, and export UI with governance constraints.

## Scope
- Implement `/admin/events/[slug]/registrations` for list/add/cancel/check-in.
- Implement `/admin/events/[slug]/export` UI for csv/json exports.
- Enforce include-email governance behavior in UI.
- Display transitions and operation outcomes clearly.

## TDD Process
1. Write failing tests for registrations list/add/cancel/check-in.
2. Write failing tests for export format options and responses.
3. Write failing tests for include-email governance behavior.
4. Implement/refactor with tests green.

## Stories
- As an admin, I can manage registrations and check-ins.
- As an admin, I can export data while respecting governance constraints.

## Acceptance Criteria
- Registrations view supports add/cancel/check-in and status updates.
- Export supports csv/json and handles blocked include-email cases.
- UI follows API links and renders Problem Details for blocked actions.
- Request IDs are visible for operational troubleshooting.

## End-of-Sprint Verification
```bash
npm run test -- admin-registrations-ui export-ui
npm run lint
npm run build
```
Manual checks:
- Add/cancel/check-in registration.
- Export csv/json and validate include-email restrictions outside local.

Pass condition:
- All Sprint 18 tests pass.
- Governance behavior validated.

## Exit Gate
Move sprint only when acceptance criteria and verification pass.


===== FILE: project_management/sprints/completed/sprint-19-admin-users-ui.md =====
# Sprint 19 — Admin Users UI

## Goal
Deliver admin users management UI aligned with API RBAC and non-escalation rules.

## Scope
- Implement `/admin/users` list/search/filter.
- Implement user detail/status enable-disable interactions.
- Implement role add/remove UI for allowed roles.
- Explicitly block/remove SUPER_ADMIN role mutation controls in UI.

## TDD Process
1. Write failing tests for users list/search/detail interactions.
2. Write failing tests for enable/disable flows.
3. Write failing tests for role add/remove idempotency and SUPER_ADMIN exclusion.
4. Implement/refactor with tests green.

## Stories
- As an admin, I can manage user status and roles safely.
- As a security reviewer, I can confirm UI has no SUPER_ADMIN escalation surface.

## Acceptance Criteria
- Users list/search/detail works from API responses.
- Enable/disable actions update UI state accurately.
- Role add/remove works for permitted roles.
- No UI control allows SUPER_ADMIN role changes.

## End-of-Sprint Verification
```bash
npm run test -- admin-users-ui
npm run lint
npm run build
```
Manual checks:
- Add/remove ADMIN role and verify idempotent behavior.
- Confirm SUPER_ADMIN controls do not appear.

Pass condition:
- All Sprint 19 tests pass.
- Non-escalation UI constraints are validated.

## Exit Gate
Move sprint only when acceptance criteria and verification pass.


===== FILE: project_management/sprints/completed/sprint-20-ui-hardening-e2e-release.md =====
# Sprint 20 — UI Hardening + E2E + Release Gate

## Goal
Finalize UI for production readiness with end-to-end coverage, accessibility pass, and escalation-surface checks.

## Scope
- Build Playwright E2E suite for critical public + admin flows.
- Add accessibility pass for keyboard navigation, labels, and focus behavior.
- Ensure consistent Problem Details UX with request_id propagation.
- Verify no CLI-only super-admin/dangerous operations are exposed in UI.

## TDD Process
1. Write failing E2E tests for end-to-end user/admin journeys.
2. Write failing accessibility and error rendering checks.
3. Implement minimal fixes to pass release criteria.
4. Refactor while preserving behavior and full green suite.

## Stories
- As a release owner, I can trust core UI flows through automated E2E coverage.
- As support, I can diagnose failures via request_id surfaced in UI.

## Acceptance Criteria
- E2E flows pass:
  - register/login/logout
  - browse events
  - register/waitlist/cancel
  - admin create→publish→registrations→check-in→export.
- Accessibility checks pass for critical routes.
- Problem Details and request_id are consistently displayed.
- No UI surface exposes CLI-only operations.

## End-of-Sprint Verification
```bash
npm run test -- e2e ui-hardening
npm run lint
npm run build
```
Manual checks:
- Spot-check critical public/admin flows in browser.
- Confirm no SUPER_ADMIN/CLI-only operation surfaces.

Pass condition:
- All Sprint 20 tests pass.
- Release checklist is fully green.

## Exit Gate
UI Phase 1 is complete only when all criteria above pass and regression suite is green.


===== FILE: project_management/sprints/completed/sprint-21-e2e-api-foundation-contracts.md =====
# Sprint 21 — E2E API Foundation + Contracts

## Goal
Implement deterministic E2E coverage for API discoverability, docs, content types, and Problem Details contract consistency.

## Scope
- Add Playwright/API E2E tests for `GET /api/v1` and `GET /api/v1/docs`.
- Add negative tests for missing endpoints returning RFC 9457 Problem Details with `request_id`.
- Assert representative success/error content types (`application/hal+json` and `application/problem+json`).
- Standardize E2E fixtures for users/events/registrations baseline.

## TDD Process
1. Write failing E2E tests for root/docs/content-type and problem-shape.
2. Add deterministic seed/fixture loader for E2E suite.
3. Implement minimal fixes until all tests pass.
4. Refactor tests for readability and stability.

## Stories
- As a UI client, I can rely on stable API contracts.
- As support, I always receive `request_id` for failed requests.

## Acceptance Criteria
- Root/docs discovery tests pass.
- Missing endpoint test validates full Problem Details contract + `request_id`.
- Content-type tests pass across representative endpoints.
- Shared E2E fixture setup is committed and reusable.

## End-of-Sprint Verification
```bash
npm run test -- e2e api-foundation
npm run lint
npm run build
```

Pass condition:
- All Sprint 21 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


===== FILE: project_management/sprints/completed/sprint-22-e2e-auth-session-hardening.md =====
# Sprint 22 — E2E Auth + Session Hardening

## Goal
Deliver complete positive/negative E2E coverage for register/login/logout/account/session expiry/CSRF/rate-limit behavior.

## Scope
- Add UI E2E tests for register → login → account and logout gating.
- Add negative tests for invalid credentials and friendly Problem Details rendering with `request_id`.
- Add E2E coverage for rate-limited login/register flows.
- Add E2E coverage for expired session and CSRF-safe mutation blocking behavior.

## TDD Process
1. Write failing tests for happy path auth journey.
2. Write failing tests for invalid credentials, 429, CSRF, and session expiry.
3. Implement minimal app/test harness updates for deterministic pass.
4. Refactor selectors, fixture helpers, and retries.

## Stories
- As a user, I can authenticate reliably.
- As a security reviewer, I can validate hardening behavior from the UI.

## Acceptance Criteria
- Register/login/logout/account E2E flow passes.
- Invalid auth + rate-limit + CSRF + expiry behaviors are covered and pass.
- Every surfaced auth error includes request correlation in UI.

## End-of-Sprint Verification
```bash
npm run test -- e2e auth session
npm run lint
npm run build
```

Pass condition:
- All Sprint 22 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


===== FILE: project_management/sprints/completed/sprint-23-e2e-public-events-hal.md =====
# Sprint 23 — E2E Public Events + HAL Compliance

## Goal
Validate public event browsing and strict HATEOAS behavior from UI consumers.

## Scope
- Add E2E coverage for `/events` list and `/events/[slug]` detail.
- Add negative tests for bad slug and forced API failure UX with Problem Details + `request_id`.
- Add HAL affordance tests for state-dependent publish/cancel visibility in admin event detail.
- Add strongest HATEOAS proof test: modified HAL href is the URL used by UI actions.
- Add stale UI/race behavior test (action fails gracefully and UI refreshes state).

## TDD Process
1. Write failing browse/detail + negative slug tests.
2. Write failing HAL affordance and dynamic-href action tests.
3. Implement/refine UI or helpers to honor HAL links only.
4. Refactor for deterministic race handling in tests.

## Stories
- As a user, I can browse event data safely.
- As an API architect, I can confirm UI is link-driven, not hardcoded.

## Acceptance Criteria
- Public list/detail E2E tests pass.
- Negative public error rendering tests pass with request correlation.
- HAL affordance + dynamic href usage tests pass.
- Stale-action race test passes with graceful recovery behavior.

## End-of-Sprint Verification
```bash
npm run test -- e2e events hal
npm run lint
npm run build
```

Pass condition:
- All Sprint 23 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


===== FILE: project_management/sprints/completed/sprint-24-e2e-admin-operations-security.md =====
# Sprint 24 — E2E Admin Operations + Security Boundaries

## Goal
Complete E2E coverage for admin events, registrations/check-in/export, users UI, and non-escalation boundaries.

## Scope
- Add E2E tests for admin event create/edit/publish/cancel + validation/slug conflicts.
- Add E2E tests for admin registrations list/add/cancel/check-in/export + blocked include_email + rate-limit.
- Add E2E tests for admin users list/search/filter, enable/disable, ADMIN role idempotency.
- Add negative tests ensuring no SUPER_ADMIN controls in UI and API escalation attempts are denied.
- Add explicit unauthorized access tests for all admin web surfaces.

## TDD Process
1. Write failing admin events console tests.
2. Write failing registration/check-in/export governance tests.
3. Write failing admin users + non-escalation tests.
4. Implement minimal fixes and refactor shared admin E2E helpers.

## Stories
- As an admin, I can operate event lifecycle safely.
- As security, I can verify escalation controls are enforced.

## Acceptance Criteria
- Admin events/registrations/export/users E2E suites pass.
- Governance and 429 scenarios are covered and pass.
- SUPER_ADMIN and CLI-only boundaries are validated in tests.

## End-of-Sprint Verification
```bash
npm run test -- e2e admin operations security
npm run lint
npm run build
```

Pass condition:
- All Sprint 24 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


===== FILE: project_management/sprints/completed/sprint-25-e2e-release-journeys-regression.md =====
# Sprint 25 — E2E Release Journeys + Regression Gate

## Goal
Ship the consolidated release-gate E2E suite with public/admin journeys and supportability regressions.

## Scope
- Build one canonical public journey: browse → detail → register/waitlist/cancel.
- Build one canonical admin journey: create → publish → registration → check-in → export.
- Add supportability assertion that forced failures always display `request_id` in UI.
- Add regression test for role downgrade mid-session (admin loses access on refresh).
- Add CI-ready test grouping/tags and docs for release execution.

## TDD Process
1. Write failing end-to-end journey tests.
2. Add failing supportability + role-downgrade regression tests.
3. Implement minimal fixes for determinism and gating.
4. Refactor and stabilize release test command.

## Stories
- As a release owner, I can trust critical journeys before shipping.
- As support, I can triage using request correlation in failure UX.

## Acceptance Criteria
- Public and admin release journeys pass reliably.
- request_id supportability check passes.
- Role downgrade mid-session regression test passes.
- Release-gate command and docs are updated.

## End-of-Sprint Verification
```bash
npm run test -- e2e release regression
npm run lint
npm run build
```

Pass condition:
- All Sprint 25 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


===== FILE: project_management/sprints/completed/sprint-26-feature-password-reset-recovery.md =====
# Sprint 26 — Feature: Password Reset + Recovery E2E

## Goal
Implement password reset/account recovery feature and its complete positive/negative E2E suite.

## Scope
- Add reset request flow (UI + API) and reset confirmation flow.
- Add secure reset token generation, expiry, one-time use, and invalidation.
- Add deterministic test token capture strategy for E2E (test inbox/mock channel).
- Add E2E tests for valid reset, expired token, reused token, unknown email, and rate limits.

## TDD Process
1. Write failing E2E tests for reset request/confirm happy path.
2. Write failing negative token/rate-limit scenarios.
3. Implement minimal backend/UI flow and token lifecycle.
4. Refactor for security and deterministic tests.

## Stories
- As a user, I can recover access when I forget my password.
- As security, I can trust token and abuse controls.

## Acceptance Criteria
- Password reset happy path passes E2E.
- Negative token misuse and abuse-limit tests pass.
- No sensitive token leakage occurs in UI/logs.

## End-of-Sprint Verification
```bash
npm run test -- e2e password-reset
npm run lint
npm run build
```

Pass condition:
- All Sprint 26 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


===== FILE: project_management/sprints/completed/sprint-27-feature-email-verification.md =====
# Sprint 27 — Feature: Email Verification + E2E

## Goal
Implement optional/common email verification lifecycle with robust E2E coverage.

## Scope
- Add verification token issue + confirm flow after registration.
- Add account state behavior for unverified/verified users.
- Add resend verification endpoint with rate limiting.
- Add E2E tests for verify success, expired link, resend, and unverified access restrictions.

## TDD Process
1. Write failing tests for verify-required registration behavior.
2. Write failing tests for verification link lifecycle and resend limits.
3. Implement feature minimally in auth/session and UI messaging.
4. Refactor and ensure compatibility with existing auth tests.

## Stories
- As a product owner, I can trust account email ownership before full access.
- As a user, I can recover from expired verification links.

## Acceptance Criteria
- Verification happy/negative paths pass E2E.
- Unverified behavior is explicit and deterministic.
- Resend flow is rate-limited and user-friendly.

## End-of-Sprint Verification
```bash
npm run test -- e2e email-verification
npm run lint
npm run build
```

Pass condition:
- All Sprint 27 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


===== FILE: project_management/sprints/completed/sprint-28-feature-admin-invitations.md =====
# Sprint 28 — Feature: Admin Invitations + E2E

## Goal
Add secure admin invitation workflows that grant ADMIN (never SUPER_ADMIN) with full E2E validation.

## Scope
- Add invitation create/send/accept flow for admin role onboarding.
- Enforce invite expiry, one-time use, and existing-account behavior.
- Ensure invite flow cannot assign SUPER_ADMIN.
- Add positive and negative E2E tests for invitation lifecycle and unauthorized attempts.

## TDD Process
1. Write failing tests for admin invite happy path.
2. Write failing tests for reuse/expiry/existing-account/unauthorized invite attempts.
3. Implement invitation model + endpoints + minimal UI surfaces.
4. Refactor security validations and test fixtures.

## Stories
- As an admin, I can onboard another admin safely.
- As security, I can validate non-escalation at all times.

## Acceptance Criteria
- Invite lifecycle tests pass end-to-end.
- SUPER_ADMIN is never assignable in invite flow.
- Unauthorized invite creation is blocked and tested.

## End-of-Sprint Verification
```bash
npm run test -- e2e admin-invitations
npm run lint
npm run build
```

Pass condition:
- All Sprint 28 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


===== FILE: project_management/sprints/completed/sprint-29-feature-account-registrations-history.md =====
# Sprint 29 — Feature: Account Registrations History + E2E

## Goal
Upgrade `/account` into a complete “My registrations” experience with privacy-safe E2E coverage.

## Scope
- Add account registrations list/history across events with current status.
- Ensure status updates reflect cancel/check-in lifecycle changes.
- Add clear empty/loading/error states using Problem Details patterns.
- Add privacy tests proving users cannot access other users’ registration data.

## TDD Process
1. Write failing tests for account history rendering and state updates.
2. Write failing privacy/authorization negative tests.
3. Implement account history UI + API integration.
4. Refactor selectors/helpers and stabilize data setup.

## Stories
- As a user, I can view my complete registration history.
- As a privacy reviewer, I can verify strict per-user data isolation.

## Acceptance Criteria
- Account history E2E tests pass for normal and empty datasets.
- Lifecycle state updates are visible without data leakage.
- Privacy negative tests pass.

## End-of-Sprint Verification
```bash
npm run test -- e2e account-registrations
npm run lint
npm run build
```

Pass condition:
- All Sprint 29 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


===== FILE: project_management/sprints/completed/sprint-30-feature-event-discovery-search-calendar.md =====
# Sprint 30 — Feature: Event Discovery (Search/Filters/Calendar) + E2E

## Goal
Add richer event discovery quality features and verify them end-to-end.

## Scope
- Add public search/filter controls (title/location/tags as implemented scope).
- Persist filter state in URL and maintain stable pagination behavior.
- Add calendar export (ICS) download path if included in scope.
- Add E2E tests for search/filter/paging and timezone-correct calendar export.

## TDD Process
1. Write failing tests for search/filter/URL state + pagination stability.
2. Write failing tests for calendar export correctness (if implemented).
3. Implement minimal discovery enhancements in API + UI.
4. Refactor for performance and deterministic assertions.

## Stories
- As a visitor, I can find relevant events quickly.
- As a user, I can export events to calendar tools reliably.

## Acceptance Criteria
- Search/filter/pagination E2E tests pass.
- URL persistence behavior is covered and passing.
- ICS export tests pass when feature is enabled.

## End-of-Sprint Verification
```bash
npm run test -- e2e event-discovery
npm run lint
npm run build
```

Pass condition:
- All Sprint 30 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


===== FILE: project_management/sprints/completed/sprint-31-feature-audit-log-ui.md =====
# Sprint 31 — Feature: Audit Log UI + E2E

## Goal
Provide an admin audit viewer with enterprise-grade access and filtering, validated by E2E tests.

## Scope
- Add admin audit list view with action/actor/time filters.
- Surface key mutation events (publish/cancel/export/roles) with safe metadata.
- Enforce admin-only access to audit UI.
- Add E2E tests for positive admin visibility and non-admin denial.
- Add negative tests for sensitive field redaction expectations.

## TDD Process
1. Write failing audit viewer access and filter tests.
2. Write failing non-admin denial and redaction tests.
3. Implement minimal audit UI endpoints/pages and filter wiring.
4. Refactor for consistency with existing admin UX.

## Stories
- As an admin, I can inspect operational history confidently.
- As compliance, I can verify least-privilege visibility and redaction.

## Acceptance Criteria
- Audit list/filter tests pass for admin users.
- Non-admin denial tests pass.
- Redaction assertions pass for sensitive metadata.

## End-of-Sprint Verification
```bash
npm run test -- e2e audit-ui
npm run lint
npm run build
```

Pass condition:
- All Sprint 31 tests and verification commands pass.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


===== FILE: project_management/sprints/completed/sprint-32-feature-compliance-retention.md =====
# Sprint 32 — Feature: Compliance Basics (Terms/Privacy/Retention) + E2E

## Goal
Implement core compliance UX/API surfaces and validate them with E2E release checks.

## Scope
- Add Terms/Privacy routes and link integration in auth/account flows.
- Add registration acknowledgment checkbox flow if required.
- Implement baseline retention-aware account/data handling required by product scope.
- Add E2E tests for policy access, required acknowledgments, and retention/deletion constraints.
- Include final escalation-surface verification (no CLI-only dangerous operations exposed).

## TDD Process
1. Write failing tests for policy page availability and required acknowledgments.
2. Write failing retention/deletion and escalation-surface tests.
3. Implement minimal compliance features and UI affordances.
4. Refactor and run full release regression.

## Stories
- As a user, I can review product policies and consent where required.
- As release/compliance owner, I can validate baseline policy and retention behaviors.

## Acceptance Criteria
- Terms/Privacy and acknowledgment tests pass.
- Retention/deletion behaviors meet defined policy tests.
- Escalation-surface checks pass in final E2E gate.

## End-of-Sprint Verification
```bash
npm run test -- e2e compliance release
npm run lint
npm run build
```

Pass condition:
- All Sprint 32 tests and verification commands pass.
- UI+API E2E backlog from Letter 4 is fully planned and implementable.

## Exit Gate
Move sprint only when all acceptance criteria and verification pass.


===== FILE: README.md =====
# LMS 219 — Super Admin Control Plane

This repository contains:

- A Next.js application shell (`src/app`) for future UI work.
- A production-oriented CLI control plane (`appctl`) for admin/super-admin operations.

The CLI is the operational source of truth and currently supports:

- DB lifecycle: `status`, `migrate`, `seed`, `backup`, `restore`, `doctor`
- Service token management: create/revoke
- User and role management
- Event lifecycle management
- Registration, check-in, and event export workflows

## Tech Stack

- Runtime: Node.js 20+
- Language: TypeScript
- Web: Next.js 16
- CLI: Commander + Zod + cosmiconfig
- Data: SQLite (`better-sqlite3`)
- Logging: Pino
- Testing: Vitest

## Quick Start

Install dependencies:

```bash
npm install
```

Run quality checks:

```bash
npm test
npm run lint
npm run build
```

Run the web app:

```bash
npm run dev
```

Run the CLI:

```bash
npm run cli -- --help
```

## CLI Basics

Common examples:

```bash
# Health
npm run cli -- doctor --env local --json

# DB setup
npm run cli -- db migrate --env local
npm run cli -- db seed --env local

# Create token + user
npm run cli -- auth token create --name bootstrap --env local --json
npm run cli -- user create --email admin@example.com --status ACTIVE --env local
```

Global flags:

- `--env <local|staging|prod>`
- `--json`
- `--token <token>`
- `--yes`
- `--trace`

## Documentation

Detailed manual:

- [docs/cli-manual.md](docs/cli-manual.md)
- [CLI Architecture (Contributor Notes)](docs/cli-manual.md#10-cli-architecture-contributor-notes)

Project planning and sprint artifacts:

- [project_management/sprints/completed](project_management/sprints/completed)

## Current Status

All planned implementation sprints (1–6) are completed and manually verified through CLI-driven signoff.



===== FILE: src/app/__tests__/e2e-account-registrations.test.ts =====
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { GET as getAccountRegistrations } from "../api/v1/account/registrations/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import { POST as postLogin } from "../api/v1/auth/login/route";
import { DELETE as deleteRegistration } from "../api/v1/events/[slug]/registrations/[userId]/route";
import { POST as postCheckin } from "../api/v1/events/[slug]/checkins/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

describe("e2e account registrations history", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("returns only registrations for the authenticated user", async () => {
    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "userb@example.com",
          password: "Password123!",
        }),
      }),
    );

    const login = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "userb@example.com",
          password: "Password123!",
        }),
      }),
    );

    const userBCookie = (login.headers.get("set-cookie") ?? "").split(";")[0];

    const userBRegistrations = await getAccountRegistrations(
      new Request("http://localhost:3000/api/v1/account/registrations", {
        headers: { cookie: userBCookie },
      }),
    );

    expect(userBRegistrations.status).toBe(200);
    const userBBody = await userBRegistrations.json();
    expect(userBBody.count).toBe(0);
    expect(userBBody.items).toEqual([]);

    const userARegistrations = await getAccountRegistrations(
      new Request("http://localhost:3000/api/v1/account/registrations", {
        headers: { cookie: fixture.userCookie },
      }),
    );

    expect(userARegistrations.status).toBe(200);
    const userABody = await userARegistrations.json();
    expect(userABody.count).toBeGreaterThan(0);
    expect(userABody.items.every((item: { event_slug: string }) => item.event_slug !== "non-existent")).toBe(true);
  });

  it("reflects lifecycle status updates in account history", async () => {
    const cancel = await deleteRegistration(
      new Request(`http://localhost:3000/api/v1/events/published-open/registrations/${fixture.userId}`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.userCookie,
        },
      }),
      { params: Promise.resolve({ slug: "published-open", userId: fixture.userId }) },
    );
    expect(cancel.status).toBe(200);

    const checkin = await postCheckin(
      new Request("http://localhost:3000/api/v1/events/published-full/checkins", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ user_id: fixture.userId }),
      }),
      { params: Promise.resolve({ slug: "published-full" }) },
    );
    expect(checkin.status).toBe(200);

    const response = await getAccountRegistrations(
      new Request("http://localhost:3000/api/v1/account/registrations", {
        headers: { cookie: fixture.userCookie },
      }),
    );

    expect(response.status).toBe(200);
    const body = await response.json();

    const openRegistration = body.items.find(
      (item: { event_slug: string; status: string }) => item.event_slug === "published-open",
    );
    const fullRegistration = body.items.find(
      (item: { event_slug: string; status: string }) => item.event_slug === "published-full",
    );

    expect(openRegistration?.status).toBe("CANCELLED");
    expect(fullRegistration?.status).toBe("CHECKED_IN");
  });

  it("returns unauthorized without an active session", async () => {
    const response = await getAccountRegistrations(
      new Request("http://localhost:3000/api/v1/account/registrations"),
    );

    expect(response.status).toBe(401);
    const body = await response.json();
    expect(body.type).toBe("https://lms-219.dev/problems/unauthorized");
  });
});


===== FILE: src/app/__tests__/e2e-admin-invitations.test.ts =====
import Database from "better-sqlite3";
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { POST as postInvite } from "../api/v1/admin/invitations/route";
import { POST as postAcceptInvite } from "../api/v1/admin/invitations/accept/route";
import { POST as postLogin } from "../api/v1/auth/login/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import { GET as getMe } from "../api/v1/me/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

const findInviteIdByEmail = (dbPath: string, email: string) => {
  const db = new Database(dbPath);
  const row = db.prepare("SELECT id FROM api_admin_invitations WHERE email = ? ORDER BY created_at DESC LIMIT 1").get(email) as { id: string };
  db.close();
  return row.id;
};

describe("e2e admin invitations", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("allows admin to invite and invited user to accept as ADMIN", async () => {
    const invite = await postInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ email: "invitee@example.com" }),
      }),
    );

    expect(invite.status).toBe(201);
    const inviteBody = await invite.json();
    expect(inviteBody.role).toBe("ADMIN");
    expect(inviteBody.invitation_token).toBeTruthy();

    const accept = await postAcceptInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations/accept", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          token: inviteBody.invitation_token,
          password: "Password123!",
        }),
      }),
    );

    expect(accept.status).toBe(200);

    const login = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "invitee@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(login.status).toBe(200);
    const cookie = (login.headers.get("set-cookie") ?? "").split(";")[0];

    const me = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        headers: {
          cookie,
        },
      }),
    );
    expect(me.status).toBe(200);

    const meBody = await me.json();
    expect(meBody.roles).toContain("ADMIN");
    expect(meBody.roles).not.toContain("SUPER_ADMIN");
  });

  it("blocks invitation reuse and expired invitations", async () => {
    const invite = await postInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ email: "reuse-invitee@example.com" }),
      }),
    );

    const inviteBody = await invite.json();

    const firstAccept = await postAcceptInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations/accept", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          token: inviteBody.invitation_token,
          password: "Password123!",
        }),
      }),
    );
    expect(firstAccept.status).toBe(200);

    const reuse = await postAcceptInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations/accept", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          token: inviteBody.invitation_token,
          password: "Password123!",
        }),
      }),
    );
    expect(reuse.status).toBe(409);

    const invite2 = await postInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ email: "expired-invitee@example.com" }),
      }),
    );

    const inviteBody2 = await invite2.json();
    const inviteId = findInviteIdByEmail(fixture.dbPath, "expired-invitee@example.com");
    const db = new Database(fixture.dbPath);
    db.prepare("UPDATE api_admin_invitations SET expires_at = ? WHERE id = ?").run("2000-01-01T00:00:00.000Z", inviteId);
    db.close();

    const expiredAccept = await postAcceptInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations/accept", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          token: inviteBody2.invitation_token,
          password: "Password123!",
        }),
      }),
    );

    expect(expiredAccept.status).toBe(412);
  });

  it("rejects invites for existing accounts and unauthorized invite attempts", async () => {
    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "existing@example.com",
          password: "Password123!",
        }),
      }),
    );

    const existingConflict = await postInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ email: "existing@example.com" }),
      }),
    );
    expect(existingConflict.status).toBe(409);

    const asUser = await postInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.userCookie,
        },
        body: JSON.stringify({ email: "forbidden@example.com" }),
      }),
    );
    expect(asUser.status).toBe(403);

    const asAnon = await postInvite(
      new Request("http://localhost:3000/api/v1/admin/invitations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ email: "anon@example.com" }),
      }),
    );
    expect(asAnon.status).toBe(401);
  });
});


===== FILE: src/app/__tests__/e2e-admin-operations-security.test.ts =====
import { randomUUID } from "node:crypto";
import Database from "better-sqlite3";
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { POST as postLogin } from "../api/v1/auth/login/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import { POST as postEvents, GET as getEvents } from "../api/v1/events/route";
import { POST as postPublish } from "../api/v1/events/[slug]/publish/route";
import { POST as postCancel } from "../api/v1/events/[slug]/cancel/route";
import { POST as postRegistration } from "../api/v1/events/[slug]/registrations/route";
import { DELETE as deleteRegistration } from "../api/v1/events/[slug]/registrations/[userId]/route";
import { POST as postCheckin } from "../api/v1/events/[slug]/checkins/route";
import { GET as getExport } from "../api/v1/events/[slug]/export/route";
import { GET as getUsers } from "../api/v1/users/route";
import { PATCH as patchUser } from "../api/v1/users/[id]/route";
import { POST as postRole } from "../api/v1/users/[id]/roles/route";
import { DELETE as deleteRole } from "../api/v1/users/[id]/roles/[role]/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

const userIdByEmail = (dbPath: string, email: string) => {
  const db = new Database(dbPath);
  const row = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  db.close();
  return row.id;
};

describe("e2e admin operations security", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("enforces admin access boundaries for admin endpoints", async () => {
    const usersAsUser = await getUsers(
      new Request("http://localhost:3000/api/v1/users", {
        headers: {
          cookie: fixture.userCookie,
        },
      }),
    );
    expect(usersAsUser.status).toBe(403);

    const createAsUser = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.userCookie,
        },
        body: JSON.stringify({
          slug: "forbidden-user-create",
          title: "Forbidden",
          start: "2026-11-01T10:00:00.000Z",
          end: "2026-11-01T11:00:00.000Z",
          timezone: "UTC",
        }),
      }),
    );

    expect(createAsUser.status).toBe(403);
  });

  it("supports admin event create/publish/cancel and validation/conflict checks", async () => {
    const invalidCreate = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({
          slug: "",
          title: "",
          start: "bad",
          end: "bad",
          timezone: "UTC",
        }),
      }),
    );
    expect(invalidCreate.status).toBe(400);

    const create = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({
          slug: "admin-security-event",
          title: "Admin Security Event",
          start: "2026-11-02T10:00:00.000Z",
          end: "2026-11-02T11:00:00.000Z",
          timezone: "UTC",
          capacity: 2,
        }),
      }),
    );
    expect(create.status).toBe(201);

    const conflict = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({
          slug: "admin-security-event",
          title: "Dup",
          start: "2026-11-02T10:00:00.000Z",
          end: "2026-11-02T11:00:00.000Z",
          timezone: "UTC",
        }),
      }),
    );
    expect(conflict.status).toBe(409);

    const publish = await postPublish(
      new Request("http://localhost:3000/api/v1/events/admin-security-event/publish", {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "admin-security-event" }) },
    );
    expect(publish.status).toBe(200);

    const cancelNoReason = await postCancel(
      new Request("http://localhost:3000/api/v1/events/admin-security-event/cancel", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ reason: "" }),
      }),
      { params: Promise.resolve({ slug: "admin-security-event" }) },
    );
    expect(cancelNoReason.status).toBe(400);

    const cancel = await postCancel(
      new Request("http://localhost:3000/api/v1/events/admin-security-event/cancel", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ reason: "Operational cancel" }),
      }),
      { params: Promise.resolve({ slug: "admin-security-event" }) },
    );
    expect(cancel.status).toBe(200);
  });

  it("enforces registration/check-in/export governance and rate limits", async () => {
    const addUnknownUser = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/published-open/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ user_id: randomUUID() }),
      }),
      { params: Promise.resolve({ slug: "published-open" }) },
    );
    expect(addUnknownUser.status).toBe(404);

    const cancelExisting = await deleteRegistration(
      new Request(`http://localhost:3000/api/v1/events/published-open/registrations/${fixture.userId}`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "published-open", userId: fixture.userId }) },
    );
    expect(cancelExisting.status).toBe(200);

    const checkinCancelled = await postCheckin(
      new Request("http://localhost:3000/api/v1/events/published-open/checkins", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ user_id: fixture.userId }),
      }),
      { params: Promise.resolve({ slug: "published-open" }) },
    );
    expect(checkinCancelled.status).toBe(412);

    let exportResponse: Response | null = null;
    for (let index = 0; index < 6; index += 1) {
      exportResponse = await getExport(
        new Request("http://localhost:3000/api/v1/events/published-open/export?format=json", {
          headers: {
            cookie: fixture.adminCookie,
            "x-forwarded-for": "203.0.113.10",
          },
        }),
        { params: Promise.resolve({ slug: "published-open" }) },
      );
    }

    expect(exportResponse?.status).toBe(429);

    process.env.APPCTL_ENV = "prod";
    const includeEmailBlocked = await getExport(
      new Request("https://example.com/api/v1/events/published-open/export?format=json&include_email=true", {
        headers: {
          cookie: fixture.adminCookie,
          "x-forwarded-for": "203.0.113.20",
        },
      }),
      { params: Promise.resolve({ slug: "published-open" }) },
    );
    expect(includeEmailBlocked.status).toBe(403);
    process.env.APPCTL_ENV = "local";
  });

  it("enforces user role/state governance and blocks super-admin escalation", async () => {
    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "admin-ops-target@example.com",
          password: "Password123!",
        }),
      }),
    );

    const targetId = userIdByEmail(fixture.dbPath, "admin-ops-target@example.com");

    const addAdmin = await postRole(
      new Request(`http://localhost:3000/api/v1/users/${targetId}/roles`, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ role: "ADMIN" }),
      }),
      { params: Promise.resolve({ id: targetId }) },
    );
    expect(addAdmin.status).toBe(200);
    expect((await addAdmin.json()).changed).toBe(true);

    const addAdminAgain = await postRole(
      new Request(`http://localhost:3000/api/v1/users/${targetId}/roles`, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ role: "ADMIN" }),
      }),
      { params: Promise.resolve({ id: targetId }) },
    );
    expect((await addAdminAgain.json()).changed).toBe(false);

    const removeAdmin = await deleteRole(
      new Request(`http://localhost:3000/api/v1/users/${targetId}/roles/ADMIN`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ id: targetId, role: "ADMIN" }) },
    );
    expect((await removeAdmin.json()).changed).toBe(true);

    const removeAdminAgain = await deleteRole(
      new Request(`http://localhost:3000/api/v1/users/${targetId}/roles/ADMIN`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ id: targetId, role: "ADMIN" }) },
    );
    expect((await removeAdminAgain.json()).changed).toBe(false);

    const addSuperAdmin = await postRole(
      new Request(`http://localhost:3000/api/v1/users/${targetId}/roles`, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ role: "SUPER_ADMIN" }),
      }),
      { params: Promise.resolve({ id: targetId }) },
    );
    expect(addSuperAdmin.status).toBe(403);

    const disable = await patchUser(
      new Request(`http://localhost:3000/api/v1/users/${targetId}`, {
        method: "PATCH",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ status: "DISABLED" }),
      }),
      { params: Promise.resolve({ id: targetId }) },
    );
    expect(disable.status).toBe(200);

    const disabledLogin = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "admin-ops-target@example.com",
          password: "Password123!",
        }),
      }),
    );
    expect(disabledLogin.status).toBe(401);

    const enable = await patchUser(
      new Request(`http://localhost:3000/api/v1/users/${targetId}`, {
        method: "PATCH",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ status: "ACTIVE" }),
      }),
      { params: Promise.resolve({ id: targetId }) },
    );
    expect(enable.status).toBe(200);

    const activeLogin = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "admin-ops-target@example.com",
          password: "Password123!",
        }),
      }),
    );
    expect(activeLogin.status).toBe(200);
  });

  it("keeps users listing usable for admin search/filter", async () => {
    const filtered = await getUsers(
      new Request("http://localhost:3000/api/v1/users?search=usera@example.com&role=USER&status=ACTIVE", {
        headers: {
          cookie: fixture.adminCookie,
        },
      }),
    );

    expect(filtered.status).toBe(200);
    const body = await filtered.json();
    expect(Array.isArray(body.items)).toBe(true);
    expect(body.items.some((user: { email: string }) => user.email === "usera@example.com")).toBe(true);

    const allEvents = await getEvents(new Request("http://localhost:3000/api/v1/events"));
    expect(allEvents.status).toBe(200);
  });
});


===== FILE: src/app/__tests__/e2e-api-foundation.test.ts =====
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { GET as getDocs } from "../api/v1/docs/route";
import { GET as getEvents } from "../api/v1/events/route";
import { GET as getEventBySlug } from "../api/v1/events/[slug]/route";
import { GET as getRegistrations } from "../api/v1/events/[slug]/registrations/route";
import { GET as getApiRoot } from "../api/v1/route";

import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

describe("e2e api-foundation", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("serves api root as HAL with discoverable links", async () => {
    const response = await getApiRoot();

    expect(response.status).toBe(200);
    expect(response.headers.get("content-type")).toContain("application/hal+json");

    const body = await response.json();
    expect(body._links.self.href).toBe("/api/v1");
    expect(body._links.docs.href).toBe("/api/v1/docs");
    expect(body._links.events.href).toBe("/api/v1/events");
    expect(body._links.auth_login.href).toBe("/api/v1/auth/login");
  });

  it("serves docs endpoint with openapi payload", async () => {
    const response = await getDocs();

    expect(response.status).toBe(200);
    expect(response.headers.get("content-type")).toContain("application/json");

    const body = await response.json();
    expect(body.openapi).toBeTruthy();
    expect(body.info).toBeTruthy();
    expect(body.paths).toBeTruthy();
  });

  it("returns problem details with request correlation on not-found resource", async () => {
    const request = new Request("http://localhost:3000/api/v1/events/does-not-exist");
    const response = await getEventBySlug(request, {
      params: Promise.resolve({ slug: "does-not-exist" }),
    });

    expect(response.status).toBe(404);
    expect(response.headers.get("content-type")).toContain("application/problem+json");

    const body = await response.json();
    expect(body.type).toBeTruthy();
    expect(body.title).toBe("Not Found");
    expect(body.status).toBe(404);
    expect(body.detail).toBeTruthy();
    expect(body.instance).toBe("http://localhost:3000/api/v1/events/does-not-exist");
    expect(body.request_id).toBeTruthy();
    expect(response.headers.get("x-request-id")).toBe(body.request_id);
  });

  it("keeps representative success/error media types consistent", async () => {
    const successResponse = await getEvents(new Request("http://localhost:3000/api/v1/events"));
    expect(successResponse.status).toBe(200);
    expect(successResponse.headers.get("content-type")).toContain("application/hal+json");

    const errorResponse = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/missing"),
      {
        params: Promise.resolve({ slug: "missing" }),
      },
    );

    expect(errorResponse.status).toBe(404);
    expect(errorResponse.headers.get("content-type")).toContain("application/problem+json");
  });

  it("provides deterministic baseline fixture resources", async () => {
    const published = await getEvents(
      new Request("http://localhost:3000/api/v1/events?status=PUBLISHED"),
    );
    const publishedBody = await published.json();
    const publishedSlugs = publishedBody.items.map((item: { slug: string }) => item.slug);

    expect(publishedSlugs).toContain("published-open");
    expect(publishedSlugs).toContain("published-full");

    const draft = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/draft-event"),
      { params: Promise.resolve({ slug: "draft-event" }) },
    );
    expect(draft.status).toBe(200);

    const cancelled = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/cancelled-event"),
      { params: Promise.resolve({ slug: "cancelled-event" }) },
    );
    const cancelledBody = await cancelled.json();
    expect(cancelledBody.status).toBe("CANCELLED");

    const registrations = await getRegistrations(
      new Request("http://localhost:3000/api/v1/events/published-open/registrations", {
        headers: {
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "published-open" }) },
    );

    expect(registrations.status).toBe(200);
    const registrationsBody = await registrations.json();
    const userEntry = registrationsBody.items.find((item: { user_id: string }) => item.user_id === fixture.userId);
    expect(userEntry).toBeTruthy();
  });
});


===== FILE: src/app/__tests__/e2e-audit-ui.test.ts =====
import { randomUUID } from "node:crypto";
import Database from "better-sqlite3";
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { GET as getAudit } from "../api/v1/audit/route";
import { POST as postEvents } from "../api/v1/events/route";
import { POST as postPublish } from "../api/v1/events/[slug]/publish/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

describe("e2e audit ui", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("allows admin audit visibility with action and actor filters", async () => {
    const create = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({
          slug: "audit-ops-event",
          title: "Audit Ops Event",
          start: "2026-11-10T10:00:00.000Z",
          end: "2026-11-10T11:00:00.000Z",
          timezone: "UTC",
          capacity: 10,
        }),
      }),
    );
    expect(create.status).toBe(201);

    const publish = await postPublish(
      new Request("http://localhost:3000/api/v1/events/audit-ops-event/publish", {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "audit-ops-event" }) },
    );
    expect(publish.status).toBe(200);

    const filtered = await getAudit(
      new Request(
        `http://localhost:3000/api/v1/audit?action=api.event.publish&actor_id=${fixture.adminId}&limit=20&offset=0`,
        {
          headers: {
            cookie: fixture.adminCookie,
          },
        },
      ),
    );

    expect(filtered.status).toBe(200);
    const body = await filtered.json();
    expect(body.count).toBeGreaterThan(0);
    expect(
      body.items.every(
        (item: { action: string; actor_id: string | null }) =>
          item.action === "api.event.publish" && item.actor_id === fixture.adminId,
      ),
    ).toBe(true);
  });

  it("denies non-admin users from reading audit entries", async () => {
    const response = await getAudit(
      new Request("http://localhost:3000/api/v1/audit", {
        headers: {
          cookie: fixture.userCookie,
        },
      }),
    );

    expect(response.status).toBe(403);
    const body = await response.json();
    expect(body.type).toBe("https://lms-219.dev/problems/forbidden");
  });

  it("redacts sensitive metadata fields in audit output", async () => {
    const db = new Database(fixture.dbPath);
    db.prepare(
      `
INSERT INTO audit_log (
  id,
  actor_type,
  actor_id,
  action,
  target_type,
  target_id,
  metadata,
  created_at,
  request_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
    ).run(
      randomUUID(),
      "USER",
      fixture.adminId,
      "api.test.sensitive",
      "system",
      null,
      JSON.stringify({
        token: "abc123",
        password_hash: "hash-value",
        user_email: "private@example.com",
        nested: {
          secret: "hide-me",
          reason: "keep-visible",
        },
      }),
      new Date().toISOString(),
      randomUUID(),
    );
    db.close();

    const response = await getAudit(
      new Request("http://localhost:3000/api/v1/audit?action=api.test.sensitive", {
        headers: {
          cookie: fixture.adminCookie,
        },
      }),
    );

    expect(response.status).toBe(200);
    const body = await response.json();
    expect(body.count).toBeGreaterThan(0);

    const item = body.items[0] as {
      metadata: {
        token: string;
        password_hash: string;
        user_email: string;
        nested: { secret: string; reason: string };
      };
    };

    expect(item.metadata.token).toBe("[REDACTED]");
    expect(item.metadata.password_hash).toBe("[REDACTED]");
    expect(item.metadata.user_email).toBe("[REDACTED]");
    expect(item.metadata.nested.secret).toBe("[REDACTED]");
    expect(item.metadata.nested.reason).toBe("keep-visible");
  });
});


===== FILE: src/app/__tests__/e2e-auth-session-hardening.test.ts =====
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { GET as getMe } from "../api/v1/me/route";
import { GET as getUsers } from "../api/v1/users/route";
import { POST as postLogin } from "../api/v1/auth/login/route";
import { POST as postLogout } from "../api/v1/auth/logout/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

describe("e2e auth session hardening", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("supports register/login/logout lifecycle with me gating", async () => {
    const register = await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.10",
        },
        body: JSON.stringify({
          email: "sprint22-user@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(register.status).toBe(201);

    const login = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.10",
        },
        body: JSON.stringify({
          email: "sprint22-user@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(login.status).toBe(200);
    const cookie = (login.headers.get("set-cookie") ?? "").split(";")[0];

    const meBeforeLogout = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        method: "GET",
        headers: {
          cookie,
        },
      }),
    );
    expect(meBeforeLogout.status).toBe(200);

    const logout = await postLogout(
      new Request("http://localhost:3000/api/v1/auth/logout", {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie,
        },
      }),
    );

    expect(logout.status).toBe(200);
    expect(logout.headers.get("set-cookie")).toContain("Max-Age=0");

    const meAfterLogout = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        method: "GET",
        headers: {
          cookie,
        },
      }),
    );

    expect(meAfterLogout.status).toBe(401);
  });

  it("shows invalid credentials as problem details with request correlation", async () => {
    const failedLogin = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.20",
        },
        body: JSON.stringify({
          email: "usera@example.com",
          password: "wrong-password",
        }),
      }),
    );

    expect(failedLogin.status).toBe(401);
    expect(failedLogin.headers.get("content-type")).toContain("application/problem+json");

    const body = await failedLogin.json();
    expect(body.title).toBe("Unauthorized");
    expect(body.status).toBe(401);
    expect(body.request_id).toBeTruthy();
    expect(failedLogin.headers.get("x-request-id")).toBe(body.request_id);
  });

  it("enforces rate limits for login and register", async () => {
    let loginResponse: Response | null = null;
    for (let index = 0; index < 6; index += 1) {
      loginResponse = await postLogin(
        new Request("http://localhost:3000/api/v1/auth/login", {
          method: "POST",
          headers: {
            "content-type": "application/json",
            origin: "http://localhost:3000",
            "x-forwarded-for": "198.51.100.30",
          },
          body: JSON.stringify({
            email: "usera@example.com",
            password: "bad-password",
          }),
        }),
      );
    }

    expect(loginResponse?.status).toBe(429);

    let registerResponse: Response | null = null;
    for (let index = 0; index < 6; index += 1) {
      registerResponse = await postRegister(
        new Request("http://localhost:3000/api/v1/auth/register", {
          method: "POST",
          headers: {
            "content-type": "application/json",
            origin: "http://localhost:3000",
            "x-forwarded-for": "198.51.100.40",
          },
          body: JSON.stringify({
            email: "rate-limit-user@example.com",
            password: "Password123!",
          }),
        }),
      );
    }

    expect(registerResponse?.status).toBe(429);
    expect(registerResponse?.headers.get("retry-after")).toBeTruthy();
  });

  it("blocks csrf-unsafe auth mutations with problem details", async () => {
    const csrfBlockedRegister = await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "https://evil.example",
          "x-forwarded-for": "198.51.100.50",
        },
        body: JSON.stringify({
          email: "csrf-user@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(csrfBlockedRegister.status).toBe(403);
    expect(csrfBlockedRegister.headers.get("content-type")).toContain("application/problem+json");

    const body = await csrfBlockedRegister.json();
    expect(body.title).toBe("Forbidden");
    expect(body.request_id).toBeTruthy();
  });

  it("supports role-aware me links and blocks admin routes when session expires", async () => {
    const meAsAdmin = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        method: "GET",
        headers: {
          cookie: fixture.adminCookie,
        },
      }),
    );

    expect(meAsAdmin.status).toBe(200);
    const meBody = await meAsAdmin.json();
    expect(meBody._links.users.href).toBe("/api/v1/users");

    const logout = await postLogout(
      new Request("http://localhost:3000/api/v1/auth/logout", {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
    );
    expect(logout.status).toBe(200);

    const usersAfterExpiry = await getUsers(
      new Request("http://localhost:3000/api/v1/users", {
        headers: {
          cookie: fixture.adminCookie,
        },
      }),
    );

    expect(usersAfterExpiry.status).toBe(401);
    expect(usersAfterExpiry.headers.get("content-type")).toContain("application/problem+json");
  });
});


===== FILE: src/app/__tests__/e2e-compliance-release.test.ts =====
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { GET as getApiRoot } from "../api/v1/route";
import { GET as getMe } from "../api/v1/me/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import { POST as postDeleteAccount } from "../api/v1/account/delete/route";
import { GET as getRegistrations } from "../api/v1/events/[slug]/registrations/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

describe("e2e compliance release", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("surfaces terms/privacy policy links in root and account flows", async () => {
    const root = await getApiRoot();
    expect(root.status).toBe(200);
    const rootBody = await root.json();
    expect(rootBody._links.terms.href).toBe("/terms");
    expect(rootBody._links.privacy.href).toBe("/privacy");
    expect(rootBody._links.account_delete.href).toBe("/api/v1/account/delete");

    const me = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        headers: { cookie: fixture.userCookie },
      }),
    );
    expect(me.status).toBe(200);
    const meBody = await me.json();
    expect(meBody._links.terms.href).toBe("/terms");
    expect(meBody._links.privacy.href).toBe("/privacy");
    expect(meBody._links.account_delete.href).toBe("/api/v1/account/delete");
  });

  it("rejects explicit missing consent during registration", async () => {
    const denied = await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "consent-denied@example.com",
          password: "Password123!",
          terms_accepted: false,
        }),
      }),
    );

    expect(denied.status).toBe(400);
    const deniedBody = await denied.json();
    expect(deniedBody.detail).toContain("acknowledgment");

    const accepted = await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "consent-accepted@example.com",
          password: "Password123!",
          terms_accepted: true,
        }),
      }),
    );

    expect(accepted.status).toBe(201);
  });

  it("applies retention-safe account deletion by revoking access and cancelling registrations", async () => {
    const deleted = await postDeleteAccount(
      new Request("http://localhost:3000/api/v1/account/delete", {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.userCookie,
        },
      }),
    );

    expect(deleted.status).toBe(200);

    const meAfterDelete = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        headers: { cookie: fixture.userCookie },
      }),
    );
    expect(meAfterDelete.status).toBe(401);

    const registrations = await getRegistrations(
      new Request("http://localhost:3000/api/v1/events/published-open/registrations", {
        headers: {
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "published-open" }) },
    );
    expect(registrations.status).toBe(200);
    const registrationsBody = await registrations.json();

    const deletedUserRegistration = registrationsBody.items.find(
      (item: { user_id: string; status: string }) => item.user_id === fixture.userId,
    );

    expect(deletedUserRegistration?.status).toBe("CANCELLED");
  });

  it("keeps escalation-only operations out of API discoverability surface", async () => {
    const root = await getApiRoot();
    expect(root.status).toBe(200);
    const body = await root.json();

    expect(body._links.db_backup).toBeUndefined();
    expect(body._links.db_restore).toBeUndefined();
    expect(body._links.auth_token_create).toBeUndefined();
  });
});


===== FILE: src/app/__tests__/e2e-email-verification.test.ts =====
import Database from "better-sqlite3";
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { POST as postLogin } from "../api/v1/auth/login/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import { POST as postVerifyRequest } from "../api/v1/auth/verify/request/route";
import { POST as postVerifyConfirm } from "../api/v1/auth/verify/confirm/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

const userIdByEmail = (dbPath: string, email: string) => {
  const db = new Database(dbPath);
  const row = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  db.close();
  return row.id;
};

describe("e2e email verification", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
    process.env.APPCTL_REQUIRE_EMAIL_VERIFICATION = "true";
  });

  afterEach(async () => {
    delete process.env.APPCTL_REQUIRE_EMAIL_VERIFICATION;
    await cleanupStandardE2EFixtures();
  });

  it("requires verification before login and allows login after confirm", async () => {
    const register = await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "verify-user@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(register.status).toBe(201);
    const registerBody = await register.json();
    expect(registerBody.status).toBe("PENDING");

    const loginBlocked = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "verify-user@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(loginBlocked.status).toBe(403);
    const blockedBody = await loginBlocked.json();
    expect(blockedBody.type).toContain("email-unverified");
    expect(blockedBody.request_id).toBeTruthy();

    const resend = await postVerifyRequest(
      new Request("http://localhost:3000/api/v1/auth/verify/request", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.81",
        },
        body: JSON.stringify({ email: "verify-user@example.com" }),
      }),
    );

    expect(resend.status).toBe(202);
    const resendBody = await resend.json();
    expect(resendBody.verification_token).toBeTruthy();

    const confirm = await postVerifyConfirm(
      new Request("http://localhost:3000/api/v1/auth/verify/confirm", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ token: resendBody.verification_token }),
      }),
    );

    expect(confirm.status).toBe(200);

    const loginAllowed = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "verify-user@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(loginAllowed.status).toBe(200);
  });

  it("rejects expired verification token", async () => {
    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "expired-verify@example.com",
          password: "Password123!",
        }),
      }),
    );

    const requestToken = await postVerifyRequest(
      new Request("http://localhost:3000/api/v1/auth/verify/request", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.82",
        },
        body: JSON.stringify({ email: "expired-verify@example.com" }),
      }),
    );
    const tokenBody = await requestToken.json();

    const userId = userIdByEmail(fixture.dbPath, "expired-verify@example.com");
    const db = new Database(fixture.dbPath);
    db.prepare(
      "UPDATE api_email_verifications SET expires_at = ?, used_at = NULL WHERE user_id = ?",
    ).run("2000-01-01T00:00:00.000Z", userId);
    db.close();

    const confirmExpired = await postVerifyConfirm(
      new Request("http://localhost:3000/api/v1/auth/verify/confirm", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ token: tokenBody.verification_token }),
      }),
    );

    expect(confirmExpired.status).toBe(412);
  });

  it("supports resend lifecycle and blocks old token after resend", async () => {
    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "resend-verify@example.com",
          password: "Password123!",
        }),
      }),
    );

    const first = await postVerifyRequest(
      new Request("http://localhost:3000/api/v1/auth/verify/request", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.83",
        },
        body: JSON.stringify({ email: "resend-verify@example.com" }),
      }),
    );
    const firstBody = await first.json();

    const second = await postVerifyRequest(
      new Request("http://localhost:3000/api/v1/auth/verify/request", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.83",
        },
        body: JSON.stringify({ email: "resend-verify@example.com" }),
      }),
    );
    const secondBody = await second.json();

    const confirmOld = await postVerifyConfirm(
      new Request("http://localhost:3000/api/v1/auth/verify/confirm", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ token: firstBody.verification_token }),
      }),
    );
    expect(confirmOld.status).toBe(409);

    const confirmNew = await postVerifyConfirm(
      new Request("http://localhost:3000/api/v1/auth/verify/confirm", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ token: secondBody.verification_token }),
      }),
    );
    expect(confirmNew.status).toBe(200);
  });

  it("rate limits verification resend endpoint", async () => {
    let response: Response | null = null;

    for (let index = 0; index < 6; index += 1) {
      response = await postVerifyRequest(
        new Request("http://localhost:3000/api/v1/auth/verify/request", {
          method: "POST",
          headers: {
            "content-type": "application/json",
            origin: "http://localhost:3000",
            "x-forwarded-for": "198.51.100.84",
          },
          body: JSON.stringify({ email: "any@example.com" }),
        }),
      );
    }

    expect(response?.status).toBe(429);
    expect(response?.headers.get("retry-after")).toBeTruthy();
  });
});


===== FILE: src/app/__tests__/e2e-event-discovery.test.ts =====
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { GET as getEvents } from "../api/v1/events/route";
import { POST as postEvent } from "../api/v1/events/route";
import { POST as postPublish } from "../api/v1/events/[slug]/publish/route";
import { GET as getEventIcs } from "../api/v1/events/[slug]/ics/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

describe("e2e event discovery", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("supports title search with stable pagination", async () => {
    const created = [
      { slug: "summit-alpha", title: "Summit Alpha", day: "05" },
      { slug: "summit-beta", title: "Summit Beta", day: "06" },
      { slug: "summit-gamma", title: "Summit Gamma", day: "07" },
    ];

    for (const item of created) {
      const create = await postEvent(
        new Request("http://localhost:3000/api/v1/events", {
          method: "POST",
          headers: {
            "content-type": "application/json",
            origin: "http://localhost:3000",
            cookie: fixture.adminCookie,
          },
          body: JSON.stringify({
            slug: item.slug,
            title: item.title,
            start: `2026-10-${item.day}T10:00:00.000Z`,
            end: `2026-10-${item.day}T11:00:00.000Z`,
            timezone: "UTC",
            capacity: 20,
          }),
        }),
      );
      expect(create.status).toBe(201);

      const publish = await postPublish(
        new Request(`http://localhost:3000/api/v1/events/${item.slug}/publish`, {
          method: "POST",
          headers: {
            origin: "http://localhost:3000",
            cookie: fixture.adminCookie,
          },
        }),
        { params: Promise.resolve({ slug: item.slug }) },
      );
      expect(publish.status).toBe(200);
    }

    const firstPage = await getEvents(
      new Request("http://localhost:3000/api/v1/events?q=Summit&limit=2&offset=0"),
    );
    expect(firstPage.status).toBe(200);
    const firstPageBody = await firstPage.json();
    expect(firstPageBody.items).toHaveLength(2);
    expect(
      firstPageBody.items.every((item: { title: string }) => item.title.toLowerCase().includes("summit")),
    ).toBe(true);

    const secondPage = await getEvents(
      new Request("http://localhost:3000/api/v1/events?q=Summit&limit=2&offset=2"),
    );
    expect(secondPage.status).toBe(200);
    const secondPageBody = await secondPage.json();
    expect(secondPageBody.items).toHaveLength(1);
    expect(secondPageBody.items[0].title).toContain("Summit");

    const pageOneIds = new Set(firstPageBody.items.map((item: { id: string }) => item.id));
    expect(pageOneIds.has(secondPageBody.items[0].id)).toBe(false);
  });

  it("exports timezone-correct ICS event data", async () => {
    const response = await getEventIcs(
      new Request("http://localhost:3000/api/v1/events/published-open/ics"),
      { params: Promise.resolve({ slug: "published-open" }) },
    );

    expect(response.status).toBe(200);
    expect(response.headers.get("content-type")).toContain("text/calendar");

    const body = await response.text();
    expect(body).toContain("BEGIN:VCALENDAR");
    expect(body).toContain("SUMMARY:Published Open");
    expect(body).toContain("DTSTART:20260901T100000Z");
    expect(body).toContain("DTEND:20260901T110000Z");
  });
});


===== FILE: src/app/__tests__/e2e-password-reset.test.ts =====
import Database from "better-sqlite3";
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { POST as postLogin } from "../api/v1/auth/login/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import { POST as postResetRequest } from "../api/v1/auth/password-reset/request/route";
import { POST as postResetConfirm } from "../api/v1/auth/password-reset/confirm/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

const userIdByEmail = (dbPath: string, email: string) => {
  const db = new Database(dbPath);
  const row = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  db.close();
  return row.id;
};

describe("e2e password reset", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("supports password reset request and confirm with one-time token", async () => {
    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "reset-user@example.com",
          password: "Password123!",
        }),
      }),
    );

    const requestReset = await postResetRequest(
      new Request("http://localhost:3000/api/v1/auth/password-reset/request", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.70",
        },
        body: JSON.stringify({ email: "reset-user@example.com" }),
      }),
    );

    expect(requestReset.status).toBe(202);
    const requestBody = await requestReset.json();
    expect(requestBody.accepted).toBe(true);
    expect(requestBody.reset_token).toBeTruthy();

    const oldPasswordLogin = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ email: "reset-user@example.com", password: "Password123!" }),
      }),
    );
    expect(oldPasswordLogin.status).toBe(200);

    const confirm = await postResetConfirm(
      new Request("http://localhost:3000/api/v1/auth/password-reset/confirm", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          token: requestBody.reset_token,
          password: "NewPassword123!",
        }),
      }),
    );

    expect(confirm.status).toBe(200);

    const oldLoginAfterReset = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ email: "reset-user@example.com", password: "Password123!" }),
      }),
    );
    expect(oldLoginAfterReset.status).toBe(401);

    const newLoginAfterReset = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ email: "reset-user@example.com", password: "NewPassword123!" }),
      }),
    );
    expect(newLoginAfterReset.status).toBe(200);

    const reuse = await postResetConfirm(
      new Request("http://localhost:3000/api/v1/auth/password-reset/confirm", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          token: requestBody.reset_token,
          password: "AnotherPassword123!",
        }),
      }),
    );
    expect(reuse.status).toBe(409);
  });

  it("rejects expired password reset token", async () => {
    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "expired-reset@example.com",
          password: "Password123!",
        }),
      }),
    );

    const requestReset = await postResetRequest(
      new Request("http://localhost:3000/api/v1/auth/password-reset/request", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.71",
        },
        body: JSON.stringify({ email: "expired-reset@example.com" }),
      }),
    );
    const requestBody = await requestReset.json();

    const userId = userIdByEmail(fixture.dbPath, "expired-reset@example.com");
    const db = new Database(fixture.dbPath);
    db.prepare(
      "UPDATE api_password_resets SET expires_at = ?, used_at = NULL WHERE user_id = ?",
    ).run("2000-01-01T00:00:00.000Z", userId);
    db.close();

    const confirmExpired = await postResetConfirm(
      new Request("http://localhost:3000/api/v1/auth/password-reset/confirm", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          token: requestBody.reset_token,
          password: "NewPassword123!",
        }),
      }),
    );

    expect(confirmExpired.status).toBe(412);
  });

  it("accepts unknown email requests without leaking account existence", async () => {
    const response = await postResetRequest(
      new Request("http://localhost:3000/api/v1/auth/password-reset/request", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "198.51.100.72",
        },
        body: JSON.stringify({ email: "unknown@example.com" }),
      }),
    );

    expect(response.status).toBe(202);
    const body = await response.json();
    expect(body.accepted).toBe(true);
  });

  it("rate limits reset requests", async () => {
    let response: Response | null = null;

    for (let index = 0; index < 6; index += 1) {
      response = await postResetRequest(
        new Request("http://localhost:3000/api/v1/auth/password-reset/request", {
          method: "POST",
          headers: {
            "content-type": "application/json",
            origin: "http://localhost:3000",
            "x-forwarded-for": "198.51.100.73",
          },
          body: JSON.stringify({ email: "rate-reset@example.com" }),
        }),
      );
    }

    expect(response?.status).toBe(429);
    expect(response?.headers.get("retry-after")).toBeTruthy();
  });
});


===== FILE: src/app/__tests__/e2e-public-events-hal.test.ts =====
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import { GET as getEvents } from "../api/v1/events/route";
import { GET as getEventBySlug } from "../api/v1/events/[slug]/route";
import { POST as postPublish } from "../api/v1/events/[slug]/publish/route";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

describe("e2e public events + hal", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    await cleanupStandardE2EFixtures();
  });

  it("renders public events list and detail resources", async () => {
    const listResponse = await getEvents(new Request("http://localhost:3000/api/v1/events"));
    expect(listResponse.status).toBe(200);
    expect(listResponse.headers.get("content-type")).toContain("application/hal+json");

    const listBody = await listResponse.json();
    expect(listBody.count).toBeGreaterThanOrEqual(4);

    const detailResponse = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/published-open"),
      { params: Promise.resolve({ slug: "published-open" }) },
    );

    expect(detailResponse.status).toBe(200);
    const detailBody = await detailResponse.json();
    expect(detailBody.slug).toBe("published-open");
    expect(detailBody.status).toBe("PUBLISHED");
  });

  it("returns consistent problem details for missing public event", async () => {
    const response = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/bad-slug"),
      { params: Promise.resolve({ slug: "bad-slug" }) },
    );

    expect(response.status).toBe(404);
    expect(response.headers.get("content-type")).toContain("application/problem+json");

    const body = await response.json();
    expect(body.title).toBe("Not Found");
    expect(body.status).toBe(404);
    expect(body.request_id).toBeTruthy();
  });

  it("shows state-driven HAL affordances by event status", async () => {
    const draft = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/draft-event"),
      { params: Promise.resolve({ slug: "draft-event" }) },
    );
    const draftBody = await draft.json();
    expect(draftBody.status).toBe("DRAFT");
    expect(draftBody._links["app:publish"]?.href).toBe("/api/v1/events/draft-event/publish");
    expect(draftBody._links["app:cancel"]).toBeFalsy();

    const published = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/published-open"),
      { params: Promise.resolve({ slug: "published-open" }) },
    );
    const publishedBody = await published.json();
    expect(publishedBody.status).toBe("PUBLISHED");
    expect(publishedBody._links["app:publish"]).toBeFalsy();
    expect(publishedBody._links["app:cancel"]?.href).toBe("/api/v1/events/published-open/cancel");

    const cancelled = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/cancelled-event"),
      { params: Promise.resolve({ slug: "cancelled-event" }) },
    );
    const cancelledBody = await cancelled.json();
    expect(cancelledBody.status).toBe("CANCELLED");
    expect(cancelledBody._links["app:publish"]).toBeFalsy();
    expect(cancelledBody._links["app:cancel"]).toBeFalsy();
  });

  it("executes publish via HAL href and removes publish affordance after transition", async () => {
    const draftResponse = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/draft-event"),
      { params: Promise.resolve({ slug: "draft-event" }) },
    );
    const draftBody = await draftResponse.json();
    const publishHref = draftBody._links["app:publish"]?.href as string;

    expect(publishHref).toBe("/api/v1/events/draft-event/publish");

    const publishSlug = publishHref.split("/").at(-2) as string;
    const publishResponse = await postPublish(
      new Request(`http://localhost:3000${publishHref}`, {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: publishSlug }) },
    );

    expect(publishResponse.status).toBe(200);

    const postPublishView = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/draft-event"),
      { params: Promise.resolve({ slug: "draft-event" }) },
    );
    const postPublishBody = await postPublishView.json();
    expect(postPublishBody.status).toBe("PUBLISHED");
    expect(postPublishBody._links["app:publish"]).toBeFalsy();
    expect(postPublishBody._links["app:cancel"]).toBeTruthy();
  });

  it("handles stale publish action gracefully and keeps HAL state authoritative", async () => {
    const draftResponse = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/draft-event"),
      { params: Promise.resolve({ slug: "draft-event" }) },
    );
    const draftBody = await draftResponse.json();
    const stalePublishHref = draftBody._links["app:publish"]?.href as string;

    await postPublish(
      new Request(`http://localhost:3000${stalePublishHref}`, {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "draft-event" }) },
    );

    const stalePublishAttempt = await postPublish(
      new Request(`http://localhost:3000${stalePublishHref}`, {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "draft-event" }) },
    );

    expect(stalePublishAttempt.status).toBe(200);

    const refreshed = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/draft-event"),
      { params: Promise.resolve({ slug: "draft-event" }) },
    );
    const refreshedBody = await refreshed.json();

    expect(refreshedBody.status).toBe("PUBLISHED");
    expect(refreshedBody._links["app:publish"]).toBeFalsy();
    expect(refreshedBody._links["app:cancel"]).toBeTruthy();
  });
});


===== FILE: src/app/__tests__/e2e-release-journeys-regression.test.ts =====
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";

import { POST as postLogin } from "../api/v1/auth/login/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import { POST as postEvents } from "../api/v1/events/route";
import { POST as postPublish } from "../api/v1/events/[slug]/publish/route";
import { POST as postRegistration } from "../api/v1/events/[slug]/registrations/route";
import { DELETE as deleteRegistration } from "../api/v1/events/[slug]/registrations/[userId]/route";
import { POST as postCheckin } from "../api/v1/events/[slug]/checkins/route";
import { GET as getExport } from "../api/v1/events/[slug]/export/route";
import { GET as getMe } from "../api/v1/me/route";
import { GET as getUsers } from "../api/v1/users/route";
import { DELETE as deleteRole } from "../api/v1/users/[id]/roles/[role]/route";
import { requestHal } from "../../lib/hal-client";
import {
  cleanupStandardE2EFixtures,
  setupStandardE2EFixture,
  type StandardE2EFixture,
} from "./helpers/e2e-fixtures";

let fixture: StandardE2EFixture;

describe("e2e release journeys regression", () => {
  beforeEach(async () => {
    fixture = await setupStandardE2EFixture();
    process.env.APPCTL_ENV = "local";
  });

  afterEach(async () => {
    vi.restoreAllMocks();
    await cleanupStandardE2EFixtures();
  });

  it("passes the public journey browse-register-waitlist-cancel", async () => {
    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "release-public@example.com",
          password: "Password123!",
        }),
      }),
    );

    const login = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "release-public@example.com",
          password: "Password123!",
        }),
      }),
    );

    const cookie = (login.headers.get("set-cookie") ?? "").split(";")[0];

    const me = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        headers: { cookie },
      }),
    );
    const meBody = await me.json();

    const registerOpen = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/published-open/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie,
        },
        body: JSON.stringify({ user_id: meBody.id }),
      }),
      { params: Promise.resolve({ slug: "published-open" }) },
    );
    expect(registerOpen.status).toBe(200);
    expect((await registerOpen.json()).status).toBe("REGISTERED");

    const waitlist = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/published-full/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie,
        },
        body: JSON.stringify({ user_id: meBody.id }),
      }),
      { params: Promise.resolve({ slug: "published-full" }) },
    );
    expect(waitlist.status).toBe(200);
    expect((await waitlist.json()).status).toBe("WAITLISTED");

    const cancel = await deleteRegistration(
      new Request(`http://localhost:3000/api/v1/events/published-open/registrations/${meBody.id}`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie,
        },
      }),
      { params: Promise.resolve({ slug: "published-open", userId: meBody.id }) },
    );

    expect(cancel.status).toBe(200);
    expect((await cancel.json()).status).toBe("CANCELLED");
  });

  it("passes the admin journey create-publish-register-checkin-export", async () => {
    const create = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({
          slug: "release-admin-journey",
          title: "Release Admin Journey",
          start: "2026-12-01T10:00:00.000Z",
          end: "2026-12-01T11:00:00.000Z",
          timezone: "UTC",
          capacity: 10,
        }),
      }),
    );
    expect(create.status).toBe(201);

    const publish = await postPublish(
      new Request("http://localhost:3000/api/v1/events/release-admin-journey/publish", {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "release-admin-journey" }) },
    );
    expect(publish.status).toBe(200);

    const addRegistration = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/release-admin-journey/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ user_id: fixture.userId }),
      }),
      { params: Promise.resolve({ slug: "release-admin-journey" }) },
    );
    expect(addRegistration.status).toBe(200);

    const checkin = await postCheckin(
      new Request("http://localhost:3000/api/v1/events/release-admin-journey/checkins", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
        body: JSON.stringify({ user_id: fixture.userId }),
      }),
      { params: Promise.resolve({ slug: "release-admin-journey" }) },
    );
    expect(checkin.status).toBe(200);

    const exported = await getExport(
      new Request("http://localhost:3000/api/v1/events/release-admin-journey/export?format=json", {
        headers: { cookie: fixture.adminCookie },
      }),
      { params: Promise.resolve({ slug: "release-admin-journey" }) },
    );

    expect(exported.status).toBe(200);
    expect(exported.headers.get("content-type")).toContain("application/json");
  });

  it("keeps request_id supportability in surfaced API errors", async () => {
    vi.spyOn(globalThis, "fetch").mockResolvedValue(
      new Response(
        JSON.stringify({
          type: "about:blank",
          title: "Internal Server Error",
          status: 500,
          detail: "Injected failure",
          request_id: "req-release-journey-1",
        }),
        {
          status: 500,
          headers: {
            "content-type": "application/problem+json",
          },
        },
      ),
    );

    const failed = await requestHal<{ ok: true }>("/api/v1/events");
    expect(failed.ok).toBe(false);
    if (!failed.ok) {
      expect(failed.problem.request_id).toBe("req-release-journey-1");
      expect(failed.problem.status).toBe(500);
    }
  });

  it("removes admin access immediately after role downgrade mid-session", async () => {
    const meBefore = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        headers: { cookie: fixture.adminCookie },
      }),
    );
    expect(meBefore.status).toBe(200);
    const meBeforeBody = await meBefore.json();
    expect(meBeforeBody._links.users.href).toBe("/api/v1/users");

    const roleRemoval = await deleteRole(
      new Request(`http://localhost:3000/api/v1/users/${fixture.adminId}/roles/ADMIN`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: fixture.adminCookie,
        },
      }),
      { params: Promise.resolve({ id: fixture.adminId, role: "ADMIN" }) },
    );
    expect(roleRemoval.status).toBe(200);

    const meAfter = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        headers: { cookie: fixture.adminCookie },
      }),
    );
    expect(meAfter.status).toBe(200);
    const meAfterBody = await meAfter.json();
    expect(meAfterBody._links.users).toBeUndefined();

    const usersAfter = await getUsers(
      new Request("http://localhost:3000/api/v1/users", {
        headers: { cookie: fixture.adminCookie },
      }),
    );
    expect(usersAfter.status).toBe(403);
  });
});


===== FILE: src/app/__tests__/e2e-ui-hardening.test.ts =====
import { readFile } from "node:fs/promises";
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it, vi } from "vitest";

import { GET as getEvents, POST as postEvents } from "../api/v1/events/route";
import { POST as postPublishEvent } from "../api/v1/events/[slug]/publish/route";
import { POST as postRegistration } from "../api/v1/events/[slug]/registrations/route";
import { DELETE as deleteRegistration } from "../api/v1/events/[slug]/registrations/[userId]/route";
import { POST as postCheckin } from "../api/v1/events/[slug]/checkins/route";
import { GET as getExport } from "../api/v1/events/[slug]/export/route";
import { GET as getMe } from "../api/v1/me/route";
import { POST as postAddRole } from "../api/v1/users/[id]/roles/route";
import { POST as postLogin } from "../api/v1/auth/login/route";
import { POST as postLogout } from "../api/v1/auth/logout/route";
import { POST as postRegister } from "../api/v1/auth/register/route";
import { runCli } from "../../cli/run-cli";
import { type CliIo } from "../../cli/types";
import { requestHal } from "../../lib/hal-client";
import { resetRateLimits } from "../../lib/api/rate-limit";

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-ui-hardening-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const runWithDb = async (argv: string[], dbPath: string): Promise<number> => {
  const { io } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return exitCode;
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

const registerAndLogin = async (email: string): Promise<string> => {
  await postRegister(
    new Request("http://localhost:3000/api/v1/auth/register", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  const login = await postLogin(
    new Request("http://localhost:3000/api/v1/auth/login", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  return (login.headers.get("set-cookie") ?? "").split(";")[0];
};

const withDb = (dbPath: string) => new Database(dbPath);

const userIdByEmail = (dbPath: string, email: string) => {
  const db = withDb(dbPath);
  const row = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  db.close();
  return row.id;
};

const addAdminRole = (dbPath: string, email: string) => {
  const db = withDb(dbPath);
  const user = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  const role = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
  db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(user.id, role.id);
  db.close();
};

afterEach(async () => {
  delete process.env.APPCTL_DB_FILE;
  delete process.env.APPCTL_ENV;
  vi.restoreAllMocks();
  resetRateLimits();
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("e2e ui hardening release gate", () => {
  it("passes critical auth, public events, registration, waitlist, cancel, admin check-in, and export flows", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("gate-admin@example.com");
    const userOneCookie = await registerAndLogin("gate-user-1@example.com");
    const userTwoCookie = await registerAndLogin("gate-user-2@example.com");

    addAdminRole(dbPath, "gate-admin@example.com");
    const adminId = userIdByEmail(dbPath, "gate-admin@example.com");
    const userOneId = userIdByEmail(dbPath, "gate-user-1@example.com");
    const userTwoId = userIdByEmail(dbPath, "gate-user-2@example.com");

    const meResponse = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        method: "GET",
        headers: {
          cookie: adminCookie,
        },
      }),
    );
    expect(meResponse.status).toBe(200);

    const logoutResponse = await postLogout(
      new Request("http://localhost:3000/api/v1/auth/logout", {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: userOneCookie,
        },
      }),
    );
    expect(logoutResponse.status).toBe(200);

    const reloginUserOne = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ email: "gate-user-1@example.com", password: "Password123!" }),
      }),
    );
    const reloginUserOneCookie = (reloginUserOne.headers.get("set-cookie") ?? "").split(";")[0];

    const createAdminEvent = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({
          slug: "admin-gate-event",
          title: "Admin Gate Event",
          start: "2026-08-01T10:00:00.000Z",
          end: "2026-08-01T11:00:00.000Z",
          timezone: "UTC",
          capacity: 5,
        }),
      }),
    );
    expect(createAdminEvent.status).toBe(201);

    const publishAdminEvent = await postPublishEvent(
      new Request("http://localhost:3000/api/v1/events/admin-gate-event/publish", {
        method: "POST",
        headers: {
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
      }),
      { params: Promise.resolve({ slug: "admin-gate-event" }) },
    );
    expect(publishAdminEvent.status).toBe(200);

    const publicEvents = await getEvents(new Request("http://localhost:3000/api/v1/events"));
    expect(publicEvents.status).toBe(200);
    const publicBody = await publicEvents.json();
    expect(publicBody.items.some((item: { slug: string }) => item.slug === "admin-gate-event")).toBe(true);

    const registerPublished = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/admin-gate-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: reloginUserOneCookie,
        },
        body: JSON.stringify({ user_id: userOneId }),
      }),
      { params: Promise.resolve({ slug: "admin-gate-event" }) },
    );
    expect(registerPublished.status).toBe(200);
    expect((await registerPublished.json()).status).toBe("REGISTERED");

    const checkinPublished = await postCheckin(
      new Request("http://localhost:3000/api/v1/events/admin-gate-event/checkins", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ user_id: userOneId }),
      }),
      { params: Promise.resolve({ slug: "admin-gate-event" }) },
    );
    expect(checkinPublished.status).toBe(200);

    const exportPublished = await getExport(
      new Request("http://localhost:3000/api/v1/events/admin-gate-event/export?format=json", {
        headers: {
          cookie: adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "admin-gate-event" }) },
    );
    expect(exportPublished.status).toBe(200);

    const createWaitlistEvent = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({
          slug: "waitlist-gate-event",
          title: "Waitlist Gate Event",
          start: "2026-08-02T10:00:00.000Z",
          end: "2026-08-02T11:00:00.000Z",
          timezone: "UTC",
          capacity: 1,
        }),
      }),
    );
    expect(createWaitlistEvent.status).toBe(201);

    const publishWaitlistEvent = await postPublishEvent(
      new Request("http://localhost:3000/api/v1/events/waitlist-gate-event/publish", {
        method: "POST",
        headers: {
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
      }),
      { params: Promise.resolve({ slug: "waitlist-gate-event" }) },
    );
    expect(publishWaitlistEvent.status).toBe(200);

    const userOneWaitlist = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/waitlist-gate-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: reloginUserOneCookie,
        },
        body: JSON.stringify({ user_id: userOneId }),
      }),
      { params: Promise.resolve({ slug: "waitlist-gate-event" }) },
    );
    expect((await userOneWaitlist.json()).status).toBe("REGISTERED");

    const userTwoWaitlist = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/waitlist-gate-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: userTwoCookie,
        },
        body: JSON.stringify({ user_id: userTwoId }),
      }),
      { params: Promise.resolve({ slug: "waitlist-gate-event" }) },
    );
    expect((await userTwoWaitlist.json()).status).toBe("WAITLISTED");

    const cancelUserOne = await deleteRegistration(
      new Request(`http://localhost:3000/api/v1/events/waitlist-gate-event/registrations/${userOneId}`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: reloginUserOneCookie,
        },
      }),
      { params: Promise.resolve({ slug: "waitlist-gate-event", userId: userOneId }) },
    );
    expect((await cancelUserOne.json()).status).toBe("CANCELLED");

    expect(adminId).toBeTruthy();
  });

  it("keeps accessibility and problem-details request_id behavior consistent and blocks super admin UI mutation", async () => {
    vi.spyOn(globalThis, "fetch").mockResolvedValue(
      new Response(
        JSON.stringify({
          type: "about:blank",
          title: "Forbidden",
          status: 403,
          detail: "Denied",
          request_id: "req-ui-hardening-1",
        }),
        {
          status: 403,
          headers: {
            "content-type": "application/problem+json",
          },
        },
      ),
    );

    const failed = await requestHal<{ ok: true }>("/api/v1/denied");
    expect(failed.ok).toBe(false);
    if (!failed.ok) {
      expect(failed.problem.request_id).toBe("req-ui-hardening-1");
    }

    const loginSource = await readFile(join(process.cwd(), "src/app/login/page.tsx"), "utf8");
    const registerSource = await readFile(join(process.cwd(), "src/app/register/page.tsx"), "utf8");
    const adminUsersSource = await readFile(join(process.cwd(), "src/app/admin/users/page.tsx"), "utf8");

    expect(loginSource.includes("<label htmlFor=")).toBe(true);
    expect(registerSource.includes("<label htmlFor=")).toBe(true);
    expect(adminUsersSource.includes("ProblemDetailsPanel")).toBe(true);
    expect(adminUsersSource.includes("Add SUPER_ADMIN")).toBe(false);
    expect(adminUsersSource.includes("Remove SUPER_ADMIN")).toBe(false);
  });

  it("enforces super-admin role mutation as API-forbidden", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("role-admin@example.com");
    const targetCookie = await registerAndLogin("role-target@example.com");

    addAdminRole(dbPath, "role-admin@example.com");
    const targetId = userIdByEmail(dbPath, "role-target@example.com");

    const blocked = await postAddRole(
      new Request(`http://localhost:3000/api/v1/users/${targetId}/roles`, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ role: "SUPER_ADMIN" }),
      }),
      { params: Promise.resolve({ id: targetId }) },
    );

    expect(blocked.status).toBe(403);
    expect(targetCookie).toContain("lms_session=");
  });
});


===== FILE: src/app/__tests__/helpers/e2e-fixtures.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";

import { POST as postLogin } from "../../api/v1/auth/login/route";
import { POST as postRegister } from "../../api/v1/auth/register/route";
import { POST as postEvent } from "../../api/v1/events/route";
import { POST as postPublish } from "../../api/v1/events/[slug]/publish/route";
import { POST as postCancel } from "../../api/v1/events/[slug]/cancel/route";
import { POST as postRegistration } from "../../api/v1/events/[slug]/registrations/route";
import { runCli } from "../../../cli/run-cli";
import type { CliIo } from "../../../cli/types";
import { resetRateLimits } from "../../../lib/api/rate-limit";

const tempDirs: string[] = [];

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const runWithDb = async (argv: string[], dbPath: string): Promise<number> => {
  const { io } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return exitCode;
};

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-e2e-fixture-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const login = async (email: string): Promise<string> => {
  const response = await postLogin(
    new Request("http://localhost:3000/api/v1/auth/login", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  return (response.headers.get("set-cookie") ?? "").split(";")[0];
};

const registerUser = async (email: string) => {
  const response = await postRegister(
    new Request("http://localhost:3000/api/v1/auth/register", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  if (response.status !== 201) {
    throw new Error(`failed_register_${email}`);
  }
};

const addAdminRole = (dbPath: string, email: string) => {
  const db = new Database(dbPath);
  const user = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  const role = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
  db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(user.id, role.id);
  db.close();
};

const userIdByEmail = (dbPath: string, email: string) => {
  const db = new Database(dbPath);
  const user = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  db.close();
  return user.id;
};

const createEvent = async (
  adminCookie: string,
  payload: {
    slug: string;
    title: string;
    start: string;
    end: string;
    timezone: string;
    capacity: number;
  },
) => {
  const response = await postEvent(
    new Request("http://localhost:3000/api/v1/events", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
        cookie: adminCookie,
      },
      body: JSON.stringify(payload),
    }),
  );

  if (response.status !== 201) {
    throw new Error(`failed_event_create_${payload.slug}`);
  }
};

const publishEvent = async (adminCookie: string, slug: string) => {
  const response = await postPublish(
    new Request(`http://localhost:3000/api/v1/events/${slug}/publish`, {
      method: "POST",
      headers: {
        origin: "http://localhost:3000",
        cookie: adminCookie,
      },
    }),
    { params: Promise.resolve({ slug }) },
  );

  if (response.status !== 200) {
    throw new Error(`failed_event_publish_${slug}`);
  }
};

const cancelEvent = async (adminCookie: string, slug: string, reason: string) => {
  const response = await postCancel(
    new Request(`http://localhost:3000/api/v1/events/${slug}/cancel`, {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
        cookie: adminCookie,
      },
      body: JSON.stringify({ reason }),
    }),
    { params: Promise.resolve({ slug }) },
  );

  if (response.status !== 200) {
    throw new Error(`failed_event_cancel_${slug}`);
  }
};

const registerForEvent = async (cookie: string, slug: string, userId: string) => {
  const response = await postRegistration(
    new Request(`http://localhost:3000/api/v1/events/${slug}/registrations`, {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
        cookie,
      },
      body: JSON.stringify({ user_id: userId }),
    }),
    { params: Promise.resolve({ slug }) },
  );

  if (response.status !== 200) {
    throw new Error(`failed_event_registration_${slug}`);
  }
};

export type StandardE2EFixture = {
  dbPath: string;
  adminCookie: string;
  userCookie: string;
  adminId: string;
  userId: string;
};

export const setupStandardE2EFixture = async (): Promise<StandardE2EFixture> => {
  const dbPath = await createDbPath();

  process.env.APPCTL_DB_FILE = dbPath;
  process.env.APPCTL_ENV = "local";

  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
  process.env.APPCTL_DB_FILE = dbPath;

  await registerUser("usera@example.com");
  await registerUser("admina@example.com");

  addAdminRole(dbPath, "admina@example.com");

  const userCookie = await login("usera@example.com");
  const adminCookie = await login("admina@example.com");

  await createEvent(adminCookie, {
    slug: "published-open",
    title: "Published Open",
    start: "2026-09-01T10:00:00.000Z",
    end: "2026-09-01T11:00:00.000Z",
    timezone: "UTC",
    capacity: 20,
  });

  await createEvent(adminCookie, {
    slug: "published-full",
    title: "Published Full",
    start: "2026-09-02T10:00:00.000Z",
    end: "2026-09-02T11:00:00.000Z",
    timezone: "UTC",
    capacity: 1,
  });

  await createEvent(adminCookie, {
    slug: "draft-event",
    title: "Draft Event",
    start: "2026-09-03T10:00:00.000Z",
    end: "2026-09-03T11:00:00.000Z",
    timezone: "UTC",
    capacity: 50,
  });

  await createEvent(adminCookie, {
    slug: "cancelled-event",
    title: "Cancelled Event",
    start: "2026-09-04T10:00:00.000Z",
    end: "2026-09-04T11:00:00.000Z",
    timezone: "UTC",
    capacity: 50,
  });

  await publishEvent(adminCookie, "published-open");
  await publishEvent(adminCookie, "published-full");
  await publishEvent(adminCookie, "cancelled-event");
  await cancelEvent(adminCookie, "cancelled-event", "Fixture cancellation");

  const userId = userIdByEmail(dbPath, "usera@example.com");
  const adminId = userIdByEmail(dbPath, "admina@example.com");

  await registerForEvent(userCookie, "published-open", userId);
  await registerForEvent(userCookie, "published-full", userId);

  return {
    dbPath,
    adminCookie,
    userCookie,
    adminId,
    userId,
  };
};

export const cleanupStandardE2EFixtures = async () => {
  delete process.env.APPCTL_DB_FILE;
  delete process.env.APPCTL_ENV;
  resetRateLimits();
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
};


===== FILE: src/app/account/page.tsx =====
"use client";

import Link from "next/link";
import { useEffect, useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { requestHal, type ProblemDetails } from "@/lib/hal-client";

type MeResponse = {
  id: string;
  email: string;
  status: string;
  roles: string[];
  _links: Record<string, { href: string }>;
};

type AccountRegistration = {
  registration_id: string;
  event_id: string;
  event_slug: string;
  event_title: string;
  status: string;
};

type AccountRegistrationsResponse = {
  count: number;
  items: AccountRegistration[];
};

export default function AccountPage() {
  const [me, setMe] = useState<MeResponse | null>(null);
  const [registrations, setRegistrations] = useState<AccountRegistration[]>([]);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);
  const [loading, setLoading] = useState(true);
  const [deleting, setDeleting] = useState(false);

  useEffect(() => {
    const load = async () => {
      setLoading(true);
      setProblem(null);

      const result = await requestHal<MeResponse>("/api/v1/me");
      if (!result.ok) {
        setProblem(result.problem);
        setLoading(false);
        return;
      }

      setMe(result.data);

      const history = await requestHal<AccountRegistrationsResponse>("/api/v1/account/registrations");
      if (history.ok) {
        setRegistrations(history.data.items ?? []);
      }

      setLoading(false);
    };

    void load();
  }, []);

  return (
    <main className="mx-auto max-w-2xl p-6">
      <h1 className="text-2xl font-semibold">Account</h1>
      {loading ? <p className="mt-2 text-sm">Loading account...</p> : null}

      {problem ? (
        <div className="mt-4 space-y-3">
          <ProblemDetailsPanel problem={problem} />
          {problem.status === 401 ? (
            <p className="text-sm">
              You are not logged in. <Link href="/login" className="underline">Go to login</Link>
            </p>
          ) : null}
        </div>
      ) : null}

      {me ? (
        <section className="mt-4 rounded border p-4">
          <p className="text-sm"><span className="font-medium">Email:</span> {me.email}</p>
          <p className="mt-1 text-sm"><span className="font-medium">Status:</span> {me.status}</p>
          <p className="mt-1 text-sm"><span className="font-medium">Roles:</span> {me.roles.join(", ")}</p>

          <div className="mt-3 text-sm">
            {me._links.events ? <Link href="/events" className="underline">Browse events</Link> : null}
          </div>
          <div className="mt-2 text-xs">
            <Link href="/terms" className="underline">Terms</Link> · <Link href="/privacy" className="underline">Privacy</Link>
          </div>

          <div className="mt-5">
            <h2 className="text-sm font-medium">My registrations ({registrations.length})</h2>
            <ul className="mt-2 space-y-2">
              {registrations.map((registration) => (
                <li key={registration.registration_id} className="rounded border p-2 text-sm">
                  <p className="font-medium">{registration.event_title}</p>
                  <p className="text-xs text-zinc-500">{registration.event_slug}</p>
                  <p className="text-xs">Status: {registration.status}</p>
                </li>
              ))}
              {registrations.length === 0 ? (
                <li className="text-xs text-zinc-500">No registrations yet.</li>
              ) : null}
            </ul>
          </div>

          <div className="mt-5 border-t pt-4">
            <button
              type="button"
              disabled={deleting}
              onClick={async () => {
                setDeleting(true);
                const result = await requestHal<{ deleted: true }>("/api/v1/account/delete", {
                  method: "POST",
                });
                if (!result.ok) {
                  setProblem(result.problem);
                  setDeleting(false);
                  return;
                }
                setDeleting(false);
                setMe(null);
                setRegistrations([]);
              }}
              className="rounded border px-3 py-2 text-sm"
            >
              {deleting ? "Deleting account..." : "Delete account"}
            </button>
          </div>
        </section>
      ) : null}
    </main>
  );
}


===== FILE: src/app/admin/audit/page.tsx =====
"use client";

import { useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { requestHal, type ProblemDetails } from "@/lib/hal-client";

type AuditItem = {
  id: string;
  action: string;
  actor_id: string | null;
  created_at: string;
  metadata: Record<string, unknown> | null;
  request_id: string;
};

type AuditResponse = {
  count: number;
  items: AuditItem[];
};

export default function AdminAuditPage() {
  const [action, setAction] = useState("");
  const [actorId, setActorId] = useState("");
  const [from, setFrom] = useState("");
  const [to, setTo] = useState("");
  const [items, setItems] = useState<AuditItem[]>([]);
  const [pending, setPending] = useState(false);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  const load = async () => {
    setPending(true);
    const params = new URLSearchParams({ limit: "50", offset: "0" });
    if (action.trim().length > 0) {
      params.set("action", action.trim());
    }
    if (actorId.trim().length > 0) {
      params.set("actor_id", actorId.trim());
    }
    if (from.trim().length > 0) {
      params.set("from", from.trim());
    }
    if (to.trim().length > 0) {
      params.set("to", to.trim());
    }

    const result = await requestHal<AuditResponse>(`/api/v1/audit?${params.toString()}`);
    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    setProblem(null);
    setItems(result.data.items ?? []);
    setPending(false);
  };

  return (
    <main className="mx-auto max-w-6xl p-6">
      <h1 className="text-2xl font-semibold">Admin Audit Log</h1>

      <section className="mt-4 rounded border p-4">
        <h2 className="text-sm font-medium">Filters</h2>
        <div className="mt-3 grid gap-2 md:grid-cols-2 lg:grid-cols-4">
          <input
            value={action}
            onChange={(event) => setAction(event.target.value)}
            placeholder="Action"
            className="rounded border px-3 py-2 text-sm"
          />
          <input
            value={actorId}
            onChange={(event) => setActorId(event.target.value)}
            placeholder="Actor ID"
            className="rounded border px-3 py-2 text-sm"
          />
          <input
            value={from}
            onChange={(event) => setFrom(event.target.value)}
            placeholder="From (ISO)"
            className="rounded border px-3 py-2 text-sm"
          />
          <input
            value={to}
            onChange={(event) => setTo(event.target.value)}
            placeholder="To (ISO)"
            className="rounded border px-3 py-2 text-sm"
          />
        </div>
        <button
          type="button"
          onClick={() => void load()}
          disabled={pending}
          className="mt-3 rounded border px-3 py-2 text-sm"
        >
          {pending ? "Loading..." : "Load audit entries"}
        </button>
      </section>

      {problem ? (
        <div className="mt-4">
          <ProblemDetailsPanel problem={problem} />
        </div>
      ) : null}

      <section className="mt-4 rounded border p-4">
        <h2 className="text-sm font-medium">Entries ({items.length})</h2>
        <div className="mt-3 overflow-x-auto">
          <table className="w-full text-left text-sm">
            <thead>
              <tr>
                <th className="pb-2">When</th>
                <th className="pb-2">Action</th>
                <th className="pb-2">Actor</th>
                <th className="pb-2">Metadata</th>
              </tr>
            </thead>
            <tbody>
              {items.map((item) => (
                <tr key={item.id} className="border-t align-top">
                  <td className="py-2">{item.created_at}</td>
                  <td className="py-2">{item.action}</td>
                  <td className="py-2">{item.actor_id ?? "-"}</td>
                  <td className="py-2">
                    <pre className="whitespace-pre-wrap break-all text-xs">
                      {JSON.stringify(item.metadata ?? {}, null, 2)}
                    </pre>
                  </td>
                </tr>
              ))}
              {items.length === 0 ? (
                <tr>
                  <td colSpan={4} className="py-3 text-sm text-zinc-500">
                    No audit entries loaded.
                  </td>
                </tr>
              ) : null}
            </tbody>
          </table>
        </div>
      </section>
    </main>
  );
}


===== FILE: src/app/admin/events/[slug]/export/page.tsx =====
"use client";

import { useParams } from "next/navigation";
import { useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { buildExportFileName } from "@/lib/admin-registration-view";
import type { ProblemDetails } from "@/lib/hal-client";

const parseProblem = async (response: Response): Promise<ProblemDetails> => {
  try {
    return (await response.json()) as ProblemDetails;
  } catch {
    return {
      type: "about:blank",
      title: "Request Failed",
      status: response.status,
      detail: "Failed to parse problem details response.",
    };
  }
};

export default function AdminEventExportPage() {
  const params = useParams<{ slug: string }>();
  const slug = params.slug;

  const [format, setFormat] = useState<"json" | "csv">("json");
  const [includeEmail, setIncludeEmail] = useState(false);
  const [pending, setPending] = useState(false);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);
  const [lastDownload, setLastDownload] = useState<string | null>(null);

  const onExport = async () => {
    if (!slug) {
      return;
    }

    setPending(true);
    setProblem(null);

    const query = new URLSearchParams({
      format,
      include_email: includeEmail ? "true" : "false",
    }).toString();

    const response = await fetch(`/api/v1/events/${slug}/export?${query}`, {
      credentials: "include",
      headers: {
        accept: "application/json, text/csv, application/problem+json",
      },
    });

    if (!response.ok) {
      setProblem(await parseProblem(response));
      setPending(false);
      return;
    }

    const fileName = buildExportFileName(slug, format);
    const blob = await response.blob();
    const url = URL.createObjectURL(blob);

    const anchor = document.createElement("a");
    anchor.href = url;
    anchor.download = fileName;
    anchor.click();
    URL.revokeObjectURL(url);

    setLastDownload(fileName);
    setPending(false);
  };

  return (
    <main className="mx-auto max-w-3xl p-6">
      <h1 className="text-2xl font-semibold">Event Export</h1>
      <p className="mt-1 text-sm">Event slug: {slug}</p>

      <section className="mt-4 rounded-md border p-4">
        <h2 className="text-sm font-medium">Export options</h2>

        <div className="mt-3 space-y-3">
          <label className="block text-sm">
            Format
            <select
              value={format}
              onChange={(event) => setFormat(event.target.value as "json" | "csv")}
              className="mt-1 w-full rounded border px-3 py-2"
            >
              <option value="json">JSON</option>
              <option value="csv">CSV</option>
            </select>
          </label>

          <label className="flex items-center gap-2 text-sm">
            <input
              type="checkbox"
              checked={includeEmail}
              onChange={(event) => setIncludeEmail(event.target.checked)}
            />
            Include email (subject to environment governance)
          </label>

          <button
            type="button"
            onClick={() => void onExport()}
            disabled={pending}
            className="rounded border px-3 py-2 text-sm"
          >
            {pending ? "Exporting..." : "Export"}
          </button>
        </div>

        {lastDownload ? <p className="mt-3 text-sm">Downloaded: {lastDownload}</p> : null}
      </section>

      {problem ? (
        <div className="mt-4">
          <ProblemDetailsPanel problem={problem} />
        </div>
      ) : null}
    </main>
  );
}


===== FILE: src/app/admin/events/[slug]/page.tsx =====
"use client";

import Link from "next/link";
import { useParams } from "next/navigation";
import { useEffect, useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { getEventActionHrefs } from "@/lib/admin-events-view";
import { requestHal, type ProblemDetails } from "@/lib/hal-client";

type EventDetail = {
  id: string;
  slug: string;
  title: string;
  status: string;
  start_at: string;
  end_at: string;
  timezone: string;
  capacity: number | null;
  _links: Record<string, { href: string }>;
};

export default function AdminEventDetailPage() {
  const params = useParams<{ slug: string }>();
  const slug = params.slug;

  const [event, setEvent] = useState<EventDetail | null>(null);
  const [pending, setPending] = useState(false);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  const [title, setTitle] = useState("");
  const [start, setStart] = useState("");
  const [end, setEnd] = useState("");
  const [capacity, setCapacity] = useState("");

  const load = async () => {
    if (!slug) {
      return;
    }

    const result = await requestHal<EventDetail>(`/api/v1/events/${slug}`);
    if (!result.ok) {
      setProblem(result.problem);
      return;
    }

    setProblem(null);
    setEvent(result.data);
    setTitle(result.data.title);
    setStart(result.data.start_at);
    setEnd(result.data.end_at);
    setCapacity(result.data.capacity === null ? "" : String(result.data.capacity));
  };

  useEffect(() => {
    if (!slug) {
      return;
    }

    void (async () => {
      const result = await requestHal<EventDetail>(`/api/v1/events/${slug}`);
      if (!result.ok) {
        setProblem(result.problem);
        return;
      }

      setProblem(null);
      setEvent(result.data);
      setTitle(result.data.title);
      setStart(result.data.start_at);
      setEnd(result.data.end_at);
      setCapacity(result.data.capacity === null ? "" : String(result.data.capacity));
    })();
  }, [slug]);

  const onSave = async () => {
    if (!slug) {
      return;
    }

    setPending(true);
    setProblem(null);

    const result = await requestHal<unknown>(`/api/v1/events/${slug}`, {
      method: "PATCH",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify({
        title,
        start,
        end,
        capacity: capacity.trim().length ? Number(capacity) : undefined,
      }),
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    await load();
    setPending(false);
  };

  const onAction = async (href: string, body?: Record<string, unknown>) => {
    setPending(true);
    setProblem(null);

    const result = await requestHal<unknown>(href, {
      method: "POST",
      headers: {
        "content-type": "application/json",
      },
      body: body ? JSON.stringify(body) : undefined,
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    await load();
    setPending(false);
  };

  const actions = event ? getEventActionHrefs(event) : { publish: null, cancel: null };

  return (
    <main className="mx-auto max-w-5xl p-6">
      <h1 className="text-2xl font-semibold">Event Detail</h1>
      <p className="mt-1 text-sm">Event slug: {slug}</p>

      {problem ? (
        <div className="mt-4">
          <ProblemDetailsPanel problem={problem} />
        </div>
      ) : null}

      {event ? (
        <>
          <section className="mt-4 rounded-md border p-4">
            <h2 className="text-sm font-medium">Edit event</h2>
            <div className="mt-3 grid gap-2 md:grid-cols-2">
              <input value={title} onChange={(e) => setTitle(e.target.value)} className="rounded border px-3 py-2 text-sm" />
              <input value={capacity} onChange={(e) => setCapacity(e.target.value)} className="rounded border px-3 py-2 text-sm" placeholder="Capacity" />
              <input value={start} onChange={(e) => setStart(e.target.value)} className="rounded border px-3 py-2 text-sm" placeholder="Start ISO" />
              <input value={end} onChange={(e) => setEnd(e.target.value)} className="rounded border px-3 py-2 text-sm" placeholder="End ISO" />
            </div>

            <button
              type="button"
              onClick={() => void onSave()}
              disabled={pending}
              className="mt-3 rounded border px-3 py-2 text-sm"
            >
              {pending ? "Saving..." : "Save changes"}
            </button>
          </section>

          <section className="mt-4 rounded-md border p-4">
            <h2 className="text-sm font-medium">Lifecycle actions</h2>
            <div className="mt-3 flex gap-2">
              {actions.publish ? (
                <button
                  type="button"
                  className="rounded border px-3 py-2 text-sm"
                  disabled={pending}
                  onClick={() => void onAction(actions.publish!)}
                >
                  Publish
                </button>
              ) : null}

              {actions.cancel ? (
                <button
                  type="button"
                  className="rounded border px-3 py-2 text-sm"
                  disabled={pending}
                  onClick={() => void onAction(actions.cancel!, { reason: "Cancelled via admin console" })}
                >
                  Cancel
                </button>
              ) : null}

              {!actions.publish && !actions.cancel ? (
                <p className="text-sm text-zinc-500">No lifecycle actions available in current state.</p>
              ) : null}
            </div>
          </section>

          <section className="mt-4 rounded-md border p-4">
            <h2 className="text-sm font-medium">Related admin tools</h2>
            <div className="mt-2 flex gap-3 text-sm">
              <Link className="underline" href={`/admin/events/${event.slug}/registrations`}>
                Registrations
              </Link>
              <Link className="underline" href={`/admin/events/${event.slug}/export`}>
                Export
              </Link>
            </div>
          </section>
        </>
      ) : null}
    </main>
  );
}


===== FILE: src/app/admin/events/[slug]/registrations/page.tsx =====
"use client";

import { useParams } from "next/navigation";
import { useEffect, useMemo, useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import {
  buildRegistrationPayload,
  canCancel,
  canCheckIn,
  type RegistrationStatus,
} from "@/lib/admin-registration-view";
import { requestHal, type ProblemDetails } from "@/lib/hal-client";

type RegistrationItem = {
  id: string;
  user_id: string;
  user_email: string;
  status: RegistrationStatus;
};

type RegistrationsResponse = {
  count: number;
  items: RegistrationItem[];
};

export default function AdminEventRegistrationsPage() {
  const params = useParams<{ slug: string }>();
  const slug = params.slug;

  const [registrations, setRegistrations] = useState<RegistrationItem[]>([]);
  const [identifier, setIdentifier] = useState("");
  const [pending, setPending] = useState(false);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  const registrationsHref = useMemo(() => {
    if (!slug) {
      return null;
    }
    return `/api/v1/events/${slug}/registrations`;
  }, [slug]);

  const loadRegistrations = async () => {
    if (!registrationsHref) {
      return;
    }

    setProblem(null);
    const result = await requestHal<RegistrationsResponse>(registrationsHref);
    if (!result.ok) {
      setProblem(result.problem);
      return;
    }

    setRegistrations(result.data.items ?? []);
  };

  useEffect(() => {
    if (!registrationsHref) {
      return;
    }

    let cancelled = false;

    void requestHal<RegistrationsResponse>(registrationsHref).then((result) => {
      if (cancelled) {
        return;
      }

      if (!result.ok) {
        setProblem(result.problem);
        return;
      }

      setRegistrations(result.data.items ?? []);
    });

    return () => {
      cancelled = true;
    };
  }, [registrationsHref]);

  const addRegistration = async () => {
    if (!registrationsHref) {
      return;
    }

    const payload = buildRegistrationPayload(identifier);
    if (!payload.user_email && !payload.user_id) {
      return;
    }

    setPending(true);
    setProblem(null);

    const result = await requestHal<unknown>(registrationsHref, {
      method: "POST",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify(payload),
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    setIdentifier("");
    await loadRegistrations();
    setPending(false);
  };

  const cancelRegistration = async (userId: string) => {
    if (!slug) {
      return;
    }

    setPending(true);
    setProblem(null);
    const result = await requestHal<unknown>(`/api/v1/events/${slug}/registrations/${userId}`, {
      method: "DELETE",
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    await loadRegistrations();
    setPending(false);
  };

  const checkInRegistration = async (userId: string) => {
    if (!slug) {
      return;
    }

    setPending(true);
    setProblem(null);
    const result = await requestHal<unknown>(`/api/v1/events/${slug}/checkins`, {
      method: "POST",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify({ user_id: userId }),
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    await loadRegistrations();
    setPending(false);
  };

  return (
    <main className="mx-auto max-w-5xl p-6">
      <h1 className="text-2xl font-semibold">Event Registrations</h1>
      <p className="mt-1 text-sm">Event slug: {slug}</p>

      <section className="mt-4 rounded-md border p-4">
        <h2 className="text-sm font-medium">Add registration</h2>
        <div className="mt-2 flex gap-2">
          <input
            value={identifier}
            onChange={(event) => setIdentifier(event.target.value)}
            placeholder="User ID or email"
            className="w-full rounded border px-3 py-2 text-sm"
          />
          <button
            type="button"
            onClick={() => void addRegistration()}
            disabled={pending}
            className="rounded border px-3 py-2 text-sm"
          >
            {pending ? "Working..." : "Add"}
          </button>
        </div>
      </section>

      {problem ? (
        <div className="mt-4">
          <ProblemDetailsPanel problem={problem} />
        </div>
      ) : null}

      <section className="mt-4 rounded-md border p-4">
        <h2 className="text-sm font-medium">Registrations ({registrations.length})</h2>
        <div className="mt-3 overflow-x-auto">
          <table className="w-full text-left text-sm">
            <thead>
              <tr>
                <th className="pb-2">User</th>
                <th className="pb-2">Status</th>
                <th className="pb-2">Actions</th>
              </tr>
            </thead>
            <tbody>
              {registrations.map((registration) => (
                <tr key={registration.id} className="border-t">
                  <td className="py-2">
                    <p>{registration.user_email}</p>
                    <p className="text-xs text-zinc-500">{registration.user_id}</p>
                  </td>
                  <td className="py-2">{registration.status}</td>
                  <td className="py-2">
                    <div className="flex gap-2">
                      <button
                        type="button"
                        className="rounded border px-2 py-1 text-xs"
                        disabled={pending || !canCheckIn(registration.status)}
                        onClick={() => void checkInRegistration(registration.user_id)}
                      >
                        Check-in
                      </button>
                      <button
                        type="button"
                        className="rounded border px-2 py-1 text-xs"
                        disabled={pending || !canCancel(registration.status)}
                        onClick={() => void cancelRegistration(registration.user_id)}
                      >
                        Cancel
                      </button>
                    </div>
                  </td>
                </tr>
              ))}
              {registrations.length === 0 ? (
                <tr>
                  <td colSpan={3} className="py-3 text-sm text-zinc-500">
                    No registrations yet.
                  </td>
                </tr>
              ) : null}
            </tbody>
          </table>
        </div>
      </section>
    </main>
  );
}


===== FILE: src/app/admin/events/page.tsx =====
"use client";

import Link from "next/link";
import { useEffect, useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { toEventCreatePayload } from "@/lib/admin-events-view";
import { requestHal, type ProblemDetails } from "@/lib/hal-client";

type EventItem = {
  id: string;
  slug: string;
  title: string;
  status: string;
};

type EventsResponse = {
  count: number;
  items: EventItem[];
};

export default function AdminEventsPage() {
  const [events, setEvents] = useState<EventItem[]>([]);
  const [pending, setPending] = useState(false);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  const [form, setForm] = useState({
    slug: "",
    title: "",
    start: "",
    end: "",
    timezone: "UTC",
    capacity: "",
  });

  const load = async () => {
    const result = await requestHal<EventsResponse>("/api/v1/events");
    if (!result.ok) {
      setProblem(result.problem);
      return;
    }

    setProblem(null);
    setEvents(result.data.items ?? []);
  };

  useEffect(() => {
    void (async () => {
      const result = await requestHal<EventsResponse>("/api/v1/events");
      if (!result.ok) {
        setProblem(result.problem);
        return;
      }

      setProblem(null);
      setEvents(result.data.items ?? []);
    })();
  }, []);

  const onCreate = async () => {
    setPending(true);
    setProblem(null);

    const result = await requestHal<unknown>("/api/v1/events", {
      method: "POST",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify(toEventCreatePayload(form)),
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    setForm({
      slug: "",
      title: "",
      start: "",
      end: "",
      timezone: "UTC",
      capacity: "",
    });
    await load();
    setPending(false);
  };

  return (
    <main className="mx-auto max-w-5xl p-6">
      <h1 className="text-2xl font-semibold">Admin Events</h1>

      <section className="mt-4 rounded-md border p-4">
        <h2 className="text-sm font-medium">Create event</h2>
        <div className="mt-3 grid gap-2 md:grid-cols-2">
          <input
            placeholder="Slug"
            value={form.slug}
            onChange={(event) => setForm((prev) => ({ ...prev, slug: event.target.value }))}
            className="rounded border px-3 py-2 text-sm"
          />
          <input
            placeholder="Title"
            value={form.title}
            onChange={(event) => setForm((prev) => ({ ...prev, title: event.target.value }))}
            className="rounded border px-3 py-2 text-sm"
          />
          <input
            placeholder="Start ISO"
            value={form.start}
            onChange={(event) => setForm((prev) => ({ ...prev, start: event.target.value }))}
            className="rounded border px-3 py-2 text-sm"
          />
          <input
            placeholder="End ISO"
            value={form.end}
            onChange={(event) => setForm((prev) => ({ ...prev, end: event.target.value }))}
            className="rounded border px-3 py-2 text-sm"
          />
          <input
            placeholder="Timezone"
            value={form.timezone}
            onChange={(event) => setForm((prev) => ({ ...prev, timezone: event.target.value }))}
            className="rounded border px-3 py-2 text-sm"
          />
          <input
            placeholder="Capacity (optional)"
            value={form.capacity}
            onChange={(event) => setForm((prev) => ({ ...prev, capacity: event.target.value }))}
            className="rounded border px-3 py-2 text-sm"
          />
        </div>

        <button
          type="button"
          onClick={() => void onCreate()}
          disabled={pending}
          className="mt-3 rounded border px-3 py-2 text-sm"
        >
          {pending ? "Creating..." : "Create event"}
        </button>
      </section>

      {problem ? (
        <div className="mt-4">
          <ProblemDetailsPanel problem={problem} />
        </div>
      ) : null}

      <section className="mt-4 rounded-md border p-4">
        <h2 className="text-sm font-medium">Events ({events.length})</h2>
        <ul className="mt-3 space-y-2">
          {events.map((event) => (
            <li key={event.id} className="rounded border p-3">
              <div className="flex items-center justify-between">
                <div>
                  <p className="font-medium">{event.title}</p>
                  <p className="text-xs text-zinc-500">{event.slug} · {event.status}</p>
                </div>
                <Link className="text-sm underline" href={`/admin/events/${event.slug}`}>
                  Manage
                </Link>
              </div>
            </li>
          ))}
        </ul>
      </section>
    </main>
  );
}


===== FILE: src/app/admin/layout.tsx =====
"use client";

import { useEffect, useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { requestHal, type HalResource, type ProblemDetails } from "@/lib/hal-client";
import { adminAccessProblem, canAccessAdminFromMe } from "@/lib/ui-access";

export default function AdminLayout({ children }: { children: React.ReactNode }) {
  const [loading, setLoading] = useState(true);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  useEffect(() => {
    const load = async () => {
      setLoading(true);
      const me = await requestHal<HalResource>("/api/v1/me");

      if (!me.ok) {
        setProblem(me.problem);
        setLoading(false);
        return;
      }

      if (!canAccessAdminFromMe(me.data)) {
        setProblem(adminAccessProblem);
        setLoading(false);
        return;
      }

      setProblem(null);
      setLoading(false);
    };

    void load();
  }, []);

  if (loading) {
    return <main className="mx-auto max-w-4xl p-6 text-sm">Checking admin access...</main>;
  }

  if (problem) {
    return (
      <main className="mx-auto max-w-4xl p-6">
        <ProblemDetailsPanel problem={problem} />
      </main>
    );
  }

  return <>{children}</>;
}


===== FILE: src/app/admin/page.tsx =====
export default function AdminHomePage() {
  return (
    <main className="mx-auto max-w-4xl p-6">
      <h1 className="text-2xl font-semibold">Admin Console</h1>
      <p className="mt-2 text-sm">Protected admin area scaffolded in Sprint 13.</p>
      <ul className="mt-4 list-disc pl-5 text-sm">
        <li>
          <a href="/admin/audit" className="underline">
            Open audit log viewer
          </a>
        </li>
      </ul>
    </main>
  );
}


===== FILE: src/app/admin/users/page.tsx =====
"use client";

import { useMemo, useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import {
  buildUsersListHref,
  canAddRole,
  canRemoveRole,
  MUTABLE_ROLES,
  normalizeRoles,
} from "@/lib/admin-users-ui";
import { requestHal, type ProblemDetails } from "@/lib/hal-client";

type UserSummary = {
  id: string;
  email: string;
  status: "ACTIVE" | "DISABLED" | "PENDING";
  roles: string[];
};

type UsersResponse = {
  count: number;
  items: UserSummary[];
};

type UserDetail = UserSummary & {
  _links: Record<string, { href: string }>;
};

export default function AdminUsersPage() {
  const [search, setSearch] = useState("");
  const [status, setStatus] = useState("");
  const [role, setRole] = useState("");

  const [users, setUsers] = useState<UserSummary[]>([]);
  const [selectedUser, setSelectedUser] = useState<UserDetail | null>(null);
  const [pending, setPending] = useState(false);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  const usersHref = useMemo(() => buildUsersListHref({ search, status, role }), [search, status, role]);

  const loadUsers = async () => {
    setPending(true);
    const listResult = await requestHal<UsersResponse>(usersHref);
    if (!listResult.ok) {
      setProblem(listResult.problem);
      setPending(false);
      return;
    }

    setProblem(null);
    setUsers(listResult.data.items ?? []);
    setPending(false);
  };

  const loadUserDetail = async (userId: string) => {
    setPending(true);
    const detailResult = await requestHal<UserDetail>(`/api/v1/users/${userId}`);
    if (!detailResult.ok) {
      setProblem(detailResult.problem);
      setPending(false);
      return;
    }

    setProblem(null);
    setSelectedUser(detailResult.data);
    setPending(false);
  };

  const updateStatus = async (nextStatus: UserSummary["status"]) => {
    if (!selectedUser) {
      return;
    }

    setPending(true);
    const result = await requestHal<unknown>(`/api/v1/users/${selectedUser.id}`, {
      method: "PATCH",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify({ status: nextStatus }),
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    await loadUsers();
    await loadUserDetail(selectedUser.id);
    setPending(false);
  };

  const addRole = async (nextRole: string) => {
    if (!selectedUser) {
      return;
    }

    setPending(true);
    const result = await requestHal<unknown>(`/api/v1/users/${selectedUser.id}/roles`, {
      method: "POST",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify({ role: nextRole }),
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    await loadUserDetail(selectedUser.id);
    setPending(false);
  };

  const removeRole = async (targetRole: string) => {
    if (!selectedUser) {
      return;
    }

    setPending(true);
    const result = await requestHal<unknown>(`/api/v1/users/${selectedUser.id}/roles/${targetRole}`, {
      method: "DELETE",
    });

    if (!result.ok) {
      setProblem(result.problem);
      setPending(false);
      return;
    }

    await loadUserDetail(selectedUser.id);
    setPending(false);
  };

  const selectedRoles = selectedUser ? normalizeRoles(selectedUser.roles) : [];

  return (
    <main className="mx-auto max-w-5xl p-6">
      <h1 className="text-2xl font-semibold">Admin Users</h1>

      <section className="mt-4 rounded-md border p-4">
        <h2 className="text-sm font-medium">Search and filters</h2>
        <div className="mt-3 grid gap-2 md:grid-cols-3">
          <input
            value={search}
            onChange={(event) => setSearch(event.target.value)}
            placeholder="Search by email"
            className="rounded border px-3 py-2 text-sm"
          />
          <select
            value={status}
            onChange={(event) => setStatus(event.target.value)}
            className="rounded border px-3 py-2 text-sm"
          >
            <option value="">All statuses</option>
            <option value="ACTIVE">ACTIVE</option>
            <option value="DISABLED">DISABLED</option>
            <option value="PENDING">PENDING</option>
          </select>
          <select
            value={role}
            onChange={(event) => setRole(event.target.value)}
            className="rounded border px-3 py-2 text-sm"
          >
            <option value="">All roles</option>
            <option value="USER">USER</option>
            <option value="ADMIN">ADMIN</option>
            <option value="SUPER_ADMIN">SUPER_ADMIN</option>
          </select>
        </div>
        <button
          type="button"
          onClick={() => void loadUsers()}
          disabled={pending}
          className="mt-3 rounded border px-3 py-2 text-sm"
        >
          {pending ? "Loading..." : "Load users"}
        </button>
      </section>

      {problem ? (
        <div className="mt-4">
          <ProblemDetailsPanel problem={problem} />
        </div>
      ) : null}

      <section className="mt-4 rounded-md border p-4">
        <h2 className="text-sm font-medium">Users ({users.length})</h2>
        <div className="mt-3 overflow-x-auto">
          <table className="w-full text-left text-sm">
            <thead>
              <tr>
                <th className="pb-2">Email</th>
                <th className="pb-2">Status</th>
                <th className="pb-2">Roles</th>
                <th className="pb-2">Actions</th>
              </tr>
            </thead>
            <tbody>
              {users.map((user) => (
                <tr key={user.id} className="border-t">
                  <td className="py-2">{user.email}</td>
                  <td className="py-2">{user.status}</td>
                  <td className="py-2">{normalizeRoles(user.roles).join(", ")}</td>
                  <td className="py-2">
                    <button
                      type="button"
                      className="rounded border px-2 py-1 text-xs"
                      onClick={() => void loadUserDetail(user.id)}
                      disabled={pending}
                    >
                      Manage
                    </button>
                  </td>
                </tr>
              ))}
              {users.length === 0 ? (
                <tr>
                  <td colSpan={4} className="py-3 text-sm text-zinc-500">
                    No users loaded.
                  </td>
                </tr>
              ) : null}
            </tbody>
          </table>
        </div>
      </section>

      {selectedUser ? (
        <section className="mt-4 rounded-md border p-4">
          <h2 className="text-sm font-medium">User detail</h2>
          <p className="mt-1 text-sm">{selectedUser.email}</p>
          <p className="text-xs text-zinc-500">{selectedUser.id}</p>

          <div className="mt-3">
            <p className="text-sm font-medium">Status</p>
            <div className="mt-2 flex gap-2">
              {(["ACTIVE", "DISABLED", "PENDING"] as const).map((nextStatus) => (
                <button
                  key={nextStatus}
                  type="button"
                  disabled={pending || selectedUser.status === nextStatus}
                  onClick={() => void updateStatus(nextStatus)}
                  className="rounded border px-2 py-1 text-xs"
                >
                  Set {nextStatus}
                </button>
              ))}
            </div>
          </div>

          <div className="mt-4">
            <p className="text-sm font-medium">Roles</p>
            <p className="mt-1 text-xs text-zinc-500">SUPER_ADMIN role mutations are intentionally hidden.</p>
            <div className="mt-2 flex gap-2">
              {selectedRoles.map((existingRole) => (
                <span key={existingRole} className="rounded border px-2 py-1 text-xs">
                  {existingRole}
                </span>
              ))}
            </div>
            <div className="mt-3 flex gap-2">
              {MUTABLE_ROLES.map((mutableRole) => (
                <button
                  key={`add-${mutableRole}`}
                  type="button"
                  disabled={pending || !canAddRole(selectedRoles, mutableRole)}
                  onClick={() => void addRole(mutableRole)}
                  className="rounded border px-2 py-1 text-xs"
                >
                  Add {mutableRole}
                </button>
              ))}
              {MUTABLE_ROLES.map((mutableRole) => (
                <button
                  key={`remove-${mutableRole}`}
                  type="button"
                  disabled={pending || !canRemoveRole(selectedRoles, mutableRole)}
                  onClick={() => void removeRole(mutableRole)}
                  className="rounded border px-2 py-1 text-xs"
                >
                  Remove {mutableRole}
                </button>
              ))}
            </div>
          </div>
        </section>
      ) : null}
    </main>
  );
}


===== FILE: src/app/api/v1/__tests__/hardening.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";

import { POST as postRegister } from "../auth/register/route";
import { POST as postLogin } from "../auth/login/route";
import { GET as getUsers } from "../users/route";
import { GET as getExport } from "../events/[slug]/export/route";
import { POST as postEvents } from "../events/route";
import { POST as postRegistration } from "../events/[slug]/registrations/route";
import { runCli } from "../../../../cli/run-cli";
import { CliIo } from "../../../../cli/types";

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-api-hardening-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const runWithDb = async (argv: string[], dbPath: string): Promise<number> => {
  const { io } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return exitCode;
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

afterEach(async () => {
  delete process.env.APPCTL_DB_FILE;
  delete process.env.APPCTL_ENV;
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("api hardening", () => {
  it("applies rate limit to register/login/export endpoints", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    for (let index = 0; index < 5; index += 1) {
      const registerResponse = await postRegister(
        new Request("http://localhost:3000/api/v1/auth/register", {
          method: "POST",
          headers: {
            "content-type": "application/json",
            origin: "http://localhost:3000",
            "x-forwarded-for": "10.0.0.1",
          },
          body: JSON.stringify({
            email: `limit${index}@example.com`,
            password: "Password123!",
          }),
        }),
      );
      expect(registerResponse.status).toBe(201);
    }

    const blockedRegister = await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "10.0.0.1",
        },
        body: JSON.stringify({
          email: "limit-block@example.com",
          password: "Password123!",
        }),
      }),
    );
    expect(blockedRegister.status).toBe(429);

    const loginAllowed = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "10.0.0.2",
        },
        body: JSON.stringify({
          email: "limit0@example.com",
          password: "Password123!",
        }),
      }),
    );
    expect(loginAllowed.status).toBe(200);

    for (let index = 0; index < 4; index += 1) {
      await postLogin(
        new Request("http://localhost:3000/api/v1/auth/login", {
          method: "POST",
          headers: {
            "content-type": "application/json",
            origin: "http://localhost:3000",
            "x-forwarded-for": "10.0.0.2",
          },
          body: JSON.stringify({
            email: "limit0@example.com",
            password: "Password123!",
          }),
        }),
      );
    }

    const blockedLogin = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          "x-forwarded-for": "10.0.0.2",
        },
        body: JSON.stringify({
          email: "limit0@example.com",
          password: "Password123!",
        }),
      }),
    );
    expect(blockedLogin.status).toBe(429);
  });

  it("sets no-store cache headers on auth and users endpoints", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const register = await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "cache-admin@example.com",
          password: "Password123!",
        }),
      }),
    );
    expect(register.headers.get("cache-control")).toBe("no-store");

    const db = new Database(dbPath);
    const user = db.prepare("SELECT id FROM users WHERE email = 'cache-admin@example.com'").get() as { id: string };
    const role = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
    db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(user.id, role.id);
    db.close();

    const login = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "cache-admin@example.com",
          password: "Password123!",
        }),
      }),
    );

    const cookie = (login.headers.get("set-cookie") ?? "").split(";")[0];
    const users = await getUsers(
      new Request("http://localhost:3000/api/v1/users", {
        headers: { cookie },
      }),
    );

    expect(login.headers.get("cache-control")).toBe("no-store");
    expect(users.headers.get("cache-control")).toBe("no-store");
  });

  it("rate limits export endpoint independently", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "export-limit-admin@example.com",
          password: "Password123!",
        }),
      }),
    );

    const db = new Database(dbPath);
    const admin = db
      .prepare("SELECT id FROM users WHERE email = 'export-limit-admin@example.com'")
      .get() as { id: string };
    const adminRole = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
    db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(admin.id, adminRole.id);
    db.close();

    const login = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "export-limit-admin@example.com",
          password: "Password123!",
        }),
      }),
    );
    const cookie = (login.headers.get("set-cookie") ?? "").split(";")[0];

    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "export-limit-user@example.com",
          password: "Password123!",
        }),
      }),
    );

    await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie,
        },
        body: JSON.stringify({
          slug: "rate-export-event",
          title: "Rate Export Event",
          start: "2026-05-01T10:00:00.000Z",
          end: "2026-05-01T11:00:00.000Z",
          timezone: "UTC",
        }),
      }),
    );

    const dbAfter = new Database(dbPath);
    const user = dbAfter
      .prepare("SELECT id FROM users WHERE email = 'export-limit-user@example.com'")
      .get() as { id: string };
    dbAfter.close();

    await postRegistration(
      new Request("http://localhost:3000/api/v1/events/rate-export-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie,
        },
        body: JSON.stringify({ user_id: user.id }),
      }),
      { params: Promise.resolve({ slug: "rate-export-event" }) },
    );

    for (let index = 0; index < 5; index += 1) {
      const allowed = await getExport(
        new Request("http://localhost:3000/api/v1/events/rate-export-event/export?format=json", {
          headers: {
            cookie,
            "x-forwarded-for": "10.0.0.3",
          },
        }),
        { params: Promise.resolve({ slug: "rate-export-event" }) },
      );
      expect(allowed.status).toBe(200);
    }

    const blocked = await getExport(
      new Request("http://localhost:3000/api/v1/events/rate-export-event/export?format=json", {
        headers: {
          cookie,
          "x-forwarded-for": "10.0.0.3",
        },
      }),
      { params: Promise.resolve({ slug: "rate-export-event" }) },
    );

    expect(blocked.status).toBe(429);
  });
});


===== FILE: src/app/api/v1/account/delete/route.ts =====
import { deleteOwnAccount, getSessionUserFromRequest, isSameOriginMutation } from "../../../../../lib/api/auth";
import { hal, problem } from "../../../../../lib/api/response";

export async function POST(request: Request) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const user = getSessionUserFromRequest(request);
  if (!user) {
    return problem(
      {
        type: "https://lms-219.dev/problems/unauthorized",
        title: "Unauthorized",
        status: 401,
        detail: "Active session required.",
      },
      request,
    );
  }

  try {
    const result = deleteOwnAccount(user.id, crypto.randomUUID());
    return hal(
      result,
      {
        self: { href: "/api/v1/account/delete" },
        register: { href: "/api/v1/auth/register" },
      },
      {
        headers: {
          "cache-control": "no-store",
        },
      },
    );
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to process account deletion.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/account/registrations/route.ts =====
import { getSessionUserFromRequest } from "../../../../../lib/api/auth";
import { listRegistrationsForUser } from "../../../../../lib/api/registrations";
import { hal, problem } from "../../../../../lib/api/response";

export async function GET(request: Request) {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return problem(
      {
        type: "https://lms-219.dev/problems/unauthorized",
        title: "Unauthorized",
        status: 401,
        detail: "Active session required.",
      },
      request,
    );
  }

  try {
    const items = listRegistrationsForUser(user.id);
    return hal(
      {
        count: items.length,
        items,
      },
      {
        self: { href: "/api/v1/account/registrations" },
        me: { href: "/api/v1/me" },
      },
      {
        headers: {
          "cache-control": "no-store",
        },
      },
    );
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to load account registrations.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/admin/invitations/accept/route.ts =====
import {
  ExistingAccountError,
  InvalidInvitationPayloadError,
  InvitationExpiredError,
  InvitationNotFoundError,
  InvitationUsedError,
  acceptAdminInvitation,
} from "../../../../../../lib/api/invitations";
import { hal, problem } from "../../../../../../lib/api/response";
import { isSameOriginMutation } from "../../../../../../lib/api/auth";

type Payload = {
  token?: string;
  password?: string;
};

export async function POST(request: Request) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  let payload: Payload;
  try {
    payload = (await request.json()) as Payload;
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.token || !payload.password) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "token and password are required.",
      },
      request,
    );
  }

  try {
    const accepted = await acceptAdminInvitation(payload.token, payload.password, crypto.randomUUID());

    return hal(
      {
        id: accepted.id,
        email: accepted.email,
        role: accepted.role,
      },
      {
        self: { href: "/api/v1/admin/invitations/accept" },
        login: { href: "/api/v1/auth/login" },
      },
    );
  } catch (error) {
    if (error instanceof InvalidInvitationPayloadError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/invalid-input",
          title: "Bad Request",
          status: 400,
          detail: "token and password are required.",
        },
        request,
      );
    }

    if (error instanceof InvitationNotFoundError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Invitation not found.",
        },
        request,
      );
    }

    if (error instanceof InvitationExpiredError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/precondition-failed",
          title: "Precondition Failed",
          status: 412,
          detail: "Invitation is expired.",
        },
        request,
      );
    }

    if (error instanceof InvitationUsedError || error instanceof ExistingAccountError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/conflict",
          title: "Conflict",
          status: 409,
          detail: "Invitation cannot be accepted.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to accept invitation.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/admin/invitations/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../lib/api/auth";
import { ExistingAccountError, InvalidEmailError, createAdminInvitation } from "../../../../../lib/api/invitations";
import { hal, problem } from "../../../../../lib/api/response";

type Payload = {
  email?: string;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function POST(request: Request) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  let payload: Payload;
  try {
    payload = (await request.json()) as Payload;
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.email) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "email is required.",
      },
      request,
    );
  }

  try {
    const created = createAdminInvitation(payload.email, auth.user.id, crypto.randomUUID());

    return hal(
      {
        email: created.email,
        role: created.role,
        ...(created.token ? { invitation_token: created.token } : {}),
      },
      {
        self: { href: "/api/v1/admin/invitations" },
        accept: { href: "/api/v1/admin/invitations/accept" },
      },
      {
        status: 201,
      },
    );
  } catch (error) {
    if (error instanceof InvalidEmailError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/invalid-input",
          title: "Bad Request",
          status: 400,
          detail: "email is required.",
        },
        request,
      );
    }

    if (error instanceof ExistingAccountError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/conflict",
          title: "Conflict",
          status: 409,
          detail: "Email already belongs to an account.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to create admin invitation.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/audit/route.ts =====
import { getSessionUserFromRequest } from "../../../../lib/api/auth";
import { listAuditEntries } from "../../../../lib/api/audit";
import { hal, problem } from "../../../../lib/api/response";

export async function GET(request: Request) {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return problem(
      {
        type: "https://lms-219.dev/problems/unauthorized",
        title: "Unauthorized",
        status: 401,
        detail: "Active session required.",
      },
      request,
    );
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return problem(
      {
        type: "https://lms-219.dev/problems/forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Admin role required.",
      },
      request,
    );
  }

  const { searchParams } = new URL(request.url);
  const action = searchParams.get("action") ?? undefined;
  const actor_id = searchParams.get("actor_id") ?? undefined;
  const from = searchParams.get("from") ?? undefined;
  const to = searchParams.get("to") ?? undefined;
  const limit = searchParams.get("limit");
  const offset = searchParams.get("offset");

  try {
    const result = listAuditEntries({
      action,
      actor_id,
      from,
      to,
      limit: limit ? Number(limit) : undefined,
      offset: offset ? Number(offset) : undefined,
    });

    return hal(
      {
        count: result.count,
        limit: result.limit,
        offset: result.offset,
        items: result.items,
      },
      {
        self: { href: "/api/v1/audit" },
      },
      {
        headers: {
          "cache-control": "no-store",
        },
      },
    );
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to load audit log.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/auth/__tests__/auth-session.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";

import { GET as getMe } from "../../me/route";
import { POST as postLogin } from "../login/route";
import { POST as postLogout } from "../logout/route";
import { POST as postRegister } from "../register/route";
import { runCli } from "../../../../../cli/run-cli";
import { CliIo } from "../../../../../cli/types";

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-api-auth-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const runWithDb = async (argv: string[], dbPath: string): Promise<number> => {
  const { io } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return exitCode;
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

afterEach(async () => {
  delete process.env.APPCTL_DB_FILE;
  delete process.env.APPCTL_ENV;
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("api/v1 auth/session", () => {
  it("registers user and logs in with secure session cookie semantics", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const registerResponse = await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "sprint8@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(registerResponse.status).toBe(201);

    const loginResponse = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "sprint8@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(loginResponse.status).toBe(200);
    const setCookie = loginResponse.headers.get("set-cookie") ?? "";
    expect(setCookie).toContain("lms_session=");
    expect(setCookie).toContain("HttpOnly");
    expect(setCookie).toContain("SameSite=Lax");
    expect(setCookie).not.toContain("Secure");
  });

  it("sets Secure cookie in prod", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "prod";

    await postRegister(
      new Request("https://example.com/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "https://example.com",
        },
        body: JSON.stringify({
          email: "prod@example.com",
          password: "Password123!",
        }),
      }),
    );

    const loginResponse = await postLogin(
      new Request("https://example.com/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "https://example.com",
        },
        body: JSON.stringify({
          email: "prod@example.com",
          password: "Password123!",
        }),
      }),
    );

    expect(loginResponse.status).toBe(200);
    expect(loginResponse.headers.get("set-cookie")).toContain("Secure");
  });

  it("returns me profile with role-aware links from active session", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "adminish@example.com",
          password: "Password123!",
        }),
      }),
    );

    const db = new Database(dbPath);
    const user = db
      .prepare("SELECT id FROM users WHERE email = ?")
      .get("adminish@example.com") as { id: string };
    const adminRole = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
    db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(user.id, adminRole.id);
    db.close();

    const loginResponse = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "adminish@example.com",
          password: "Password123!",
        }),
      }),
    );

    const cookieHeader = loginResponse.headers.get("set-cookie") ?? "";
    const sessionCookie = cookieHeader.split(";")[0];

    const meResponse = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        method: "GET",
        headers: {
          cookie: sessionCookie,
        },
      }),
    );

    expect(meResponse.status).toBe(200);
    const meBody = await meResponse.json();
    expect(meBody.email).toBe("adminish@example.com");
    expect(meBody.roles).toContain("ADMIN");
    expect(meBody._links).toMatchObject({
      self: { href: "/api/v1/me" },
      logout: { href: "/api/v1/auth/logout" },
      users: { href: "/api/v1/users" },
    });
  });

  it("rejects missing session and supports logout invalidation", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const anonymousMe = await getMe(new Request("http://localhost:3000/api/v1/me"));
    expect(anonymousMe.status).toBe(401);
    const errorBody = await anonymousMe.json();
    expect(errorBody).toMatchObject({
      title: "Unauthorized",
      status: 401,
    });
    expect(errorBody.request_id).toBeTruthy();

    await postRegister(
      new Request("http://localhost:3000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "logout@example.com",
          password: "Password123!",
        }),
      }),
    );

    const loginResponse = await postLogin(
      new Request("http://localhost:3000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          email: "logout@example.com",
          password: "Password123!",
        }),
      }),
    );
    const sessionCookie = (loginResponse.headers.get("set-cookie") ?? "").split(";")[0];

    const logoutResponse = await postLogout(
      new Request("http://localhost:3000/api/v1/auth/logout", {
        method: "POST",
        headers: {
          origin: "http://localhost:3000",
          cookie: sessionCookie,
        },
      }),
    );

    expect(logoutResponse.status).toBe(200);
    expect(logoutResponse.headers.get("set-cookie")).toContain("Max-Age=0");

    const afterLogout = await getMe(
      new Request("http://localhost:3000/api/v1/me", {
        headers: {
          cookie: sessionCookie,
        },
      }),
    );
    expect(afterLogout.status).toBe(401);
  });
});


===== FILE: src/app/api/v1/auth/login/route.ts =====
import {
  buildSessionCookie,
  EmailUnverifiedError,
  getAuthContext,
  InvalidCredentialsError,
  isSameOriginMutation,
  loginUser,
} from "../../../../../lib/api/auth";
import { hal, problem } from "../../../../../lib/api/response";
import { consumeRateLimit } from "../../../../../lib/api/rate-limit";

export async function POST(request: Request) {
  const rateLimit = consumeRateLimit(request, "auth:login", 5, 60_000);
  if (!rateLimit.allowed) {
    return problem(
      {
        type: "https://lms-219.dev/problems/rate-limited",
        title: "Too Many Requests",
        status: 429,
        detail: "Rate limit exceeded for login.",
      },
      request,
      {
        headers: {
          "retry-after": String(rateLimit.retryAfterSeconds),
          "cache-control": "no-store",
        },
      },
    );
  }

  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  let payload: { email?: string; password?: string };
  try {
    payload = (await request.json()) as { email?: string; password?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.email || !payload.password) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "Email and password are required.",
      },
      request,
    );
  }

  try {
    const context = getAuthContext();
    const login = await loginUser(payload.email, payload.password, crypto.randomUUID());

    return hal(
      {
        id: login.user.id,
        email: login.user.email,
        status: login.user.status,
        roles: login.user.roles,
      },
      {
        self: { href: "/api/v1/me" },
        logout: { href: "/api/v1/auth/logout" },
      },
      {
        headers: {
          "set-cookie": buildSessionCookie(login.sessionToken, context.env),
          "cache-control": "no-store",
        },
      },
    );
  } catch (error) {
    if (error instanceof EmailUnverifiedError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/email-unverified",
          title: "Forbidden",
          status: 403,
          detail: "Email verification required before login.",
        },
        request,
        {
          headers: {
            "cache-control": "no-store",
          },
        },
      );
    }

    if (error instanceof InvalidCredentialsError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Invalid credentials.",
        },
        request,
        {
          headers: {
            "cache-control": "no-store",
          },
        },
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to login.",
      },
        request,
        {
          headers: {
            "cache-control": "no-store",
          },
        },
    );
  }
}


===== FILE: src/app/api/v1/auth/logout/route.ts =====
import {
  buildSessionClearCookie,
  getAuthContext,
  isSameOriginMutation,
  logoutUser,
  parseSessionTokenFromCookie,
} from "../../../../../lib/api/auth";
import { hal, problem } from "../../../../../lib/api/response";

export async function POST(request: Request) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const context = getAuthContext();
  const sessionToken = parseSessionTokenFromCookie(request.headers.get("cookie"));

  if (sessionToken) {
    logoutUser(sessionToken, crypto.randomUUID());
  }

  return hal(
    {
      logged_out: true,
    },
    {
      login: { href: "/api/v1/auth/login" },
      register: { href: "/api/v1/auth/register" },
    },
    {
      headers: {
        "set-cookie": buildSessionClearCookie(context.env),
      },
    },
  );
}


===== FILE: src/app/api/v1/auth/password-reset/confirm/route.ts =====
import { hal, problem } from "../../../../../../lib/api/response";
import {
  InvalidPasswordResetPayloadError,
  ResetTokenExpiredError,
  ResetTokenInvalidError,
  ResetTokenUsedError,
  confirmPasswordReset,
  isSameOriginMutation,
} from "../../../../../../lib/api/auth";

export async function POST(request: Request) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  let payload: { token?: string; password?: string };
  try {
    payload = (await request.json()) as { token?: string; password?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.token || !payload.password) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "token and password are required.",
      },
      request,
    );
  }

  try {
    await confirmPasswordReset(payload.token, payload.password, crypto.randomUUID());
    return hal(
      {
        reset: true,
      },
      {
        self: { href: "/api/v1/auth/password-reset/confirm" },
        login: { href: "/api/v1/auth/login" },
      },
      {
        headers: {
          "cache-control": "no-store",
        },
      },
    );
  } catch (error) {
    if (error instanceof InvalidPasswordResetPayloadError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/invalid-input",
          title: "Bad Request",
          status: 400,
          detail: "token and password are required.",
        },
        request,
      );
    }

    if (error instanceof ResetTokenInvalidError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Reset token not found.",
        },
        request,
      );
    }

    if (error instanceof ResetTokenExpiredError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/precondition-failed",
          title: "Precondition Failed",
          status: 412,
          detail: "Reset token is expired.",
        },
        request,
      );
    }

    if (error instanceof ResetTokenUsedError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/conflict",
          title: "Conflict",
          status: 409,
          detail: "Reset token already used.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to reset password.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/auth/password-reset/request/route.ts =====
import { consumeRateLimit } from "../../../../../../lib/api/rate-limit";
import { hal, problem } from "../../../../../../lib/api/response";
import { isSameOriginMutation, requestPasswordReset } from "../../../../../../lib/api/auth";

export async function POST(request: Request) {
  const rateLimit = consumeRateLimit(request, "auth:password-reset-request", 5, 60_000);
  if (!rateLimit.allowed) {
    return problem(
      {
        type: "https://lms-219.dev/problems/rate-limited",
        title: "Too Many Requests",
        status: 429,
        detail: "Rate limit exceeded for password reset requests.",
      },
      request,
      {
        headers: {
          "retry-after": String(rateLimit.retryAfterSeconds),
          "cache-control": "no-store",
        },
      },
    );
  }

  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  let payload: { email?: string };
  try {
    payload = (await request.json()) as { email?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.email) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "email is required.",
      },
      request,
    );
  }

  try {
    const result = requestPasswordReset(payload.email, crypto.randomUUID());
    return hal(
      {
        accepted: true,
        ...(result.token ? { reset_token: result.token } : {}),
      },
      {
        self: { href: "/api/v1/auth/password-reset/request" },
        confirm: { href: "/api/v1/auth/password-reset/confirm" },
      },
      {
        status: 202,
        headers: {
          "cache-control": "no-store",
        },
      },
    );
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to process password reset request.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/auth/register/route.ts =====
import { hal, problem } from "../../../../../lib/api/response";
import {
  EmailAlreadyRegisteredError,
  InvalidRegisterPayloadError,
  InvalidTermsAcknowledgmentError,
  isSameOriginMutation,
  registerUser,
} from "../../../../../lib/api/auth";
import { consumeRateLimit } from "../../../../../lib/api/rate-limit";

export async function POST(request: Request) {
  const rateLimit = consumeRateLimit(request, "auth:register", 5, 60_000);
  if (!rateLimit.allowed) {
    return problem(
      {
        type: "https://lms-219.dev/problems/rate-limited",
        title: "Too Many Requests",
        status: 429,
        detail: "Rate limit exceeded for register.",
      },
      request,
      {
        headers: {
          "retry-after": String(rateLimit.retryAfterSeconds),
          "cache-control": "no-store",
        },
      },
    );
  }

  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  let payload: { email?: string; password?: string; terms_accepted?: boolean };
  try {
    payload = (await request.json()) as { email?: string; password?: string; terms_accepted?: boolean };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.email || !payload.password) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "Email and password are required.",
      },
      request,
    );
  }

  if (payload.terms_accepted === false) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "Terms and Privacy acknowledgment is required.",
      },
      request,
    );
  }

  try {
    const created = await registerUser(
      payload.email,
      payload.password,
      payload.terms_accepted,
      crypto.randomUUID(),
    );
    return hal(
      {
        id: created.id,
        email: created.email,
        status: created.status,
        roles: created.roles,
      },
      {
        self: { href: "/api/v1/me" },
        login: { href: "/api/v1/auth/login" },
      },
      {
        status: 201,
        headers: {
          "cache-control": "no-store",
        },
      },
    );
  } catch (error) {
    if (error instanceof EmailAlreadyRegisteredError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/conflict",
          title: "Conflict",
          status: 409,
          detail: "Email is already registered.",
        },
        request,
        {
          headers: {
            "cache-control": "no-store",
          },
        },
      );
    }

    if (error instanceof InvalidRegisterPayloadError || error instanceof InvalidTermsAcknowledgmentError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/invalid-input",
          title: "Bad Request",
          status: 400,
          detail: "Invalid registration payload.",
        },
        request,
        {
          headers: {
            "cache-control": "no-store",
          },
        },
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to register user.",
      },
        request,
        {
          headers: {
            "cache-control": "no-store",
          },
        },
    );
  }
}


===== FILE: src/app/api/v1/auth/verify/confirm/route.ts =====
import {
  InvalidVerifyTokenError,
  VerifyTokenExpiredError,
  VerifyTokenInvalidError,
  VerifyTokenUsedError,
  confirmEmailVerification,
  isSameOriginMutation,
} from "../../../../../../lib/api/auth";
import { hal, problem } from "../../../../../../lib/api/response";

export async function POST(request: Request) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  let payload: { token?: string };
  try {
    payload = (await request.json()) as { token?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.token) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "token is required.",
      },
      request,
    );
  }

  try {
    await confirmEmailVerification(payload.token, crypto.randomUUID());
    return hal(
      { verified: true },
      {
        self: { href: "/api/v1/auth/verify/confirm" },
        login: { href: "/api/v1/auth/login" },
      },
      {
        headers: {
          "cache-control": "no-store",
        },
      },
    );
  } catch (error) {
    if (error instanceof InvalidVerifyTokenError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/invalid-input",
          title: "Bad Request",
          status: 400,
          detail: "token is required.",
        },
        request,
      );
    }

    if (error instanceof VerifyTokenInvalidError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Verification token not found.",
        },
        request,
      );
    }

    if (error instanceof VerifyTokenExpiredError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/precondition-failed",
          title: "Precondition Failed",
          status: 412,
          detail: "Verification token is expired.",
        },
        request,
      );
    }

    if (error instanceof VerifyTokenUsedError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/conflict",
          title: "Conflict",
          status: 409,
          detail: "Verification token already used.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to verify email.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/auth/verify/request/route.ts =====
import { consumeRateLimit } from "../../../../../../lib/api/rate-limit";
import { hal, problem } from "../../../../../../lib/api/response";
import { isSameOriginMutation, requestEmailVerification } from "../../../../../../lib/api/auth";

export async function POST(request: Request) {
  const rateLimit = consumeRateLimit(request, "auth:verify-request", 5, 60_000);
  if (!rateLimit.allowed) {
    return problem(
      {
        type: "https://lms-219.dev/problems/rate-limited",
        title: "Too Many Requests",
        status: 429,
        detail: "Rate limit exceeded for verification requests.",
      },
      request,
      {
        headers: {
          "retry-after": String(rateLimit.retryAfterSeconds),
          "cache-control": "no-store",
        },
      },
    );
  }

  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  let payload: { email?: string };
  try {
    payload = (await request.json()) as { email?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.email) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "email is required.",
      },
      request,
    );
  }

  const result = requestEmailVerification(payload.email, crypto.randomUUID());
  return hal(
    {
      accepted: true,
      ...(result.token ? { verification_token: result.token } : {}),
    },
    {
      self: { href: "/api/v1/auth/verify/request" },
      confirm: { href: "/api/v1/auth/verify/confirm" },
    },
    {
      status: 202,
      headers: {
        "cache-control": "no-store",
      },
    },
  );
}


===== FILE: src/app/api/v1/docs/route.ts =====
import { openApiDocument } from "../../../../lib/api/openapi";

export async function GET() {
  return Response.json(openApiDocument, {
    headers: {
      "content-type": "application/json; charset=utf-8",
    },
  });
}


===== FILE: src/app/api/v1/events/__tests__/events-api.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";

import { GET as getEvents, POST as postEvents } from "../route";
import { GET as getEventBySlug, PATCH as patchEventBySlug } from "../[slug]/route";
import { POST as postPublishEvent } from "../[slug]/publish/route";
import { POST as postCancelEvent } from "../[slug]/cancel/route";
import { POST as postLogin } from "../../auth/login/route";
import { POST as postRegister } from "../../auth/register/route";
import { runCli } from "../../../../../cli/run-cli";
import { CliIo } from "../../../../../cli/types";

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-api-events-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const runWithDb = async (argv: string[], dbPath: string): Promise<number> => {
  const { io } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return exitCode;
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

const registerAndLoginAdmin = async (dbPath: string, email: string): Promise<string> => {
  await postRegister(
    new Request("http://localhost:3000/api/v1/auth/register", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  const db = new Database(dbPath);
  const user = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  const role = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
  db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(user.id, role.id);
  db.close();

  const login = await postLogin(
    new Request("http://localhost:3000/api/v1/auth/login", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  return (login.headers.get("set-cookie") ?? "").split(";")[0];
};

afterEach(async () => {
  delete process.env.APPCTL_DB_FILE;
  delete process.env.APPCTL_ENV;
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("api/v1 events", () => {
  it("creates and updates event with admin session", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLoginAdmin(dbPath, "event-admin@example.com");

    const create = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          slug: "spring-demo",
          title: "Spring Demo",
          start: "2026-03-10T10:00:00.000Z",
          end: "2026-03-10T11:00:00.000Z",
          timezone: "UTC",
          capacity: 10,
        }),
      }),
    );

    expect(create.status).toBe(201);
    const createdBody = await create.json();
    expect(createdBody.slug).toBe("spring-demo");
    expect(createdBody.status).toBe("DRAFT");
    expect(createdBody._links["app:publish"]).toBeTruthy();

    const update = await patchEventBySlug(
      new Request("http://localhost:3000/api/v1/events/spring-demo", {
        method: "PATCH",
        headers: {
          "content-type": "application/json",
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ title: "Spring Demo Updated", capacity: 20 }),
      }),
      { params: Promise.resolve({ slug: "spring-demo" }) },
    );

    expect(update.status).toBe(200);
    const updatedBody = await update.json();
    expect(updatedBody.title).toBe("Spring Demo Updated");
    expect(updatedBody.capacity).toBe(20);
  });

  it("enforces state-based publish/cancel HATEOAS links", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLoginAdmin(dbPath, "state-admin@example.com");

    await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          slug: "stateful",
          title: "Stateful Event",
          start: "2026-03-11T10:00:00.000Z",
          end: "2026-03-11T11:00:00.000Z",
          timezone: "UTC",
        }),
      }),
    );

    const draftView = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/stateful", {
        headers: { cookie: adminCookie },
      }),
      { params: Promise.resolve({ slug: "stateful" }) },
    );
    const draftBody = await draftView.json();
    expect(draftBody._links["app:publish"]).toBeTruthy();
    expect(draftBody._links["app:cancel"]).toBeFalsy();

    const publish = await postPublishEvent(
      new Request("http://localhost:3000/api/v1/events/stateful/publish", {
        method: "POST",
        headers: {
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
      }),
      { params: Promise.resolve({ slug: "stateful" }) },
    );
    expect(publish.status).toBe(200);

    const publishedView = await getEventBySlug(
      new Request("http://localhost:3000/api/v1/events/stateful", {
        headers: { cookie: adminCookie },
      }),
      { params: Promise.resolve({ slug: "stateful" }) },
    );
    const publishedBody = await publishedView.json();
    expect(publishedBody.status).toBe("PUBLISHED");
    expect(publishedBody._links["app:publish"]).toBeFalsy();
    expect(publishedBody._links["app:cancel"]).toBeTruthy();

    const cancel = await postCancelEvent(
      new Request("http://localhost:3000/api/v1/events/stateful/cancel", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({ reason: "Weather risk" }),
      }),
      { params: Promise.resolve({ slug: "stateful" }) },
    );

    expect(cancel.status).toBe(200);
    const cancelledBody = await cancel.json();
    expect(cancelledBody.status).toBe("CANCELLED");
    expect(cancelledBody._links["app:publish"]).toBeFalsy();
    expect(cancelledBody._links["app:cancel"]).toBeFalsy();
  });

  it("supports list filters and paging metadata", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLoginAdmin(dbPath, "list-admin@example.com");

    await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          slug: "list-a",
          title: "List A",
          start: "2026-03-12T10:00:00.000Z",
          end: "2026-03-12T11:00:00.000Z",
          timezone: "UTC",
        }),
      }),
    );

    await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
        body: JSON.stringify({
          slug: "list-b",
          title: "List B",
          start: "2026-03-13T10:00:00.000Z",
          end: "2026-03-13T11:00:00.000Z",
          timezone: "UTC",
        }),
      }),
    );

    await postPublishEvent(
      new Request("http://localhost:3000/api/v1/events/list-b/publish", {
        method: "POST",
        headers: {
          cookie: adminCookie,
          origin: "http://localhost:3000",
        },
      }),
      { params: Promise.resolve({ slug: "list-b" }) },
    );

    const list = await getEvents(new Request("http://localhost:3000/api/v1/events?status=PUBLISHED&limit=1&offset=0"));
    expect(list.status).toBe(200);
    const body = await list.json();
    expect(body.limit).toBe(1);
    expect(body.offset).toBe(0);
    expect(body.items).toHaveLength(1);
    expect(body.items[0].status).toBe("PUBLISHED");
  });
});


===== FILE: src/app/api/v1/events/__tests__/registrations-api.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";

import { POST as postEvents } from "../route";
import { GET as getRegistrations, POST as postRegistration } from "../[slug]/registrations/route";
import { DELETE as deleteRegistration } from "../[slug]/registrations/[userId]/route";
import { POST as postCheckin } from "../[slug]/checkins/route";
import { GET as getExport } from "../[slug]/export/route";
import { POST as postLogin } from "../../auth/login/route";
import { POST as postRegister } from "../../auth/register/route";
import { runCli } from "../../../../../cli/run-cli";
import { CliIo } from "../../../../../cli/types";
import { resetRateLimits } from "../../../../../lib/api/rate-limit";

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-api-reg-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const runWithDb = async (argv: string[], dbPath: string): Promise<number> => {
  const { io } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return exitCode;
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

const registerAndLogin = async (email: string): Promise<string> => {
  await postRegister(
    new Request("http://localhost:3000/api/v1/auth/register", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  const login = await postLogin(
    new Request("http://localhost:3000/api/v1/auth/login", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  return (login.headers.get("set-cookie") ?? "").split(";")[0];
};

const addAdminRole = (dbPath: string, email: string) => {
  const db = new Database(dbPath);
  const user = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string };
  const role = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
  db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(user.id, role.id);
  db.close();
};

const createEventAsAdmin = async (adminCookie: string, slug: string, capacity = 1) => {
  const create = await postEvents(
    new Request("http://localhost:3000/api/v1/events", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
        cookie: adminCookie,
      },
      body: JSON.stringify({
        slug,
        title: slug,
        start: "2026-04-01T10:00:00.000Z",
        end: "2026-04-01T11:00:00.000Z",
        timezone: "UTC",
        capacity,
      }),
    }),
  );
  expect(create.status).toBe(201);
};

afterEach(async () => {
  delete process.env.APPCTL_DB_FILE;
  delete process.env.APPCTL_ENV;
  resetRateLimits();
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("api/v1 registrations/checkin/export", () => {
  it("adds registrations with capacity waitlist behavior", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("reg-admin@example.com");
    addAdminRole(dbPath, "reg-admin@example.com");
    await createEventAsAdmin(adminCookie, "waitlist-event", 1);

    await registerAndLogin("user1@example.com");
    await registerAndLogin("user2@example.com");

    const db = new Database(dbPath);
    const user1 = db.prepare("SELECT id FROM users WHERE email = 'user1@example.com'").get() as { id: string };
    const user2 = db.prepare("SELECT id FROM users WHERE email = 'user2@example.com'").get() as { id: string };
    db.close();

    const addOne = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/waitlist-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ user_id: user1.id }),
      }),
      { params: Promise.resolve({ slug: "waitlist-event" }) },
    );

    const addTwo = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/waitlist-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ user_id: user2.id }),
      }),
      { params: Promise.resolve({ slug: "waitlist-event" }) },
    );

    expect((await addOne.json()).status).toBe("REGISTERED");
    expect((await addTwo.json()).status).toBe("WAITLISTED");
  });

  it("removes as CANCELLED state transition and supports check-in", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("checkin-admin@example.com");
    addAdminRole(dbPath, "checkin-admin@example.com");
    await createEventAsAdmin(adminCookie, "checkin-event", 5);

    await registerAndLogin("checkin-user@example.com");
    const db = new Database(dbPath);
    const user = db.prepare("SELECT id FROM users WHERE email = 'checkin-user@example.com'").get() as {
      id: string;
    };
    db.close();

    await postRegistration(
      new Request("http://localhost:3000/api/v1/events/checkin-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ user_id: user.id }),
      }),
      { params: Promise.resolve({ slug: "checkin-event" }) },
    );

    const checkedIn = await postCheckin(
      new Request("http://localhost:3000/api/v1/events/checkin-event/checkins", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ user_id: user.id }),
      }),
      { params: Promise.resolve({ slug: "checkin-event" }) },
    );
    expect((await checkedIn.json()).status).toBe("CHECKED_IN");

    const removed = await deleteRegistration(
      new Request(`http://localhost:3000/api/v1/events/checkin-event/registrations/${user.id}`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
      }),
      { params: Promise.resolve({ slug: "checkin-event", userId: user.id }) },
    );
    expect((await removed.json()).status).toBe("CANCELLED");

    const checkinAfterCancel = await postCheckin(
      new Request("http://localhost:3000/api/v1/events/checkin-event/checkins", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ user_id: user.id }),
      }),
      { params: Promise.resolve({ slug: "checkin-event" }) },
    );
    expect(checkinAfterCancel.status).toBe(412);
  });

  it("exports json/csv and enforces include_email governance", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("export-admin@example.com");
    addAdminRole(dbPath, "export-admin@example.com");
    await createEventAsAdmin(adminCookie, "export-event", 5);

    await registerAndLogin("export-user@example.com");
    const db = new Database(dbPath);
    const user = db.prepare("SELECT id FROM users WHERE email = 'export-user@example.com'").get() as {
      id: string;
    };
    db.close();

    await postRegistration(
      new Request("http://localhost:3000/api/v1/events/export-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ user_id: user.id }),
      }),
      { params: Promise.resolve({ slug: "export-event" }) },
    );

    const exportJson = await getExport(
      new Request("http://localhost:3000/api/v1/events/export-event/export?format=json&include_email=true", {
        headers: { cookie: adminCookie },
      }),
      { params: Promise.resolve({ slug: "export-event" }) },
    );
    expect(exportJson.status).toBe(200);
    expect(exportJson.headers.get("content-type")).toContain("application/json");

    const exportCsv = await getExport(
      new Request("http://localhost:3000/api/v1/events/export-event/export?format=csv", {
        headers: { cookie: adminCookie },
      }),
      { params: Promise.resolve({ slug: "export-event" }) },
    );
    expect(exportCsv.status).toBe(200);
    expect(exportCsv.headers.get("content-type")).toContain("text/csv");

    process.env.APPCTL_ENV = "prod";
    const blocked = await getExport(
      new Request("https://example.com/api/v1/events/export-event/export?format=json&include_email=true", {
        headers: { cookie: adminCookie },
      }),
      { params: Promise.resolve({ slug: "export-event" }) },
    );
    expect(blocked.status).toBe(403);
  });

  it("lists registrations with optional status filter", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("list-reg-admin@example.com");
    addAdminRole(dbPath, "list-reg-admin@example.com");
    await createEventAsAdmin(adminCookie, "list-reg-event", 10);

    await registerAndLogin("list-reg-user@example.com");
    const db = new Database(dbPath);
    const user = db.prepare("SELECT id FROM users WHERE email = 'list-reg-user@example.com'").get() as {
      id: string;
    };
    db.close();

    await postRegistration(
      new Request("http://localhost:3000/api/v1/events/list-reg-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ user_id: user.id }),
      }),
      { params: Promise.resolve({ slug: "list-reg-event" }) },
    );

    const listAll = await getRegistrations(
      new Request("http://localhost:3000/api/v1/events/list-reg-event/registrations", {
        headers: { cookie: adminCookie },
      }),
      { params: Promise.resolve({ slug: "list-reg-event" }) },
    );
    const listFiltered = await getRegistrations(
      new Request("http://localhost:3000/api/v1/events/list-reg-event/registrations?status=REGISTERED", {
        headers: { cookie: adminCookie },
      }),
      { params: Promise.resolve({ slug: "list-reg-event" }) },
    );

    expect(listAll.status).toBe(200);
    expect(listFiltered.status).toBe(200);
    expect((await listFiltered.json()).items).toHaveLength(1);
  });
});


===== FILE: src/app/api/v1/events/__tests__/self-registration.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";

import { POST as postEvents } from "../route";
import { DELETE as deleteRegistration } from "../[slug]/registrations/[userId]/route";
import { POST as postRegistration } from "../[slug]/registrations/route";
import { POST as postLogin } from "../../auth/login/route";
import { POST as postRegister } from "../../auth/register/route";
import { runCli } from "../../../../../cli/run-cli";
import { CliIo } from "../../../../../cli/types";

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-api-self-reg-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const runWithDb = async (argv: string[], dbPath: string): Promise<number> => {
  const { io } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return exitCode;
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

const registerAndLogin = async (email: string): Promise<string> => {
  await postRegister(
    new Request("http://localhost:3000/api/v1/auth/register", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  const login = await postLogin(
    new Request("http://localhost:3000/api/v1/auth/login", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password: "Password123!" }),
    }),
  );

  return (login.headers.get("set-cookie") ?? "").split(";")[0];
};

afterEach(async () => {
  delete process.env.APPCTL_DB_FILE;
  delete process.env.APPCTL_ENV;
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("self registration API", () => {
  it("allows authenticated user to register and cancel themselves", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("self-admin@example.com");
    const userCookie = await registerAndLogin("self-user@example.com");

    const db = new Database(dbPath);
    const admin = db.prepare("SELECT id FROM users WHERE email = 'self-admin@example.com'").get() as { id: string };
    const user = db.prepare("SELECT id FROM users WHERE email = 'self-user@example.com'").get() as { id: string };
    const adminRole = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
    db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(admin.id, adminRole.id);
    db.close();

    const createEvent = await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({
          slug: "self-reg-event",
          title: "Self Registration Event",
          start: "2026-06-01T10:00:00.000Z",
          end: "2026-06-01T11:00:00.000Z",
          timezone: "UTC",
          capacity: 1,
        }),
      }),
    );
    expect(createEvent.status).toBe(201);

    const addSelf = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/self-reg-event/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: userCookie,
        },
        body: JSON.stringify({ user_id: user.id }),
      }),
      { params: Promise.resolve({ slug: "self-reg-event" }) },
    );
    expect(addSelf.status).toBe(200);
    expect((await addSelf.json()).status).toBe("REGISTERED");

    const removeSelf = await deleteRegistration(
      new Request(`http://localhost:3000/api/v1/events/self-reg-event/registrations/${user.id}`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: userCookie,
        },
      }),
      { params: Promise.resolve({ slug: "self-reg-event", userId: user.id }) },
    );

    expect(removeSelf.status).toBe(200);
    expect((await removeSelf.json()).status).toBe("CANCELLED");
  });

  it("prevents non-admin users from managing other users registrations", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("self-admin-2@example.com");
    const userCookie = await registerAndLogin("self-user-2@example.com");
    await registerAndLogin("other-user@example.com");

    const db = new Database(dbPath);
    const admin = db.prepare("SELECT id FROM users WHERE email = 'self-admin-2@example.com'").get() as { id: string };
    const user = db.prepare("SELECT id FROM users WHERE email = 'self-user-2@example.com'").get() as { id: string };
    const other = db.prepare("SELECT id FROM users WHERE email = 'other-user@example.com'").get() as { id: string };
    const adminRole = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
    db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(admin.id, adminRole.id);
    db.close();

    await postEvents(
      new Request("http://localhost:3000/api/v1/events", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({
          slug: "forbidden-self-reg",
          title: "Forbidden Self Registration",
          start: "2026-06-02T10:00:00.000Z",
          end: "2026-06-02T11:00:00.000Z",
          timezone: "UTC",
          capacity: 2,
        }),
      }),
    );

    const addOther = await postRegistration(
      new Request("http://localhost:3000/api/v1/events/forbidden-self-reg/registrations", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: userCookie,
        },
        body: JSON.stringify({ user_id: other.id }),
      }),
      { params: Promise.resolve({ slug: "forbidden-self-reg" }) },
    );

    expect(addOther.status).toBe(403);

    const removeOther = await deleteRegistration(
      new Request(`http://localhost:3000/api/v1/events/forbidden-self-reg/registrations/${other.id}`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: userCookie,
        },
      }),
      { params: Promise.resolve({ slug: "forbidden-self-reg", userId: other.id }) },
    );

    expect(removeOther.status).toBe(403);

    const removeSelfWithoutRegistration = await deleteRegistration(
      new Request(`http://localhost:3000/api/v1/events/forbidden-self-reg/registrations/${user.id}`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: userCookie,
        },
      }),
      { params: Promise.resolve({ slug: "forbidden-self-reg", userId: user.id }) },
    );

    expect(removeSelfWithoutRegistration.status).toBe(404);
  });
});


===== FILE: src/app/api/v1/events/[slug]/cancel/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../../lib/api/auth";
import { hal, problem } from "../../../../../../lib/api/response";
import { eventLinksForState } from "../../../../../../lib/api/events";
import { resolveConfig } from "../../../../../../cli/config";
import { EventNotFoundError, InvalidInputError } from "../../../../../../core/domain/errors";
import { SqliteAuditSink } from "../../../../../../core/infrastructure/sqlite/audit-sink";
import { SqliteEventRepository } from "../../../../../../core/infrastructure/sqlite/repositories";
import { cancelEvent as cancelEventUseCase } from "../../../../../../core/use-cases/cancel-event";
import { executeWithAudit } from "../../../../../../core/use-cases/with-audit";

type RouteContext = {
  params: Promise<{ slug: string }>;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function POST(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { slug } = await context.params;
  const config = resolveConfig({ envVars: process.env });
  const events = new SqliteEventRepository(config);
  const audit = new SqliteAuditSink(config);

  let payload: { reason?: string };
  try {
    payload = (await request.json()) as { reason?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.reason) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "reason is required.",
      },
      request,
    );
  }

  try {
    const cancelled = executeWithAudit({
      action: "api.event.cancel",
      requestId: crypto.randomUUID(),
      targetType: "event",
      audit,
      execute: () =>
        cancelEventUseCase(
          {
            slug,
            reason: payload.reason!,
          },
          {
            events,
            now: () => new Date().toISOString(),
          },
        ),
      metadata: () => ({
        slug,
        actorId: auth.user.id,
        reason: payload.reason?.trim(),
      }),
    });

    return hal({ ...cancelled }, eventLinksForState(cancelled.slug, cancelled.status));
  } catch (error) {
    if (error instanceof InvalidInputError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/invalid-input",
          title: "Bad Request",
          status: 400,
          detail: "reason is required.",
        },
        request,
      );
    }

    if (error instanceof EventNotFoundError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Event not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to cancel event.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/events/[slug]/checkins/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../../lib/api/auth";
import { hal, problem } from "../../../../../../lib/api/response";
import { resolveConfig } from "../../../../../../cli/config";
import {
  CancelledRegistrationCheckinError,
  EventNotFoundError,
  RegistrationNotFoundError,
  UserNotFoundError,
} from "../../../../../../core/domain/errors";
import { SqliteAuditSink } from "../../../../../../core/infrastructure/sqlite/audit-sink";
import {
  SqliteEventRepository,
  SqliteRegistrationRepository,
  SqliteUserRepository,
} from "../../../../../../core/infrastructure/sqlite/repositories";
import { checkInParticipant } from "../../../../../../core/use-cases/check-in-participant";
import { executeWithAudit } from "../../../../../../core/use-cases/with-audit";

type RouteContext = {
  params: Promise<{ slug: string }>;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function POST(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { slug } = await context.params;

  let payload: { user_id?: string; user_email?: string };
  try {
    payload = (await request.json()) as { user_id?: string; user_email?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  const identifier = payload.user_id ?? payload.user_email;
  if (!identifier) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "user_id or user_email is required.",
      },
      request,
    );
  }

  const config = resolveConfig({ envVars: process.env });
  const users = new SqliteUserRepository(config);
  const events = new SqliteEventRepository(config);
  const registrations = new SqliteRegistrationRepository(config);
  const audit = new SqliteAuditSink(config);

  try {
    const checkedIn = executeWithAudit({
      action: "api.registration.checkin",
      requestId: crypto.randomUUID(),
      targetType: "registration",
      audit,
      execute: () =>
        checkInParticipant(
          {
            eventSlug: slug,
            userIdentifier: identifier,
          },
          {
            users,
            events,
            registrations,
          },
        ),
      metadata: (result) => ({
        eventSlug: slug,
        userId: result.user_id,
        actorId: auth.user.id,
      }),
    });

    return hal(
      { ...checkedIn },
      {
        self: { href: `/api/v1/events/${slug}/checkins` },
        registration: { href: `/api/v1/events/${slug}/registrations/${checkedIn.user_id}` },
      },
    );
  } catch (error) {
    if (error instanceof CancelledRegistrationCheckinError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/precondition-failed",
          title: "Precondition Failed",
          status: 412,
          detail: "Cannot check in a cancelled registration.",
        },
        request,
      );
    }

    if (
      error instanceof EventNotFoundError ||
      error instanceof UserNotFoundError ||
      error instanceof RegistrationNotFoundError
    ) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Registration not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to check in registration.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/events/[slug]/export/route.ts =====
import { getSessionUserFromRequest } from "../../../../../../lib/api/auth";
import { problem } from "../../../../../../lib/api/response";
import { exportEventData } from "../../../../../../lib/api/registrations";
import { resolveConfig } from "../../../../../../cli/config";
import { EventNotFoundError } from "../../../../../../core/domain/errors";
import { consumeRateLimit } from "../../../../../../lib/api/rate-limit";

type RouteContext = {
  params: Promise<{ slug: string }>;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

const toBool = (value: string | null): boolean => {
  if (!value) {
    return false;
  }
  return ["1", "true", "yes"].includes(value.toLowerCase());
};

export async function GET(request: Request, context: RouteContext) {
  const rateLimit = consumeRateLimit(request, "event:export", 5, 60_000);
  if (!rateLimit.allowed) {
    return problem(
      {
        type: "https://lms-219.dev/problems/rate-limited",
        title: "Too Many Requests",
        status: 429,
        detail: "Rate limit exceeded for export.",
      },
      request,
      {
        headers: {
          "retry-after": String(rateLimit.retryAfterSeconds),
          "cache-control": "no-store",
        },
      },
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { slug } = await context.params;
  const url = new URL(request.url);
  const format = url.searchParams.get("format")?.toLowerCase() ?? "json";
  const includeEmail = toBool(url.searchParams.get("include_email"));

  if (format !== "json" && format !== "csv") {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "format must be csv or json.",
      },
      request,
    );
  }

  const config = resolveConfig({ envVars: process.env });
  if (includeEmail && config.env !== "local") {
    return problem(
      {
        type: "https://lms-219.dev/problems/forbidden",
        title: "Forbidden",
        status: 403,
        detail: "include_email is restricted outside local environment.",
      },
      request,
    );
  }

  try {
    const exported = exportEventData({
      slug,
      format,
      includeEmail,
      actorId: auth.user.id,
      requestId: crypto.randomUUID(),
    });

    return new Response(exported.body, {
      status: 200,
      headers: {
        "content-type":
          exported.format === "csv" ? "text/csv; charset=utf-8" : "application/json; charset=utf-8",
        "cache-control": "no-store",
      },
    });
  } catch (error) {
    if (error instanceof EventNotFoundError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Event not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to export event data.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/events/[slug]/ics/route.ts =====
import { getEventBySlug } from "../../../../../../lib/api/events";
import { problem } from "../../../../../../lib/api/response";
import { EventNotFoundError } from "../../../../../../core/domain/errors";

type RouteContext = {
  params: Promise<{ slug: string }>;
};

const formatUtcIcs = (iso: string) => {
  return iso.replace(/[-:]/g, "").replace(/\.\d{3}Z$/, "Z");
};

const toIcs = (event: {
  slug: string;
  title: string;
  start_at: string;
  end_at: string;
}) => {
  const uid = `${event.slug}@lms-219`;
  const now = formatUtcIcs(new Date().toISOString());
  const start = formatUtcIcs(event.start_at);
  const end = formatUtcIcs(event.end_at);

  return [
    "BEGIN:VCALENDAR",
    "VERSION:2.0",
    "PRODID:-//LMS 219//Events//EN",
    "CALSCALE:GREGORIAN",
    "METHOD:PUBLISH",
    "BEGIN:VEVENT",
    `UID:${uid}`,
    `DTSTAMP:${now}`,
    `DTSTART:${start}`,
    `DTEND:${end}`,
    `SUMMARY:${event.title}`,
    `DESCRIPTION:Event ${event.slug}`,
    "END:VEVENT",
    "END:VCALENDAR",
  ].join("\r\n");
};

export async function GET(request: Request, context: RouteContext) {
  const { slug } = await context.params;

  try {
    const event = getEventBySlug(slug);
    const body = toIcs(event);

    return new Response(body, {
      status: 200,
      headers: {
        "content-type": "text/calendar; charset=utf-8",
        "cache-control": "no-store",
        "content-disposition": `attachment; filename=\"${slug}.ics\"`,
      },
    });
  } catch (error) {
    if (error instanceof EventNotFoundError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Event not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to export event calendar.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/events/[slug]/publish/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../../lib/api/auth";
import { hal, problem } from "../../../../../../lib/api/response";
import { eventLinksForState } from "../../../../../../lib/api/events";
import { resolveConfig } from "../../../../../../cli/config";
import { EventNotFoundError } from "../../../../../../core/domain/errors";
import { SqliteAuditSink } from "../../../../../../core/infrastructure/sqlite/audit-sink";
import { SqliteEventRepository } from "../../../../../../core/infrastructure/sqlite/repositories";
import { publishEvent as publishEventUseCase } from "../../../../../../core/use-cases/publish-event";
import { executeWithAudit } from "../../../../../../core/use-cases/with-audit";

type RouteContext = {
  params: Promise<{ slug: string }>;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function POST(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { slug } = await context.params;
  const config = resolveConfig({ envVars: process.env });
  const events = new SqliteEventRepository(config);
  const audit = new SqliteAuditSink(config);

  try {
    const result = executeWithAudit({
      action: "api.event.publish",
      requestId: crypto.randomUUID(),
      targetType: "event",
      audit,
      execute: () =>
        publishEventUseCase(
          { slug },
          {
            events,
            now: () => new Date().toISOString(),
          },
        ),
      metadata: (out) => ({
        slug,
        actorId: auth.user.id,
        idempotent: out.idempotent,
      }),
    });

    const published = result.event;
    return hal({ ...published }, eventLinksForState(published.slug, published.status));
  } catch (error) {
    if (error instanceof EventNotFoundError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Event not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to publish event.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/events/[slug]/registrations/[userId]/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../../../lib/api/auth";
import { hal, problem } from "../../../../../../../lib/api/response";
import { resolveConfig } from "../../../../../../../cli/config";
import {
  EventNotFoundError,
  RegistrationNotFoundError,
  UserNotFoundError,
} from "../../../../../../../core/domain/errors";
import { SqliteAuditSink } from "../../../../../../../core/infrastructure/sqlite/audit-sink";
import {
  SqliteEventRepository,
  SqliteRegistrationRepository,
  SqliteUserRepository,
} from "../../../../../../../core/infrastructure/sqlite/repositories";
import { removeParticipant } from "../../../../../../../core/use-cases/remove-participant";
import { executeWithAudit } from "../../../../../../../core/use-cases/with-audit";

type RouteContext = {
  params: Promise<{ slug: string; userId: string }>;
};

const requireSession = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  return { user };
};

const isAdmin = (roles: string[]): boolean => {
  return roles.includes("ADMIN") || roles.includes("SUPER_ADMIN");
};

export async function DELETE(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireSession(request);
  if (auth.error) {
    return auth.error;
  }

  const { slug, userId } = await context.params;

  if (!isAdmin(auth.user.roles) && userId !== auth.user.id) {
    return problem(
      {
        type: "https://lms-219.dev/problems/forbidden",
        title: "Forbidden",
        status: 403,
        detail: "You can only cancel your own registration.",
      },
      request,
    );
  }

  const config = resolveConfig({ envVars: process.env });
  const users = new SqliteUserRepository(config);
  const events = new SqliteEventRepository(config);
  const registrations = new SqliteRegistrationRepository(config);
  const audit = new SqliteAuditSink(config);

  try {
    const removed = executeWithAudit({
      action: "api.registration.cancel",
      requestId: crypto.randomUUID(),
      targetType: "registration",
      audit,
      execute: () =>
        removeParticipant(
          {
            eventSlug: slug,
            userIdentifier: userId,
          },
          {
            users,
            events,
            registrations,
          },
        ),
      metadata: (result) => ({
        eventSlug: slug,
        userId: result.user_id,
        actorId: auth.user.id,
      }),
    });

    return hal(
      { ...removed },
      {
        self: { href: `/api/v1/events/${slug}/registrations/${userId}` },
        collection: { href: `/api/v1/events/${slug}/registrations` },
      },
    );
  } catch (error) {
    if (
      error instanceof EventNotFoundError ||
      error instanceof UserNotFoundError ||
      error instanceof RegistrationNotFoundError
    ) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Registration not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to remove registration.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/events/[slug]/registrations/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../../lib/api/auth";
import { hal, problem } from "../../../../../../lib/api/response";
import { listRegistrations } from "../../../../../../lib/api/registrations";
import { resolveConfig } from "../../../../../../cli/config";
import { EventNotFoundError, UserNotFoundError } from "../../../../../../core/domain/errors";
import { SqliteAuditSink } from "../../../../../../core/infrastructure/sqlite/audit-sink";
import {
  SqliteEventRepository,
  SqliteRegistrationRepository,
  SqliteUserRepository,
} from "../../../../../../core/infrastructure/sqlite/repositories";
import { registerParticipant } from "../../../../../../core/use-cases/register-participant";
import { executeWithAudit } from "../../../../../../core/use-cases/with-audit";

type RouteContext = {
  params: Promise<{ slug: string }>;
};

const requireSession = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  return { user };
};

const isAdmin = (roles: string[]): boolean => {
  return roles.includes("ADMIN") || roles.includes("SUPER_ADMIN");
};

export async function GET(request: Request, context: RouteContext) {
  const auth = requireSession(request);
  if (auth.error) {
    return auth.error;
  }

  const { slug } = await context.params;
  const status = new URL(request.url).searchParams.get("status") ?? undefined;

  try {
    const items = listRegistrations(slug, status);
    const visibleItems = isAdmin(auth.user.roles)
      ? items
      : items.filter((item) => item.user_id === auth.user.id);

    return hal(
      {
        count: visibleItems.length,
        items: visibleItems,
      },
      {
        self: { href: `/api/v1/events/${slug}/registrations` },
        event: { href: `/api/v1/events/${slug}` },
      },
    );
  } catch (error) {
    if (error instanceof EventNotFoundError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Event not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to list registrations.",
      },
      request,
    );
  }
}

export async function POST(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireSession(request);
  if (auth.error) {
    return auth.error;
  }

  const { slug } = await context.params;
  let payload: { user_id?: string; user_email?: string };

  try {
    payload = (await request.json()) as { user_id?: string; user_email?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  const identifier = payload.user_id ?? payload.user_email ?? auth.user.id;

  if (!isAdmin(auth.user.roles)) {
    const isSelfById = payload.user_id ? payload.user_id === auth.user.id : true;
    const isSelfByEmail = payload.user_email
      ? payload.user_email.toLowerCase() === auth.user.email.toLowerCase()
      : true;

    if (!isSelfById || !isSelfByEmail) {
      return problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "You can only create your own registration.",
        },
        request,
      );
    }
  }

  const config = resolveConfig({ envVars: process.env });
  const users = new SqliteUserRepository(config);
  const events = new SqliteEventRepository(config);
  const registrations = new SqliteRegistrationRepository(config);
  const audit = new SqliteAuditSink(config);

  try {
    const added = executeWithAudit({
      action: "api.registration.add",
      requestId: crypto.randomUUID(),
      targetType: "registration",
      audit,
      execute: () =>
        registerParticipant(
          {
            eventSlug: slug,
            userIdentifier: identifier,
          },
          {
            users,
            events,
            registrations,
            id: () => crypto.randomUUID(),
          },
        ),
      metadata: (result) => ({
        eventSlug: slug,
        userId: result.user_id,
        actorId: auth.user.id,
      }),
    });

    return hal(
      { ...added },
      {
        self: { href: `/api/v1/events/${slug}/registrations/${added.user_id}` },
        collection: { href: `/api/v1/events/${slug}/registrations` },
      },
    );
  } catch (error) {
    if (error instanceof EventNotFoundError || error instanceof UserNotFoundError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Event or user not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to add registration.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/events/[slug]/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../lib/api/auth";
import { hal, problem } from "../../../../../lib/api/response";
import { eventLinksForState, getEventBySlug } from "../../../../../lib/api/events";
import { resolveConfig } from "../../../../../cli/config";
import { EventNotFoundError, InvalidInputError } from "../../../../../core/domain/errors";
import { SqliteAuditSink } from "../../../../../core/infrastructure/sqlite/audit-sink";
import { SqliteEventRepository } from "../../../../../core/infrastructure/sqlite/repositories";
import { updateEvent as updateEventUseCase } from "../../../../../core/use-cases/update-event";
import { executeWithAudit } from "../../../../../core/use-cases/with-audit";

type RouteContext = {
  params: Promise<{ slug: string }>;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function GET(request: Request, context: RouteContext) {
  const { slug } = await context.params;

  try {
    const found = getEventBySlug(slug);
    return hal({ ...found }, eventLinksForState(found.slug, found.status));
  } catch (error) {
    if (error instanceof EventNotFoundError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Event not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to load event.",
      },
      request,
    );
  }
}

export async function PATCH(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { slug } = await context.params;
  let payload: { title?: string; start?: string; end?: string; capacity?: number };

  try {
    payload = (await request.json()) as {
      title?: string;
      start?: string;
      end?: string;
      capacity?: number;
    };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  const config = resolveConfig({ envVars: process.env });
  const events = new SqliteEventRepository(config);
  const audit = new SqliteAuditSink(config);

  try {
    const updated = executeWithAudit({
      action: "api.event.update",
      requestId: crypto.randomUUID(),
      targetType: "event",
      audit,
      execute: () =>
        updateEventUseCase(
          {
            slug,
            title: payload.title,
            start: payload.start,
            end: payload.end,
            capacity: payload.capacity,
          },
          {
            events,
            now: () => new Date().toISOString(),
          },
        ),
      metadata: () => ({
        slug,
        actorId: auth.user.id,
      }),
    });

    return hal({ ...updated }, eventLinksForState(updated.slug, updated.status));
  } catch (error) {
    if (error instanceof EventNotFoundError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "Event not found.",
        },
        request,
      );
    }

    if (error instanceof InvalidInputError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/invalid-input",
          title: "Bad Request",
          status: 400,
          detail: "Invalid event update payload.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to update event.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/events/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../lib/api/auth";
import { hal, problem } from "../../../../lib/api/response";
import { eventLinksForState, listEvents } from "../../../../lib/api/events";
import { resolveConfig } from "../../../../cli/config";
import { EventAlreadyExistsError, InvalidInputError } from "../../../../core/domain/errors";
import { SqliteAuditSink } from "../../../../core/infrastructure/sqlite/audit-sink";
import { SqliteEventRepository } from "../../../../core/infrastructure/sqlite/repositories";
import { createEvent as createEventUseCase } from "../../../../core/use-cases/create-event";
import { executeWithAudit } from "../../../../core/use-cases/with-audit";

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const status = searchParams.get("status") ?? undefined;
  const q = searchParams.get("q") ?? undefined;
  const from = searchParams.get("from") ?? undefined;
  const to = searchParams.get("to") ?? undefined;
  const limit = searchParams.get("limit");
  const offset = searchParams.get("offset");

  try {
    const result = listEvents({
      status,
      q,
      from,
      to,
      limit: limit ? Number(limit) : undefined,
      offset: offset ? Number(offset) : undefined,
    });

    return hal(
      {
        count: result.count,
        limit: result.limit,
        offset: result.offset,
        items: result.items.map((item) => ({
          ...item,
          _links: eventLinksForState(item.slug, item.status),
        })),
      },
      {
        self: { href: "/api/v1/events" },
      },
    );
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "Invalid event filter input.",
      },
      request,
    );
  }
}

export async function POST(request: Request) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  let payload: {
    slug?: string;
    title?: string;
    start?: string;
    end?: string;
    timezone?: string;
    capacity?: number;
  };

  try {
    payload = (await request.json()) as {
      slug?: string;
      title?: string;
      start?: string;
      end?: string;
      timezone?: string;
      capacity?: number;
    };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.slug || !payload.title || !payload.start || !payload.end || !payload.timezone) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "slug, title, start, end, timezone are required.",
      },
      request,
    );
  }

  const config = resolveConfig({ envVars: process.env });
  const events = new SqliteEventRepository(config);
  const audit = new SqliteAuditSink(config);

  try {
    const created = executeWithAudit({
      action: "api.event.create",
      requestId: crypto.randomUUID(),
      targetType: "event",
      audit,
      execute: () =>
        createEventUseCase(
          {
            slug: payload.slug,
            title: payload.title,
            start: payload.start,
            end: payload.end,
            timezone: payload.timezone,
            capacity: payload.capacity,
            createdBy: auth.user.id,
          },
          {
            events,
            id: () => crypto.randomUUID(),
            now: () => new Date().toISOString(),
          },
        ),
      metadata: (result) => ({
        eventId: result.id,
        slug: result.slug,
        actorId: auth.user.id,
      }),
    });

    return hal(
      { ...created },
      eventLinksForState(created.slug, created.status),
      {
        status: 201,
      },
    );
  } catch (error) {
    if (error instanceof EventAlreadyExistsError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/conflict",
          title: "Conflict",
          status: 409,
          detail: "Event already exists for slug.",
        },
        request,
      );
    }

    if (error instanceof InvalidInputError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/invalid-input",
          title: "Bad Request",
          status: 400,
          detail: "Invalid event payload.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to create event.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/me/route.ts =====
import { getUserFromSession, parseSessionTokenFromCookie } from "../../../../lib/api/auth";
import { hal, problem } from "../../../../lib/api/response";

export async function GET(request: Request) {
  const sessionToken = parseSessionTokenFromCookie(request.headers.get("cookie"));
  if (!sessionToken) {
    return problem(
      {
        type: "https://lms-219.dev/problems/unauthorized",
        title: "Unauthorized",
        status: 401,
        detail: "Active session required.",
      },
      request,
    );
  }

  const user = getUserFromSession(sessionToken);
  if (!user) {
    return problem(
      {
        type: "https://lms-219.dev/problems/unauthorized",
        title: "Unauthorized",
        status: 401,
        detail: "Session is invalid or expired.",
      },
      request,
    );
  }

  const links: Record<string, { href: string }> = {
    self: { href: "/api/v1/me" },
    logout: { href: "/api/v1/auth/logout" },
    events: { href: "/api/v1/events" },
    terms: { href: "/terms" },
    privacy: { href: "/privacy" },
    account_delete: { href: "/api/v1/account/delete" },
  };

  if (user.roles.includes("ADMIN") || user.roles.includes("SUPER_ADMIN")) {
    links.users = { href: "/api/v1/users" };
  }

  return hal(
    {
      id: user.id,
      email: user.email,
      status: user.status,
      roles: user.roles,
    },
    links,
  );
}


===== FILE: src/app/api/v1/route.ts =====
import { hal } from "../../../lib/api/response";

export async function GET() {
  return hal(
    {
      name: "lms_219_api",
      version: "v1",
    },
    {
      self: { href: "/api/v1" },
      docs: { href: "/api/v1/docs" },
      terms: { href: "/terms" },
      privacy: { href: "/privacy" },
      auth_register: { href: "/api/v1/auth/register" },
      auth_login: { href: "/api/v1/auth/login" },
      me: { href: "/api/v1/me" },
      account_delete: { href: "/api/v1/account/delete" },
      events: { href: "/api/v1/events" },
    },
  );
}


===== FILE: src/app/api/v1/users/__tests__/users-api.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";

import { GET as getUsers } from "../route";
import { GET as getUserById, PATCH as patchUserById } from "../[id]/route";
import { POST as postUserRole } from "../[id]/roles/route";
import { DELETE as deleteUserRole } from "../[id]/roles/[role]/route";
import { POST as postLogin } from "../../auth/login/route";
import { POST as postRegister } from "../../auth/register/route";
import { runCli } from "../../../../../cli/run-cli";
import { CliIo } from "../../../../../cli/types";
import { resetRateLimits } from "../../../../../lib/api/rate-limit";

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-api-users-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const runWithDb = async (argv: string[], dbPath: string): Promise<number> => {
  const { io } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return exitCode;
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

const registerAndLogin = async (email: string, password: string): Promise<string> => {
  await postRegister(
    new Request("http://localhost:3000/api/v1/auth/register", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password }),
    }),
  );

  const login = await postLogin(
    new Request("http://localhost:3000/api/v1/auth/login", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        origin: "http://localhost:3000",
      },
      body: JSON.stringify({ email, password }),
    }),
  );

  return (login.headers.get("set-cookie") ?? "").split(";")[0];
};

afterEach(async () => {
  delete process.env.APPCTL_DB_FILE;
  delete process.env.APPCTL_ENV;
  resetRateLimits();
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("api/v1 users", () => {
  it("requires ADMIN role for user listing", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const userCookie = await registerAndLogin("basic-user@example.com", "Password123!");
    const denied = await getUsers(
      new Request("http://localhost:3000/api/v1/users", {
        headers: { cookie: userCookie },
      }),
    );

    expect(denied.status).toBe(403);
    expect((await denied.json()).title).toBe("Forbidden");
  });

  it("supports list and detail retrieval for admin session", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("admin@example.com", "Password123!");
    const db = new Database(dbPath);
    const admin = db.prepare("SELECT id FROM users WHERE email = ?").get("admin@example.com") as {
      id: string;
    };
    const adminRole = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
    db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(admin.id, adminRole.id);
    db.close();

    const listResponse = await getUsers(
      new Request("http://localhost:3000/api/v1/users", {
        headers: { cookie: adminCookie },
      }),
    );
    const listBody = await listResponse.json();

    expect(listResponse.status).toBe(200);
    expect(listBody.count).toBeGreaterThan(0);
    expect(listBody._links.self.href).toBe("/api/v1/users");

    const detailResponse = await getUserById(
      new Request(`http://localhost:3000/api/v1/users/${admin.id}`, {
        headers: { cookie: adminCookie },
      }),
      { params: Promise.resolve({ id: admin.id }) },
    );
    const detailBody = await detailResponse.json();

    expect(detailResponse.status).toBe(200);
    expect(detailBody.id).toBe(admin.id);
    expect(detailBody.roles).toContain("ADMIN");
  });

  it("updates user status and writes audit entry", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("patch-admin@example.com", "Password123!");
    const targetCookie = await registerAndLogin("target-user@example.com", "Password123!");
    expect(targetCookie).toContain("lms_session=");

    const db = new Database(dbPath);
    const admin = db.prepare("SELECT id FROM users WHERE email = ?").get("patch-admin@example.com") as {
      id: string;
    };
    const target = db.prepare("SELECT id FROM users WHERE email = ?").get("target-user@example.com") as {
      id: string;
    };
    const adminRole = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
    db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(admin.id, adminRole.id);
    db.close();

    const patchResponse = await patchUserById(
      new Request(`http://localhost:3000/api/v1/users/${target.id}`, {
        method: "PATCH",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ status: "DISABLED" }),
      }),
      { params: Promise.resolve({ id: target.id }) },
    );

    expect(patchResponse.status).toBe(200);
    const patchBody = await patchResponse.json();
    expect(patchBody.status).toBe("DISABLED");

    const dbAfter = new Database(dbPath);
    const auditCount = dbAfter
      .prepare("SELECT COUNT(*) as count FROM audit_log WHERE action = 'api.user.update'")
      .get() as { count: number };
    dbAfter.close();

    expect(auditCount.count).toBeGreaterThan(0);
  });

  it("adds/removes roles idempotently and blocks SUPER_ADMIN changes", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    process.env.APPCTL_DB_FILE = dbPath;
    process.env.APPCTL_ENV = "local";

    const adminCookie = await registerAndLogin("roles-admin@example.com", "Password123!");
    await registerAndLogin("roles-target@example.com", "Password123!");

    const db = new Database(dbPath);
    const admin = db.prepare("SELECT id FROM users WHERE email = ?").get("roles-admin@example.com") as {
      id: string;
    };
    const target = db.prepare("SELECT id FROM users WHERE email = ?").get("roles-target@example.com") as {
      id: string;
    };
    const adminRole = db.prepare("SELECT id FROM roles WHERE name = 'ADMIN'").get() as { id: string };
    db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(admin.id, adminRole.id);
    db.close();

    const addOne = await postUserRole(
      new Request(`http://localhost:3000/api/v1/users/${target.id}/roles`, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ role: "ADMIN" }),
      }),
      { params: Promise.resolve({ id: target.id }) },
    );
    const addTwo = await postUserRole(
      new Request(`http://localhost:3000/api/v1/users/${target.id}/roles`, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ role: "ADMIN" }),
      }),
      { params: Promise.resolve({ id: target.id }) },
    );

    expect(addOne.status).toBe(200);
    expect(addTwo.status).toBe(200);

    const removeOne = await deleteUserRole(
      new Request(`http://localhost:3000/api/v1/users/${target.id}/roles/ADMIN`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
      }),
      { params: Promise.resolve({ id: target.id, role: "ADMIN" }) },
    );
    const removeTwo = await deleteUserRole(
      new Request(`http://localhost:3000/api/v1/users/${target.id}/roles/ADMIN`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
      }),
      { params: Promise.resolve({ id: target.id, role: "ADMIN" }) },
    );

    expect(removeOne.status).toBe(200);
    expect(removeTwo.status).toBe(200);

    const blockedAdd = await postUserRole(
      new Request(`http://localhost:3000/api/v1/users/${target.id}/roles`, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
        body: JSON.stringify({ role: "SUPER_ADMIN" }),
      }),
      { params: Promise.resolve({ id: target.id }) },
    );

    const blockedRemove = await deleteUserRole(
      new Request(`http://localhost:3000/api/v1/users/${target.id}/roles/SUPER_ADMIN`, {
        method: "DELETE",
        headers: {
          origin: "http://localhost:3000",
          cookie: adminCookie,
        },
      }),
      { params: Promise.resolve({ id: target.id, role: "SUPER_ADMIN" }) },
    );

    expect(blockedAdd.status).toBe(403);
    expect(blockedRemove.status).toBe(403);
  });
});


===== FILE: src/app/api/v1/users/[id]/roles/[role]/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../../../lib/api/auth";
import { hal, problem } from "../../../../../../../lib/api/response";
import {
  removeUserRole,
  SuperAdminRoleForbiddenError,
  UserNotFoundError,
} from "../../../../../../../lib/api/users";

type RouteContext = {
  params: Promise<{ id: string; role: string }>;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function DELETE(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { id, role } = await context.params;

  try {
    const result = removeUserRole(id, role, auth.user.id, crypto.randomUUID());
    return hal(
      {
        user_id: id,
        role: result.role,
        changed: result.changed,
      },
      {
        self: { href: `/api/v1/users/${id}/roles/${role.toUpperCase()}` },
        user: { href: `/api/v1/users/${id}` },
      },
    );
  } catch (error) {
    if (error instanceof SuperAdminRoleForbiddenError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "SUPER_ADMIN role changes are CLI-only.",
        },
        request,
      );
    }

    if (error instanceof UserNotFoundError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "User not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to remove role.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/users/[id]/roles/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../../lib/api/auth";
import { hal, problem } from "../../../../../../lib/api/response";
import {
  addUserRole,
  SuperAdminRoleForbiddenError,
  UserNotFoundError,
} from "../../../../../../lib/api/users";

type RouteContext = {
  params: Promise<{ id: string }>;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function POST(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { id } = await context.params;
  let payload: { role?: string };

  try {
    payload = (await request.json()) as { role?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.role) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "role is required.",
      },
      request,
    );
  }

  try {
    const result = addUserRole(id, payload.role, auth.user.id, crypto.randomUUID());
    return hal(
      {
        user_id: id,
        role: result.role,
        changed: result.changed,
      },
      {
        self: { href: `/api/v1/users/${id}/roles` },
        user: { href: `/api/v1/users/${id}` },
      },
    );
  } catch (error) {
    if (error instanceof SuperAdminRoleForbiddenError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "SUPER_ADMIN role changes are CLI-only.",
        },
        request,
      );
    }

    if (error instanceof UserNotFoundError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "User not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to add role.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/users/[id]/route.ts =====
import { getSessionUserFromRequest, isSameOriginMutation } from "../../../../../lib/api/auth";
import { hal, problem } from "../../../../../lib/api/response";
import {
  getUserById,
  InvalidUserStatusError,
  updateUserStatus,
  UserNotFoundError,
} from "../../../../../lib/api/users";

type RouteContext = {
  params: Promise<{ id: string }>;
};

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function GET(request: Request, context: RouteContext) {
  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { id } = await context.params;

  try {
    const found = getUserById(id);
    return hal(found, {
      self: { href: `/api/v1/users/${id}` },
      roles: { href: `/api/v1/users/${id}/roles` },
    });
  } catch (error) {
    if (error instanceof UserNotFoundError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "User not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to load user.",
      },
      request,
    );
  }
}

export async function PATCH(request: Request, context: RouteContext) {
  if (!isSameOriginMutation(request)) {
    return problem(
      {
        type: "https://lms-219.dev/problems/csrf-check-failed",
        title: "Forbidden",
        status: 403,
        detail: "Cross-origin mutation request rejected.",
      },
      request,
    );
  }

  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { id } = await context.params;
  let payload: { status?: string };

  try {
    payload = (await request.json()) as { status?: string };
  } catch {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-json",
        title: "Bad Request",
        status: 400,
        detail: "Request body must be valid JSON.",
      },
      request,
    );
  }

  if (!payload.status) {
    return problem(
      {
        type: "https://lms-219.dev/problems/invalid-input",
        title: "Bad Request",
        status: 400,
        detail: "status is required.",
      },
      request,
    );
  }

  try {
    const updated = updateUserStatus(id, payload.status, auth.user.id, crypto.randomUUID());
    return hal(updated, {
      self: { href: `/api/v1/users/${id}` },
      roles: { href: `/api/v1/users/${id}/roles` },
    });
  } catch (error) {
    if (error instanceof InvalidUserStatusError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/invalid-input",
          title: "Bad Request",
          status: 400,
          detail: "Invalid status. Allowed: ACTIVE, DISABLED, PENDING.",
        },
        request,
      );
    }

    if (error instanceof UserNotFoundError) {
      return problem(
        {
          type: "https://lms-219.dev/problems/not-found",
          title: "Not Found",
          status: 404,
          detail: "User not found.",
        },
        request,
      );
    }

    return problem(
      {
        type: "https://lms-219.dev/problems/internal",
        title: "Internal Server Error",
        status: 500,
        detail: "Unable to update user.",
      },
      request,
    );
  }
}


===== FILE: src/app/api/v1/users/route.ts =====
import { getSessionUserFromRequest } from "../../../../lib/api/auth";
import { hal, problem } from "../../../../lib/api/response";
import { listUsers } from "../../../../lib/api/users";

const requireAdmin = (request: Request) => {
  const user = getSessionUserFromRequest(request);
  if (!user) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/unauthorized",
          title: "Unauthorized",
          status: 401,
          detail: "Active session required.",
        },
        request,
      ),
    };
  }

  if (!user.roles.includes("ADMIN") && !user.roles.includes("SUPER_ADMIN")) {
    return {
      error: problem(
        {
          type: "https://lms-219.dev/problems/forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Admin role required.",
        },
        request,
      ),
    };
  }

  return { user };
};

export async function GET(request: Request) {
  const auth = requireAdmin(request);
  if (auth.error) {
    return auth.error;
  }

  const { searchParams } = new URL(request.url);
  const role = searchParams.get("role") ?? undefined;
  const status = searchParams.get("status") ?? undefined;
  const search = searchParams.get("search") ?? undefined;
  const limit = searchParams.get("limit");
  const offset = searchParams.get("offset");

  const result = listUsers({
    role,
    status,
    search,
    limit: limit ? Number(limit) : undefined,
    offset: offset ? Number(offset) : undefined,
  });

  return hal(
    {
      count: result.count,
      limit: result.limit,
      offset: result.offset,
      items: result.items,
    },
    {
      self: { href: "/api/v1/users" },
    },
    {
      headers: {
        "cache-control": "no-store",
      },
    },
  );
}


===== FILE: src/app/events/[slug]/page.tsx =====
"use client";

import { useEffect, useState } from "react";
import { useParams } from "next/navigation";
import Link from "next/link";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { follow, getRoot, requestHal, type HalResource, type ProblemDetails } from "@/lib/hal-client";

type EventResource = {
  id: string;
  slug: string;
  title: string;
  status: string;
  timezone: string;
  start_at: string;
  end_at: string;
  _links: Record<string, { href: string }>;
};

type EventListPayload = {
  items: Array<{
    slug: string;
    _links?: Record<string, { href: string }>;
  }>;
};

type MeResponse = {
  id: string;
  email: string;
  _links: Record<string, { href: string }>;
};

type RegistrationsList = {
  items: Array<{
    user_id: string;
    status: "REGISTERED" | "WAITLISTED" | "CANCELLED" | "CHECKED_IN";
  }>;
};

export default function EventDetailPage() {
  const params = useParams<{ slug: string }>();
  const [event, setEvent] = useState<EventResource | null>(null);
  const [me, setMe] = useState<MeResponse | null>(null);
  const [registrationStatus, setRegistrationStatus] = useState<string | null>(null);
  const [actionPending, setActionPending] = useState(false);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);
  const [loading, setLoading] = useState(true);

  const loadRegistrationStatus = async (eventSelfHref: string, userId: string) => {
    const result = await requestHal<RegistrationsList>(`${eventSelfHref}/registrations`);
    if (!result.ok) {
      if (result.problem.status === 404) {
        setRegistrationStatus(null);
        return;
      }
      setProblem(result.problem);
      return;
    }

    const mine = result.data.items.find((item) => item.user_id === userId);
    setRegistrationStatus(mine?.status ?? null);
  };

  useEffect(() => {
    const load = async () => {
      setLoading(true);
      setProblem(null);

      const slug = params.slug;
      if (!slug) {
        setLoading(false);
        return;
      }
      const rootResult = await getRoot();
      if (!rootResult.ok) {
        setProblem(rootResult.problem);
        setLoading(false);
        return;
      }

      const eventsLink = follow(rootResult.data as HalResource, "events");
      if (!eventsLink) {
        setProblem({
          type: "about:blank",
          title: "Events Link Missing",
          status: 500,
          detail: "API root did not provide events affordance.",
        });
        setLoading(false);
        return;
      }

      const collectionResult = await requestHal<EventListPayload>(eventsLink.href);
      let detailHref = `${eventsLink.href}/${slug}`;

      if (collectionResult.ok) {
        const found = collectionResult.data.items?.find((item) => item.slug === slug);
        if (found?._links?.self?.href) {
          detailHref = found._links.self.href;
        }
      }

      const detailResult = await requestHal<EventResource>(detailHref);
      if (!detailResult.ok) {
        setProblem(detailResult.problem);
        setLoading(false);
        return;
      }

      setEvent(detailResult.data);

      const meResult = await requestHal<MeResponse>("/api/v1/me");
      if (meResult.ok) {
        setMe(meResult.data);
        const eventSelfHref = detailResult.data._links.self?.href ?? detailHref;
        await loadRegistrationStatus(eventSelfHref, meResult.data.id);
      } else {
        setMe(null);
        if (meResult.problem.status !== 401) {
          setProblem(meResult.problem);
        }
      }

      setLoading(false);
    };

    void load();
  }, [params.slug]);

  const onRegister = async () => {
    if (!event || !me) {
      return;
    }

    setActionPending(true);
    setProblem(null);

    const endpoint = `${event._links.self?.href ?? `/api/v1/events/${event.slug}`}/registrations`;
    const result = await requestHal<{ status: string }>(endpoint, {
      method: "POST",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify({ user_id: me.id }),
    });

    if (!result.ok) {
      setProblem(result.problem);
      setActionPending(false);
      return;
    }

    setRegistrationStatus(result.data.status);
    setActionPending(false);
  };

  const onCancel = async () => {
    if (!event || !me) {
      return;
    }

    setActionPending(true);
    setProblem(null);

    const endpoint = `${event._links.self?.href ?? `/api/v1/events/${event.slug}`}/registrations/${me.id}`;
    const result = await requestHal<{ status: string }>(endpoint, {
      method: "DELETE",
    });

    if (!result.ok) {
      setProblem(result.problem);
      setActionPending(false);
      return;
    }

    setRegistrationStatus(result.data.status);
    setActionPending(false);
  };

  return (
    <main className="mx-auto max-w-4xl p-6">
      {loading ? <p className="text-sm">Loading event...</p> : null}
      {problem ? <ProblemDetailsPanel problem={problem} /> : null}
      {event ? (
        <article className="space-y-3 rounded-md border p-4">
          <h1 className="text-2xl font-semibold">{event.title}</h1>
          <p className="text-sm">Status: {event.status}</p>
          <p className="text-sm">
            {event.start_at} — {event.end_at} ({event.timezone})
          </p>
          {event._links["app:ics"] ? (
            <p className="text-sm">
              <a href={event._links["app:ics"].href} className="underline">
                Download calendar (.ics)
              </a>
            </p>
          ) : null}

          <div className="rounded-md border p-3">
            <h2 className="text-sm font-medium">Your registration</h2>
            {!me ? (
              <p className="mt-1 text-sm">
                <Link href="/login" className="underline">
                  Login
                </Link>{" "}
                to register.
              </p>
            ) : (
              <div className="mt-2 space-y-2">
                <p className="text-sm">
                  Status: <span className="font-medium">{registrationStatus ?? "NOT_REGISTERED"}</span>
                </p>
                <div className="flex gap-2">
                  {registrationStatus === null || registrationStatus === "CANCELLED" ? (
                    <button
                      type="button"
                      disabled={actionPending}
                      onClick={() => void onRegister()}
                      className="rounded border px-3 py-2 text-sm"
                    >
                      {actionPending ? "Working..." : "Register"}
                    </button>
                  ) : (
                    <button
                      type="button"
                      disabled={actionPending}
                      onClick={() => void onCancel()}
                      className="rounded border px-3 py-2 text-sm"
                    >
                      {actionPending ? "Working..." : "Cancel registration"}
                    </button>
                  )}
                </div>
              </div>
            )}
          </div>

          <div>
            <h2 className="text-sm font-medium">Available actions</h2>
            <ul className="mt-1 list-disc pl-5 text-sm">
              {Object.keys(event._links)
                .filter((rel) => rel.startsWith("app:"))
                .map((rel) => (
                  <li key={rel}>{rel}</li>
                ))}
              {Object.keys(event._links).filter((rel) => rel.startsWith("app:")).length === 0 ? (
                <li>No action links available.</li>
              ) : null}
            </ul>
          </div>
        </article>
      ) : null}
    </main>
  );
}


===== FILE: src/app/events/page.tsx =====
"use client";

import Link from "next/link";
import { useEffect, useState } from "react";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { follow, getRoot, requestHal, type HalResource, type ProblemDetails } from "@/lib/hal-client";

type EventItem = {
  slug: string;
  title: string;
  status: string;
  _links: Record<string, { href: string }>;
};

type EventsPayload = {
  count: number;
  items: EventItem[];
};

export default function EventsPage() {
  const [page, setPage] = useState(1);
  const [searchQuery, setSearchQuery] = useState("");
  const [events, setEvents] = useState<EventItem[]>([]);
  const [queryInput, setQueryInput] = useState("");
  const [loading, setLoading] = useState(true);
  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  useEffect(() => {
    const syncFromUrl = () => {
      const params = new URLSearchParams(window.location.search);
      const nextPage = Math.max(Number(params.get("page") ?? "1") || 1, 1);
      const nextQuery = params.get("q") ?? "";
      setPage(nextPage);
      setSearchQuery(nextQuery);
      setQueryInput(nextQuery);
    };

    syncFromUrl();
    window.addEventListener("popstate", syncFromUrl);
    return () => {
      window.removeEventListener("popstate", syncFromUrl);
    };
  }, []);

  const updateUrlState = (next: { q?: string; page?: string }) => {
    if (typeof window === "undefined") {
      return;
    }

    const params = new URLSearchParams(window.location.search);

    if (next.q !== undefined) {
      const q = next.q.trim();
      if (q.length > 0) {
        params.set("q", q);
      } else {
        params.delete("q");
      }
    }

    if (next.page !== undefined) {
      params.set("page", next.page);
    }

    const query = params.toString();
    const nextUrl = query.length > 0 ? `${window.location.pathname}?${query}` : window.location.pathname;
    window.history.pushState(null, "", nextUrl);
    const updated = new URLSearchParams(window.location.search);
    setPage(Math.max(Number(updated.get("page") ?? "1") || 1, 1));
    setSearchQuery(updated.get("q") ?? "");
  };

  useEffect(() => {
    const load = async () => {
      setLoading(true);
      setProblem(null);

      const rootResult = await getRoot();
      if (!rootResult.ok) {
        setProblem(rootResult.problem);
        setLoading(false);
        return;
      }

      const eventsLink = follow(rootResult.data as HalResource, "events");
      if (!eventsLink) {
        setProblem({
          type: "about:blank",
          title: "Events Link Missing",
          status: 500,
          detail: "API root did not provide events affordance.",
        });
        setLoading(false);
        return;
      }

      const limit = 5;
      const offset = (page - 1) * limit;
      const query = new URLSearchParams({
        limit: String(limit),
        offset: String(offset),
      });
      if (searchQuery.trim().length > 0) {
        query.set("q", searchQuery.trim());
      }

      const eventsResult = await requestHal<EventsPayload>(`${eventsLink.href}?${query.toString()}`);
      if (!eventsResult.ok) {
        setProblem(eventsResult.problem);
        setLoading(false);
        return;
      }

      setEvents(eventsResult.data.items ?? []);
      setLoading(false);
    };

    void load();
  }, [page, searchQuery]);

  return (
    <main className="mx-auto max-w-4xl p-6">
      <h1 className="text-2xl font-semibold">Events</h1>
      <form
        className="mt-4 flex gap-2"
        onSubmit={(event) => {
          event.preventDefault();
          updateUrlState({ q: queryInput, page: "1" });
        }}
      >
        <input
          value={queryInput}
          onChange={(event) => setQueryInput(event.target.value)}
          placeholder="Search title"
          className="w-full rounded border px-3 py-2 text-sm"
        />
        <button type="submit" className="rounded border px-3 py-2 text-sm">
          Search
        </button>
      </form>
      {loading ? <p className="mt-4 text-sm">Loading events...</p> : null}
      {problem ? <div className="mt-4"><ProblemDetailsPanel problem={problem} /></div> : null}
      {!loading && !problem ? (
        <>
          <ul className="mt-4 space-y-3">
            {events.map((event) => (
              <li key={event.slug} className="rounded-md border p-4">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="font-medium">{event.title}</p>
                    <p className="text-sm">Status: {event.status}</p>
                  </div>
                  <Link href={`/events/${event.slug}`} className="text-sm underline">
                    View
                  </Link>
                </div>
              </li>
            ))}
          </ul>
          <div className="mt-4 flex items-center gap-2 text-sm">
            <button
              type="button"
              className="rounded border px-3 py-2"
              disabled={page <= 1}
              onClick={() => updateUrlState({ page: String(page - 1) })}
            >
              Previous
            </button>
            <span>Page {page}</span>
            <button
              type="button"
              className="rounded border px-3 py-2"
              disabled={events.length < 5}
              onClick={() => updateUrlState({ page: String(page + 1) })}
            >
              Next
            </button>
          </div>
        </>
      ) : null}
    </main>
  );
}


===== FILE: src/app/globals.css =====
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}


===== FILE: src/app/layout.tsx =====
import type { Metadata } from "next";
import Link from "next/link";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "LMS 219",
  description: "LMS 219 UI consuming /api/v1 HAL APIs",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <header className="border-b">
          <nav className="mx-auto flex max-w-4xl items-center gap-4 p-4 text-sm">
            <Link href="/">Home</Link>
            <Link href="/events">Events</Link>
            <Link href="/admin">Admin</Link>
          </nav>
        </header>
        {children}
      </body>
    </html>
  );
}


===== FILE: src/app/login/page.tsx =====
"use client";

import Link from "next/link";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { follow, getRoot, requestHal, type HalResource, type ProblemDetails } from "@/lib/hal-client";
import { loginSchema, type LoginFormValues } from "@/lib/auth-forms";

export default function LoginPage() {
  const router = useRouter();
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<LoginFormValues>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: "",
      password: "",
    },
  });

  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  const onSubmit = async (values: LoginFormValues) => {
    setProblem(null);

    const root = await getRoot();
    if (!root.ok) {
      setProblem(root.problem);
      return;
    }

    const loginLink = follow(root.data as HalResource, "auth_login");
    if (!loginLink) {
      setProblem({
        type: "about:blank",
        title: "Login Link Missing",
        status: 500,
        detail: "API root did not include auth_login link.",
      });
      return;
    }

    const result = await requestHal<unknown>(loginLink.href, {
      method: "POST",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify(values),
    });

    if (!result.ok) {
      setProblem(result.problem);
      return;
    }

    router.push("/account");
  };

  return (
    <main className="mx-auto max-w-md p-6">
      <h1 className="text-2xl font-semibold">Login</h1>
      <p className="mt-2 text-sm">Use your account credentials to sign in.</p>

      <form className="mt-4 space-y-3" onSubmit={(event) => void handleSubmit(onSubmit)(event)}>
        <div>
          <label htmlFor="email" className="text-sm font-medium">
            Email
          </label>
          <input id="email" type="email" className="mt-1 w-full rounded border px-3 py-2" {...register("email")} />
          {errors.email ? <p className="mt-1 text-xs text-red-600">{errors.email.message}</p> : null}
        </div>

        <div>
          <label htmlFor="password" className="text-sm font-medium">
            Password
          </label>
          <input
            id="password"
            type="password"
            className="mt-1 w-full rounded border px-3 py-2"
            {...register("password")}
          />
          {errors.password ? <p className="mt-1 text-xs text-red-600">{errors.password.message}</p> : null}
        </div>

        <button type="submit" disabled={isSubmitting} className="rounded border px-3 py-2 text-sm">
          {isSubmitting ? "Signing in..." : "Sign in"}
        </button>
      </form>

      {problem ? (
        <div className="mt-4">
          <ProblemDetailsPanel problem={problem} />
        </div>
      ) : null}

      <p className="mt-4 text-sm">
        Need an account? <Link className="underline" href="/register">Register</Link>
      </p>
      <p className="mt-2 text-xs">
        <Link className="underline" href="/terms">Terms</Link> · <Link className="underline" href="/privacy">Privacy</Link>
      </p>
    </main>
  );
}


===== FILE: src/app/page.tsx =====
import Link from "next/link";

export default function Home() {
  return (
    <main className="mx-auto max-w-4xl p-6">
      <h1 className="text-2xl font-semibold">LMS 219 UI</h1>
      <p className="mt-2 text-sm">Public events are now available through HAL-driven UI screens.</p>
      <div className="mt-4 flex gap-3">
        <Link href="/events" className="rounded-md border px-3 py-2 text-sm">
          Browse Events
        </Link>
      </div>
      <p className="mt-4 text-xs text-zinc-500">Admin pages will be delivered in upcoming sprints.</p>
    </main>
  );
}


===== FILE: src/app/privacy/page.tsx =====
export default function PrivacyPage() {
  return (
    <main className="mx-auto max-w-3xl p-6">
      <h1 className="text-2xl font-semibold">Privacy Policy</h1>
      <p className="mt-3 text-sm">
        LMS 219 processes account and event participation data for service operation and keeps deletion records for retention compliance.
      </p>
    </main>
  );
}


===== FILE: src/app/register/page.tsx =====
"use client";

import Link from "next/link";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { ProblemDetailsPanel } from "@/components/problem-details";
import { follow, getRoot, requestHal, type HalResource, type ProblemDetails } from "@/lib/hal-client";
import { registerSchema, type RegisterFormValues } from "@/lib/auth-forms";

export default function RegisterPage() {
  const router = useRouter();
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<RegisterFormValues>({
    resolver: zodResolver(registerSchema),
    defaultValues: {
      email: "",
      password: "",
      confirmPassword: "",
      termsAccepted: false,
    },
  });

  const [problem, setProblem] = useState<ProblemDetails | null>(null);

  const onSubmit = async (values: RegisterFormValues) => {
    setProblem(null);

    const root = await getRoot();
    if (!root.ok) {
      setProblem(root.problem);
      return;
    }

    const registerLink = follow(root.data as HalResource, "auth_register");
    if (!registerLink) {
      setProblem({
        type: "about:blank",
        title: "Register Link Missing",
        status: 500,
        detail: "API root did not include auth_register link.",
      });
      return;
    }

    const result = await requestHal<unknown>(registerLink.href, {
      method: "POST",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify({
        email: values.email,
        password: values.password,
        terms_accepted: values.termsAccepted,
      }),
    });

    if (!result.ok) {
      setProblem(result.problem);
      return;
    }

    router.push("/login");
  };

  return (
    <main className="mx-auto max-w-md p-6">
      <h1 className="text-2xl font-semibold">Register</h1>
      <p className="mt-2 text-sm">Create a new account.</p>

      <form className="mt-4 space-y-3" onSubmit={(event) => void handleSubmit(onSubmit)(event)}>
        <div>
          <label htmlFor="email" className="text-sm font-medium">
            Email
          </label>
          <input id="email" type="email" className="mt-1 w-full rounded border px-3 py-2" {...register("email")} />
          {errors.email ? <p className="mt-1 text-xs text-red-600">{errors.email.message}</p> : null}
        </div>

        <div>
          <label htmlFor="password" className="text-sm font-medium">
            Password
          </label>
          <input
            id="password"
            type="password"
            className="mt-1 w-full rounded border px-3 py-2"
            {...register("password")}
          />
          {errors.password ? <p className="mt-1 text-xs text-red-600">{errors.password.message}</p> : null}
        </div>

        <div>
          <label className="inline-flex items-center gap-2 text-sm">
            <input type="checkbox" {...register("termsAccepted")} />
            <span>
              I agree to the <Link className="underline" href="/terms">Terms</Link> and <Link className="underline" href="/privacy">Privacy</Link>.
            </span>
          </label>
          {errors.termsAccepted ? <p className="mt-1 text-xs text-red-600">{errors.termsAccepted.message}</p> : null}
        </div>

        <div>
          <label htmlFor="confirmPassword" className="text-sm font-medium">
            Confirm password
          </label>
          <input
            id="confirmPassword"
            type="password"
            className="mt-1 w-full rounded border px-3 py-2"
            {...register("confirmPassword")}
          />
          {errors.confirmPassword ? <p className="mt-1 text-xs text-red-600">{errors.confirmPassword.message}</p> : null}
        </div>

        <button type="submit" disabled={isSubmitting} className="rounded border px-3 py-2 text-sm">
          {isSubmitting ? "Creating account..." : "Create account"}
        </button>
      </form>

      {problem ? (
        <div className="mt-4">
          <ProblemDetailsPanel problem={problem} />
        </div>
      ) : null}

      <p className="mt-4 text-sm">
        Already have an account? <Link className="underline" href="/login">Login</Link>
      </p>
    </main>
  );
}


===== FILE: src/app/terms/page.tsx =====
export default function TermsPage() {
  return (
    <main className="mx-auto max-w-3xl p-6">
      <h1 className="text-2xl font-semibold">Terms of Service</h1>
      <p className="mt-3 text-sm">
        By using LMS 219, you agree to lawful use, account security responsibilities, and service abuse restrictions.
      </p>
    </main>
  );
}


===== FILE: src/cli/__tests__/auth-user.test.ts =====
import { createHash } from "node:crypto";
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";
import { runCli } from "../run-cli";
import { CliIo } from "../types";

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-auth-user-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const runWithDb = async (
  argv: string[],
  dbPath: string,
): Promise<{ exitCode: number; stdout: string; stderr: string }> => {
  const { io, stdout, stderr } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return {
    exitCode,
    stdout: stdout.join(""),
    stderr: stderr.join(""),
  };
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

afterEach(async () => {
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("appctl auth/user", () => {
  it("token create shows token once and stores hash only", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    const create = await runWithDb(["--json", "auth", "token", "create", "--name", "sprint3"], dbPath);
    expect(create.exitCode).toBe(0);

    const payload = JSON.parse(create.stdout);
    const token = payload.data.token as string;
    const tokenId = payload.data.id as string;

    const db = new Database(dbPath);
    const stored = db
      .prepare("SELECT token_hash FROM service_tokens WHERE id = ?")
      .get(tokenId) as { token_hash: string };
    db.close();

    const expectedHash = createHash("sha256").update(token).digest("hex");
    expect(token).not.toBe(stored.token_hash);
    expect(stored.token_hash).toBe(expectedHash);
  });

  it("staging write requires token and revoked token is rejected", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    const unauthorized = await runWithDb(
      ["user", "create", "--email", "no-token@example.com", "--env", "staging"],
      dbPath,
    );
    expect(unauthorized.exitCode).toBe(3);

    const created = await runWithDb(["--json", "auth", "token", "create", "--name", "api"], dbPath);
    const createdPayload = JSON.parse(created.stdout);
    const token = createdPayload.data.token as string;
    const tokenId = createdPayload.data.id as string;

    const withToken = await runWithDb(
      [
        "user",
        "create",
        "--email",
        "with-token@example.com",
        "--status",
        "ACTIVE",
        "--env",
        "staging",
        "--token",
        token,
      ],
      dbPath,
    );
    expect(withToken.exitCode).toBe(0);

    const revoke = await runWithDb(["auth", "token", "revoke", "--id", tokenId], dbPath);
    expect(revoke.exitCode).toBe(0);

    const afterRevoke = await runWithDb(
      ["user", "create", "--email", "revoked@example.com", "--env", "staging", "--token", token],
      dbPath,
    );
    expect(afterRevoke.exitCode).toBe(3);
  });

  it("user create enforces unique email conflict", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    const first = await runWithDb(["user", "create", "--email", "dup@example.com"], dbPath);
    const second = await runWithDb(["user", "create", "--email", "dup@example.com"], dbPath);

    expect(first.exitCode).toBe(0);
    expect(second.exitCode).toBe(5);
  });

  it("role add/remove are idempotent and audited", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    const createUser = await runWithDb(
      ["--json", "user", "create", "--email", "role-user@example.com", "--status", "ACTIVE"],
      dbPath,
    );
    const userId = JSON.parse(createUser.stdout).data.id as string;

    const addOne = await runWithDb(["user", "role", "add", "--id", userId, "--role", "ADMIN"], dbPath);
    const addTwo = await runWithDb(["user", "role", "add", "--id", userId, "--role", "ADMIN"], dbPath);
    const removeOne = await runWithDb(["user", "role", "remove", "--id", userId, "--role", "ADMIN"], dbPath);
    const removeTwo = await runWithDb(["user", "role", "remove", "--id", userId, "--role", "ADMIN"], dbPath);

    expect(addOne.exitCode).toBe(0);
    expect(addTwo.exitCode).toBe(0);
    expect(removeOne.exitCode).toBe(0);
    expect(removeTwo.exitCode).toBe(0);

    const db = new Database(dbPath);
    const userRoleCount = db
      .prepare("SELECT COUNT(*) AS count FROM user_roles WHERE user_id = ?")
      .get(userId) as { count: number };
    const addAuditCount = db
      .prepare("SELECT COUNT(*) AS count FROM audit_log WHERE action = 'user.role.add'")
      .get() as { count: number };
    const removeAuditCount = db
      .prepare("SELECT COUNT(*) AS count FROM audit_log WHERE action = 'user.role.remove'")
      .get() as { count: number };
    db.close();

    expect(userRoleCount.count).toBe(0);
    expect(addAuditCount.count).toBe(2);
    expect(removeAuditCount.count).toBe(2);
  });

  it("returns not-found exit code 4 for missing user", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    const missing = await runWithDb(["user", "disable", "--id", "missing-user-id"], dbPath);
    expect(missing.exitCode).toBe(4);
  });
});


===== FILE: src/cli/__tests__/backup-restore.test.ts =====
import { mkdtemp, rm, stat } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import { afterEach, describe, expect, it } from "vitest";
import { runCli } from "../run-cli";
import { CliIo } from "../types";

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-backup-restore-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const runWithDb = async (
  argv: string[],
  dbPath: string,
): Promise<{ exitCode: number; stdout: string; stderr: string }> => {
  const { io, stdout, stderr } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return {
    exitCode,
    stdout: stdout.join(""),
    stderr: stderr.join(""),
  };
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

afterEach(async () => {
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("appctl backup/restore", () => {
  it("creates backup artifact and restores round-trip locally", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    await runWithDb(["user", "create", "--email", "first@example.com", "--status", "ACTIVE"], dbPath);

    const outDir = await mkdtemp(join(tmpdir(), "appctl-backup-out-"));
    tempDirs.push(outDir);
    const backupPath = join(outDir, "backup.db");

    const backup = await runWithDb(["db", "backup", "--out", backupPath], dbPath);
    expect(backup.exitCode).toBe(0);

    const backupStat = await stat(backupPath);
    expect(backupStat.size).toBeGreaterThan(0);

    await runWithDb(["user", "create", "--email", "second@example.com", "--status", "ACTIVE"], dbPath);

    const restoreWithoutYes = await runWithDb(["db", "restore", "--from", backupPath], dbPath);
    expect(restoreWithoutYes.exitCode).toBe(6);

    const restore = await runWithDb(["db", "restore", "--from", backupPath, "--yes"], dbPath);
    expect(restore.exitCode).toBe(0);

    const users = await runWithDb(["--json", "user", "list"], dbPath);
    const payload = JSON.parse(users.stdout);
    const emails = payload.data.map((user: { email: string }) => user.email);

    expect(emails).toContain("first@example.com");
    expect(emails).not.toContain("second@example.com");
  });

  it("enforces prod dangerous-op guardrails for backup and restore", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    const outDir = await mkdtemp(join(tmpdir(), "appctl-prod-guard-"));
    tempDirs.push(outDir);
    const backupPath = join(outDir, "backup.db");

    const prodBackupNoForce = await runWithDb(
      ["db", "backup", "--out", backupPath, "--env", "prod", "--yes"],
      dbPath,
    );
    expect(prodBackupNoForce.exitCode).toBe(6);

    const prodBackupNoToken = await runWithDb(
      ["db", "backup", "--out", backupPath, "--env", "prod", "--yes", "--force-prod"],
      dbPath,
    );
    expect(prodBackupNoToken.exitCode).toBe(3);

    const tokenCreate = await runWithDb(["--json", "auth", "token", "create", "--name", "prod-guard"], dbPath);
    const token = JSON.parse(tokenCreate.stdout).data.token as string;

    const prodBackupWithToken = await runWithDb(
      [
        "db",
        "backup",
        "--out",
        backupPath,
        "--env",
        "prod",
        "--yes",
        "--force-prod",
        "--token",
        token,
      ],
      dbPath,
    );
    expect(prodBackupWithToken.exitCode).toBe(0);

    const prodRestoreNoForce = await runWithDb(
      ["db", "restore", "--from", backupPath, "--env", "prod", "--yes", "--token", token],
      dbPath,
    );
    expect(prodRestoreNoForce.exitCode).toBe(6);

    const prodRestoreNoToken = await runWithDb(
      ["db", "restore", "--from", backupPath, "--env", "prod", "--yes", "--force-prod"],
      dbPath,
    );
    expect(prodRestoreNoToken.exitCode).toBe(3);

    const prodRestoreWithToken = await runWithDb(
      [
        "db",
        "restore",
        "--from",
        backupPath,
        "--env",
        "prod",
        "--yes",
        "--force-prod",
        "--token",
        token,
      ],
      dbPath,
    );
    expect(prodRestoreWithToken.exitCode).toBe(0);
  });
});


===== FILE: src/cli/__tests__/db-core.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";
import { runCli } from "../run-cli";
import { CliIo } from "../types";

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-db-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const runWithDb = async (
  argv: string[],
  dbPath: string,
): Promise<{ exitCode: number; stdout: string; stderr: string }> => {
  const { io, stdout, stderr } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return {
    exitCode,
    stdout: stdout.join(""),
    stderr: stderr.join(""),
  };
};

afterEach(async () => {
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("appctl db core", () => {
  it("migrate is idempotent", async () => {
    const dbPath = await createDbPath();

    const first = await runWithDb(["--json", "db", "migrate"], dbPath);
    const second = await runWithDb(["--json", "db", "migrate"], dbPath);
    const status = await runWithDb(["--json", "db", "status"], dbPath);

    expect(first.exitCode).toBe(0);
    expect(second.exitCode).toBe(0);

    const secondPayload = JSON.parse(second.stdout);
    expect(secondPayload.data.applied).toEqual([]);

    const statusPayload = JSON.parse(status.stdout);
    expect(statusPayload.data.pendingCount).toBe(0);
  });

  it("seed is idempotent", async () => {
    const dbPath = await createDbPath();
    await runWithDb(["db", "migrate"], dbPath);

    const first = await runWithDb(["--json", "db", "seed"], dbPath);
    const second = await runWithDb(["--json", "db", "seed"], dbPath);

    expect(first.exitCode).toBe(0);
    expect(second.exitCode).toBe(0);

    const db = new Database(dbPath);
    const count = db.prepare("SELECT COUNT(*) AS count FROM roles").get() as { count: number };
    db.close();

    expect(count.count).toBe(3);
  });

  it("seed fails with precondition when migrations are pending", async () => {
    const dbPath = await createDbPath();

    const result = await runWithDb(["db", "seed"], dbPath);

    expect(result.exitCode).toBe(6);
    expect(result.stderr).toContain("Migrations are pending");
  });

  it("doctor fails when schema is not current", async () => {
    const dbPath = await createDbPath();

    const result = await runWithDb(["doctor"], dbPath);

    expect(result.exitCode).toBe(6);
    expect(result.stderr).toContain("Schema is not up to date");
  });

  it("doctor detects invalid sqlite pragmas", async () => {
    const dbPath = await createDbPath();
    await runWithDb(["db", "migrate"], dbPath);

    const db = new Database(dbPath);
    db.pragma("journal_mode = DELETE");
    db.close();

    const result = await runWithDb(["doctor"], dbPath);

    expect(result.exitCode).toBe(6);
    expect(result.stderr).toContain("SQLite pragmas invalid");
  });

  it("seed fails closed when audit insert fails and roles are rolled back", async () => {
    const dbPath = await createDbPath();
    await runWithDb(["db", "migrate"], dbPath);

    const db = new Database(dbPath);
    db.exec("DROP TABLE audit_log");
    db.close();

    const result = await runWithDb(["db", "seed"], dbPath);
    expect(result.exitCode).toBe(1);

    const check = new Database(dbPath);
    const roles = check.prepare("SELECT COUNT(*) AS count FROM roles").get() as { count: number };
    check.close();

    expect(roles.count).toBe(0);
  });
});


===== FILE: src/cli/__tests__/event.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";
import { runCli } from "../run-cli";
import { CliIo } from "../types";

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-event-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const runWithDb = async (
  argv: string[],
  dbPath: string,
): Promise<{ exitCode: number; stdout: string; stderr: string }> => {
  const { io, stdout, stderr } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return {
    exitCode,
    stdout: stdout.join(""),
    stderr: stderr.join(""),
  };
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

afterEach(async () => {
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("appctl event lifecycle", () => {
  it("event create validates ISO inputs and enforces unique slug", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    const bad = await runWithDb(
      [
        "event",
        "create",
        "--slug",
        "spring-launch",
        "--title",
        "Spring Launch",
        "--start",
        "invalid-date",
        "--end",
        "2026-04-01T15:00:00Z",
        "--tz",
        "UTC",
      ],
      dbPath,
    );

    const first = await runWithDb(
      [
        "event",
        "create",
        "--slug",
        "spring-launch",
        "--title",
        "Spring Launch",
        "--start",
        "2026-04-01T14:00:00Z",
        "--end",
        "2026-04-01T15:00:00Z",
        "--tz",
        "UTC",
      ],
      dbPath,
    );

    const duplicate = await runWithDb(
      [
        "event",
        "create",
        "--slug",
        "spring-launch",
        "--title",
        "Duplicate",
        "--start",
        "2026-04-01T14:00:00Z",
        "--end",
        "2026-04-01T15:00:00Z",
        "--tz",
        "UTC",
      ],
      dbPath,
    );

    expect(bad.exitCode).toBe(2);
    expect(first.exitCode).toBe(0);
    expect(duplicate.exitCode).toBe(5);
  });

  it("event update changes only provided fields", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    await runWithDb(
      [
        "event",
        "create",
        "--slug",
        "update-test",
        "--title",
        "Before",
        "--start",
        "2026-04-01T14:00:00Z",
        "--end",
        "2026-04-01T15:00:00Z",
        "--tz",
        "UTC",
      ],
      dbPath,
    );

    const update = await runWithDb(
      ["--json", "event", "update", "--slug", "update-test", "--title", "After"],
      dbPath,
    );

    expect(update.exitCode).toBe(0);
    const payload = JSON.parse(update.stdout);
    expect(payload.data.title).toBe("After");
    expect(payload.data.start_at).toBe("2026-04-01T14:00:00.000Z");
    expect(payload.data.end_at).toBe("2026-04-01T15:00:00.000Z");
  });

  it("event publish is idempotent and audited", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    await runWithDb(
      [
        "event",
        "create",
        "--slug",
        "publish-test",
        "--title",
        "Publish Test",
        "--start",
        "2026-04-01T14:00:00Z",
        "--end",
        "2026-04-01T15:00:00Z",
        "--tz",
        "UTC",
      ],
      dbPath,
    );

    const first = await runWithDb(["event", "publish", "--slug", "publish-test"], dbPath);
    const second = await runWithDb(["event", "publish", "--slug", "publish-test"], dbPath);

    expect(first.exitCode).toBe(0);
    expect(second.exitCode).toBe(0);

    const db = new Database(dbPath);
    const eventRow = db.prepare("SELECT status FROM events WHERE slug = 'publish-test'").get() as {
      status: string;
    };
    const auditCount = db
      .prepare("SELECT COUNT(*) AS count FROM audit_log WHERE action = 'event.publish'")
      .get() as { count: number };
    db.close();

    expect(eventRow.status).toBe("PUBLISHED");
    expect(auditCount.count).toBe(2);
  });

  it("event cancel sets CANCELLED and stores reason metadata", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    await runWithDb(
      [
        "event",
        "create",
        "--slug",
        "cancel-test",
        "--title",
        "Cancel Test",
        "--start",
        "2026-04-01T14:00:00Z",
        "--end",
        "2026-04-01T15:00:00Z",
        "--tz",
        "UTC",
      ],
      dbPath,
    );

    const cancel = await runWithDb(
      ["event", "cancel", "--slug", "cancel-test", "--reason", "verification"],
      dbPath,
    );

    expect(cancel.exitCode).toBe(0);

    const db = new Database(dbPath);
    const eventRow = db.prepare("SELECT status FROM events WHERE slug = 'cancel-test'").get() as {
      status: string;
    };
    const auditMeta = db
      .prepare("SELECT metadata FROM audit_log WHERE action = 'event.cancel' ORDER BY created_at DESC LIMIT 1")
      .get() as { metadata: string };
    db.close();

    expect(eventRow.status).toBe("CANCELLED");
    expect(JSON.parse(auditMeta.metadata).reason).toBe("verification");
  });

  it("event list supports status and date filters", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);

    await runWithDb(
      [
        "event",
        "create",
        "--slug",
        "list-one",
        "--title",
        "List One",
        "--start",
        "2026-04-01T14:00:00Z",
        "--end",
        "2026-04-01T15:00:00Z",
        "--tz",
        "UTC",
      ],
      dbPath,
    );
    await runWithDb(
      [
        "event",
        "create",
        "--slug",
        "list-two",
        "--title",
        "List Two",
        "--start",
        "2026-05-01T14:00:00Z",
        "--end",
        "2026-05-01T15:00:00Z",
        "--tz",
        "UTC",
      ],
      dbPath,
    );

    await runWithDb(["event", "cancel", "--slug", "list-two", "--reason", "verification"], dbPath);

    const filtered = await runWithDb(
      ["--json", "event", "list", "--status", "CANCELLED", "--from", "2026-04-15T00:00:00Z"],
      dbPath,
    );

    expect(filtered.exitCode).toBe(0);
    const payload = JSON.parse(filtered.stdout);
    expect(payload.data).toHaveLength(1);
    expect(payload.data[0].slug).toBe("list-two");
    expect(payload.data[0].status).toBe("CANCELLED");
  });
});


===== FILE: src/cli/__tests__/registration-export.test.ts =====
import { mkdtemp, readFile, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import Database from "better-sqlite3";
import { afterEach, describe, expect, it } from "vitest";
import { runCli } from "../run-cli";
import { CliIo } from "../types";

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-reg-export-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const runWithDb = async (
  argv: string[],
  dbPath: string,
): Promise<{ exitCode: number; stdout: string; stderr: string }> => {
  const { io, stdout, stderr } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return {
    exitCode,
    stdout: stdout.join(""),
    stderr: stderr.join(""),
  };
};

const setupBase = async (dbPath: string): Promise<void> => {
  await runWithDb(["db", "migrate"], dbPath);
  await runWithDb(["db", "seed"], dbPath);
};

const setupUsersAndEvent = async (dbPath: string): Promise<void> => {
  await runWithDb(["user", "create", "--email", "admin@example.com", "--status", "ACTIVE"], dbPath);
  await runWithDb(["user", "create", "--email", "guest@example.com", "--status", "ACTIVE"], dbPath);
  await runWithDb(
    [
      "event",
      "create",
      "--slug",
      "spring-launch",
      "--title",
      "Spring Launch",
      "--start",
      "2026-04-01T14:00:00Z",
      "--end",
      "2026-04-01T15:00:00Z",
      "--tz",
      "UTC",
      "--capacity",
      "1",
    ],
    dbPath,
  );
};

afterEach(async () => {
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("appctl registration/export", () => {
  it("full events place new registrations in WAITLISTED", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    await setupUsersAndEvent(dbPath);

    const first = await runWithDb(["--json", "reg", "add", "--event", "spring-launch", "--user", "admin@example.com"], dbPath);
    const second = await runWithDb(["--json", "reg", "add", "--event", "spring-launch", "--user", "guest@example.com"], dbPath);

    expect(first.exitCode).toBe(0);
    expect(second.exitCode).toBe(0);

    expect(JSON.parse(first.stdout).data.status).toBe("REGISTERED");
    expect(JSON.parse(second.stdout).data.status).toBe("WAITLISTED");
  });

  it("reg remove transitions to CANCELLED without hard delete", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    await setupUsersAndEvent(dbPath);

    await runWithDb(["reg", "add", "--event", "spring-launch", "--user", "admin@example.com"], dbPath);
    const removed = await runWithDb(
      ["--json", "reg", "remove", "--event", "spring-launch", "--user", "admin@example.com", "--reason", "test"],
      dbPath,
    );

    expect(removed.exitCode).toBe(0);
    expect(JSON.parse(removed.stdout).data.status).toBe("CANCELLED");

    const db = new Database(dbPath);
    const count = db.prepare("SELECT COUNT(*) AS count FROM event_registrations").get() as { count: number };
    db.close();

    expect(count.count).toBe(1);
  });

  it("checkin transitions registration to CHECKED_IN", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    await setupUsersAndEvent(dbPath);

    await runWithDb(["reg", "add", "--event", "spring-launch", "--user", "admin@example.com"], dbPath);
    const checkedIn = await runWithDb(
      ["--json", "checkin", "--event", "spring-launch", "--user", "admin@example.com"],
      dbPath,
    );

    expect(checkedIn.exitCode).toBe(0);
    expect(JSON.parse(checkedIn.stdout).data.status).toBe("CHECKED_IN");
  });

  it("event export writes csv and json files", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    await setupUsersAndEvent(dbPath);

    await runWithDb(["reg", "add", "--event", "spring-launch", "--user", "admin@example.com"], dbPath);

    const outDir = await mkdtemp(join(tmpdir(), "appctl-export-out-"));
    tempDirs.push(outDir);
    const csvOut = join(outDir, "spring-launch.csv");
    const jsonOut = join(outDir, "spring-launch.json");

    const csv = await runWithDb(
      ["event", "export", "--slug", "spring-launch", "--format", "csv", "--out", csvOut],
      dbPath,
    );
    const json = await runWithDb(
      ["event", "export", "--slug", "spring-launch", "--format", "json", "--out", jsonOut],
      dbPath,
    );

    expect(csv.exitCode).toBe(0);
    expect(json.exitCode).toBe(0);

    const csvContent = await readFile(csvOut, "utf8");
    const jsonContent = await readFile(jsonOut, "utf8");

    expect(csvContent).toContain("id,status,user_id");
    expect(JSON.parse(jsonContent)).toHaveLength(1);
  });

  it("include-email requires token outside local and mutations are audited", async () => {
    const dbPath = await createDbPath();
    await setupBase(dbPath);
    await setupUsersAndEvent(dbPath);

    await runWithDb(["reg", "add", "--event", "spring-launch", "--user", "admin@example.com"], dbPath);

    const outDir = await mkdtemp(join(tmpdir(), "appctl-export-sec-"));
    tempDirs.push(outDir);
    const secureOut = join(outDir, "secure.json");

    const withoutToken = await runWithDb(
      [
        "event",
        "export",
        "--slug",
        "spring-launch",
        "--format",
        "json",
        "--out",
        secureOut,
        "--include-email",
        "--env",
        "staging",
      ],
      dbPath,
    );
    expect(withoutToken.exitCode).toBe(3);

    const created = await runWithDb(["--json", "auth", "token", "create", "--name", "exp"], dbPath);
    const token = JSON.parse(created.stdout).data.token as string;

    const withToken = await runWithDb(
      [
        "event",
        "export",
        "--slug",
        "spring-launch",
        "--format",
        "json",
        "--out",
        secureOut,
        "--include-email",
        "--env",
        "staging",
        "--token",
        token,
      ],
      dbPath,
    );

    expect(withToken.exitCode).toBe(0);
    const exported = JSON.parse(await readFile(secureOut, "utf8"));
    expect(exported[0].user_email).toBe("admin@example.com");

    const checkin = await runWithDb(["checkin", "--event", "spring-launch", "--user", "admin@example.com"], dbPath);
    expect(checkin.exitCode).toBe(0);

    const db = new Database(dbPath);
    const addAudit = db
      .prepare("SELECT COUNT(*) AS count FROM audit_log WHERE action = 'registration.add'")
      .get() as { count: number };
    const checkinAudit = db
      .prepare("SELECT COUNT(*) AS count FROM audit_log WHERE action = 'registration.checkin'")
      .get() as { count: number };
    const exportAudit = db
      .prepare("SELECT COUNT(*) AS count FROM audit_log WHERE action = 'event.export'")
      .get() as { count: number };
    db.close();

    expect(addAudit.count).toBeGreaterThan(0);
    expect(checkinAudit.count).toBeGreaterThan(0);
    expect(exportAudit.count).toBeGreaterThan(0);
  });
});


===== FILE: src/cli/__tests__/run-cli.test.ts =====
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import { afterEach, describe, expect, it } from "vitest";
import { resolveConfig } from "../config";
import { mapErrorToExitCode, runCli } from "../run-cli";
import { CliIo } from "../types";

const createIo = (): { io: CliIo; stdout: string[]; stderr: string[] } => {
  const stdout: string[] = [];
  const stderr: string[] = [];

  return {
    io: {
      writeStdout: (message: string) => {
        stdout.push(message);
      },
      writeStderr: (message: string) => {
        stderr.push(message);
      },
    },
    stdout,
    stderr,
  };
};

const tempDirs: string[] = [];

const createDbPath = async (): Promise<string> => {
  const directory = await mkdtemp(join(tmpdir(), "appctl-test-"));
  tempDirs.push(directory);
  return join(directory, "app.db");
};

const runWithDb = async (
  argv: string[],
  dbPath: string,
): Promise<{ exitCode: number; stdout: string; stderr: string }> => {
  const { io, stdout, stderr } = createIo();
  const previousDbPath = process.env.APPCTL_DB_FILE;

  process.env.APPCTL_DB_FILE = dbPath;
  const exitCode = await runCli(argv, io);

  if (previousDbPath === undefined) {
    delete process.env.APPCTL_DB_FILE;
  } else {
    process.env.APPCTL_DB_FILE = previousDbPath;
  }

  return {
    exitCode,
    stdout: stdout.join(""),
    stderr: stderr.join(""),
  };
};

afterEach(async () => {
  await Promise.all(tempDirs.splice(0).map((dir) => rm(dir, { recursive: true, force: true })));
});

describe("appctl foundation", () => {
  it("matches help snapshot", async () => {
    const { io, stdout } = createIo();
    const exitCode = await runCli(["--help"], io);

    expect(exitCode).toBe(0);
    expect(stdout.join("")).toMatchSnapshot();
  });

  it("returns JSON envelope for doctor", async () => {
    const dbPath = await createDbPath();
    await runWithDb(["db", "migrate"], dbPath);

    const { exitCode, stdout } = await runWithDb(["--json", "--env", "local", "doctor"], dbPath);

    expect(exitCode).toBe(0);

    const payload = JSON.parse(stdout);
    expect(payload).toMatchObject({
      ok: true,
      command: "doctor",
      env: "local",
      warnings: [],
      errors: [],
    });
    expect(typeof payload.request_id).toBe("string");
  });

  it("applies config precedence flags > env > file > defaults", () => {
    const config = resolveConfig({
      fileConfig: {
        env: "staging",
        output: {
          defaultFormat: "text",
        },
      },
      envVars: {
        APPCTL_ENV: "prod",
        APPCTL_OUTPUT_FORMAT: "text",
      },
      flags: {
        env: "local",
        json: true,
      },
    });

    expect(config.env).toBe("local");
    expect(config.output.defaultFormat).toBe("json");
  });

  it("returns usage error exit code 2 for invalid env", async () => {
    const { io } = createIo();
    const exitCode = await runCli(["--env", "qa", "doctor"], io);

    expect(exitCode).toBe(2);
  });

  it("maps unexpected errors to exit code 1", () => {
    expect(mapErrorToExitCode(new Error("boom"))).toBe(1);
  });
});



===== FILE: src/cli/auth-users-repository.ts =====
import Database from "better-sqlite3";
import { appendServiceAudit, openCliDb } from "./repository-helpers";
import { AppConfig } from "./types";

export interface UserRecord {
  id: string;
  email: string;
  status: string;
  created_at: string;
  updated_at: string;
}

export class DuplicateUserEmailError extends Error {
  constructor(public readonly email: string) {
    super(`Duplicate user email: ${email}`);
    this.name = "DuplicateUserEmailError";
  }
}

const appendAudit = (
  db: Database.Database,
  action: string,
  requestId: string,
  metadata?: Record<string, unknown>,
): void => {
  appendServiceAudit(db, {
    action,
    requestId,
    targetType: "system",
    metadata,
  });
};

export const createServiceToken = (
  config: AppConfig,
  args: {
    id: string;
    name: string;
    tokenHash: string;
    createdAt: string;
    requestId: string;
    ttlDays?: number;
  },
): void => {
  const db = openCliDb(config);
  try {
    const run = db.transaction(() => {
      db.prepare(
        "INSERT INTO service_tokens (id, name, token_hash, created_at, revoked_at, last_used_at) VALUES (?, ?, ?, ?, NULL, NULL)",
      ).run(args.id, args.name, args.tokenHash, args.createdAt);

      appendAudit(db, "auth.token.create", args.requestId, {
        tokenId: args.id,
        name: args.name,
        ttlDays: args.ttlDays ?? null,
      });
    });

    run();
  } finally {
    db.close();
  }
};

export const revokeServiceToken = (
  config: AppConfig,
  args: {
    id: string;
    revokedAt: string;
    requestId: string;
  },
): boolean => {
  const db = openCliDb(config);
  try {
    let changed = 0;

    const run = db.transaction(() => {
      const result = db
        .prepare("UPDATE service_tokens SET revoked_at = ? WHERE id = ? AND revoked_at IS NULL")
        .run(args.revokedAt, args.id);
      changed = result.changes;

      if (changed > 0) {
        appendAudit(db, "auth.token.revoke", args.requestId, {
          tokenId: args.id,
        });
      }
    });

    run();

    return changed > 0;
  } finally {
    db.close();
  }
};

export const createUser = (
  config: AppConfig,
  args: {
    id: string;
    email: string;
    status: string;
    createdAt: string;
    updatedAt: string;
    requestId: string;
  },
): void => {
  const db = openCliDb(config);
  try {
    const run = db.transaction(() => {
      try {
        db.prepare("INSERT INTO users (id, email, status, created_at, updated_at) VALUES (?, ?, ?, ?, ?)").run(
          args.id,
          args.email,
          args.status,
          args.createdAt,
          args.updatedAt,
        );
      } catch (error) {
        if (error instanceof Error && error.message.includes("UNIQUE constraint failed: users.email")) {
          throw new DuplicateUserEmailError(args.email);
        }
        throw error;
      }

      appendAudit(db, "user.create", args.requestId, {
        userId: args.id,
        email: args.email,
      });
    });

    run();
  } finally {
    db.close();
  }
};

export const listUsers = (
  config: AppConfig,
  filters: { role?: string; status?: string; search?: string },
): UserRecord[] => {
  const db = openCliDb(config);
  try {
    const params: unknown[] = [];
    const clauses: string[] = [];
    const joins: string[] = [];

    if (filters.role) {
      joins.push("JOIN user_roles ur ON ur.user_id = u.id JOIN roles r ON r.id = ur.role_id");
      clauses.push("r.name = ?");
      params.push(filters.role.toUpperCase());
    }

    if (filters.status) {
      clauses.push("u.status = ?");
      params.push(filters.status.toUpperCase());
    }

    if (filters.search) {
      clauses.push("u.email LIKE ?");
      params.push(`%${filters.search}%`);
    }

    const query = `
SELECT DISTINCT u.id, u.email, u.status, u.created_at, u.updated_at
FROM users u
${joins.join(" ")}
${clauses.length ? `WHERE ${clauses.join(" AND ")}` : ""}
ORDER BY u.created_at ASC
`;

    return db.prepare(query).all(...params) as UserRecord[];
  } finally {
    db.close();
  }
};

export const findUserById = (config: AppConfig, id: string): UserRecord | undefined => {
  const db = openCliDb(config);
  try {
    return db.prepare("SELECT id, email, status, created_at, updated_at FROM users WHERE id = ?").get(id) as
      | UserRecord
      | undefined;
  } finally {
    db.close();
  }
};

export const findUserByEmail = (config: AppConfig, email: string): UserRecord | undefined => {
  const db = openCliDb(config);
  try {
    return db.prepare("SELECT id, email, status, created_at, updated_at FROM users WHERE email = ?").get(email) as
      | UserRecord
      | undefined;
  } finally {
    db.close();
  }
};

export const updateUserStatus = (
  config: AppConfig,
  args: {
    id: string;
    status: "ACTIVE" | "DISABLED";
    updatedAt: string;
    action: "user.enable" | "user.disable";
    requestId: string;
    reason?: string;
  },
): boolean => {
  const db = openCliDb(config);
  try {
    let changed = 0;

    const run = db.transaction(() => {
      const result = db.prepare("UPDATE users SET status = ?, updated_at = ? WHERE id = ?").run(args.status, args.updatedAt, args.id);
      changed = result.changes;

      if (changed > 0) {
        appendAudit(db, args.action, args.requestId, {
          userId: args.id,
          reason: args.reason ?? null,
        });
      }
    });

    run();

    return changed > 0;
  } finally {
    db.close();
  }
};

export const hasUser = (config: AppConfig, userId: string): boolean => {
  const db = openCliDb(config);
  try {
    const found = db.prepare("SELECT id FROM users WHERE id = ?").get(userId) as { id: string } | undefined;
    return Boolean(found);
  } finally {
    db.close();
  }
};

export const findRoleIdByName = (config: AppConfig, role: string): string | undefined => {
  const db = openCliDb(config);
  try {
    const row = db.prepare("SELECT id FROM roles WHERE name = ?").get(role) as { id: string } | undefined;
    return row?.id;
  } finally {
    db.close();
  }
};

export const addUserRole = (
  config: AppConfig,
  args: {
    userId: string;
    roleId: string;
    roleName: string;
    requestId: string;
  },
): void => {
  const db = openCliDb(config);
  try {
    const run = db.transaction(() => {
      db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(args.userId, args.roleId);

      appendAudit(db, "user.role.add", args.requestId, {
        userId: args.userId,
        role: args.roleName,
      });
    });

    run();
  } finally {
    db.close();
  }
};

export const removeUserRole = (
  config: AppConfig,
  args: {
    userId: string;
    roleId: string;
    roleName: string;
    requestId: string;
  },
): void => {
  const db = openCliDb(config);
  try {
    const run = db.transaction(() => {
      db.prepare("DELETE FROM user_roles WHERE user_id = ? AND role_id = ?").run(args.userId, args.roleId);

      appendAudit(db, "user.role.remove", args.requestId, {
        userId: args.userId,
        role: args.roleName,
      });
    });

    run();
  } finally {
    db.close();
  }
};


===== FILE: src/cli/auth-users.ts =====
import { randomUUID } from "node:crypto";
import {
  addUserRole,
  createServiceToken,
  findRoleIdByName,
  findUserByEmail,
  findUserById,
  hasUser,
  listUsers,
  removeUserRole,
  revokeServiceToken,
  updateUserStatus,
  UserRecord,
} from "./auth-users-repository";
import { conflictError, notFoundError, preconditionError, usageError } from "./errors";
import { SqliteAuditSink } from "../core/infrastructure/sqlite/audit-sink";
import { SqliteUserRepository } from "../core/infrastructure/sqlite/repositories";
import { UserAlreadyExistsError } from "../core/domain/errors";
import { executeWithAudit } from "../core/use-cases/with-audit";
import { registerUser } from "../core/use-cases/register-user";
import { requireSchemaCurrent } from "./schema-guard";
import { AppConfig } from "./types";
import { hashToken, requireWriteAuth } from "./write-auth";

export interface CreateTokenResult {
  id: string;
  name: string;
  token: string;
}

export const authTokenCreate = (
  config: AppConfig,
  requestId: string,
  name: string,
  ttlDays?: number,
): CreateTokenResult => {
  requireSchemaCurrent(config);

  if (!name.trim()) {
    throw usageError("Token name is required.");
  }

  const token = `sat_${randomUUID().replace(/-/g, "")}`;
  const tokenHash = hashToken(token);
  const id = randomUUID();
  createServiceToken(config, {
    id,
    name,
    tokenHash,
    createdAt: new Date().toISOString(),
    requestId,
    ttlDays,
  });

  return {
    id,
    name,
    token,
  };
};

export interface RevokeTokenResult {
  id: string;
  revoked: boolean;
}

export const authTokenRevoke = (config: AppConfig, requestId: string, id: string): RevokeTokenResult => {
  requireSchemaCurrent(config);

  const revoked = revokeServiceToken(config, {
    id,
    revokedAt: new Date().toISOString(),
    requestId,
  });

  if (!revoked) {
    throw notFoundError(`Token not found or already revoked: ${id}`);
  }

  return {
    id,
    revoked: true,
  };
};

const normalizeStatus = (status?: string): string => {
  if (!status) {
    return "PENDING";
  }

  const upper = status.toUpperCase();
  if (!["ACTIVE", "DISABLED", "PENDING"].includes(upper)) {
    throw usageError("Invalid status. Allowed: PENDING, ACTIVE, DISABLED.");
  }

  return upper;
};

export const userCreate = (
  config: AppConfig,
  requestId: string,
  email: string,
  status: string | undefined,
  token?: string,
): UserRecord => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const normalizedStatus = normalizeStatus(status);
  const users = new SqliteUserRepository(config);
  const audit = new SqliteAuditSink(config);

  try {
    const created = executeWithAudit({
      action: "user.create",
      requestId,
      targetType: "system",
      audit,
      execute: () =>
        registerUser(
          {
            email,
            status: normalizedStatus,
          },
          {
            users,
            now: () => new Date().toISOString(),
            id: () => randomUUID(),
          },
        ),
      metadata: (result) => ({
        userId: result.id,
        email: result.email,
      }),
    });

    return created;
  } catch (error) {
    if (error instanceof UserAlreadyExistsError) {
      throw conflictError(`User already exists for email: ${error.email}`);
    }
    if (error instanceof Error && error.message === "Email is required.") {
      throw usageError("Email is required.");
    }
    throw error;
  }
};

export const userList = (
  config: AppConfig,
  filters: { role?: string; status?: string; search?: string },
): UserRecord[] => {
  requireSchemaCurrent(config);
  return listUsers(config, filters);
};

export const userShow = (config: AppConfig, options: { id?: string; email?: string }): UserRecord => {
  requireSchemaCurrent(config);

  if (!options.id && !options.email) {
    throw usageError("Provide --id or --email.");
  }

  const row = options.id ? findUserById(config, options.id) : findUserByEmail(config, options.email!.toLowerCase());

  if (!row) {
    throw notFoundError("User not found.");
  }

  return row;
};

const setUserStatus = (
  config: AppConfig,
  requestId: string,
  id: string,
  status: "ACTIVE" | "DISABLED",
  action: "user.enable" | "user.disable",
  token?: string,
  reason?: string,
): UserRecord => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const now = new Date().toISOString();
  const changed = updateUserStatus(config, {
    id,
    status,
    updatedAt: now,
    action,
    requestId,
    reason,
  });

  if (!changed) {
    throw notFoundError(`User not found: ${id}`);
  }

  const updated = findUserById(config, id);
  if (!updated) {
    throw notFoundError(`User not found: ${id}`);
  }

  return updated;
};

export const userDisable = (
  config: AppConfig,
  requestId: string,
  id: string,
  token?: string,
  reason?: string,
): UserRecord => setUserStatus(config, requestId, id, "DISABLED", "user.disable", token, reason);

export const userEnable = (
  config: AppConfig,
  requestId: string,
  id: string,
  token?: string,
): UserRecord => setUserStatus(config, requestId, id, "ACTIVE", "user.enable", token);

export interface UserRoleMutationResult {
  userId: string;
  role: string;
}

export const userRoleAdd = (
  config: AppConfig,
  requestId: string,
  id: string,
  role: string,
  token?: string,
): UserRoleMutationResult => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const normalizedRole = role.toUpperCase();

  if (!hasUser(config, id)) {
    throw notFoundError(`User not found: ${id}`);
  }

  const roleId = findRoleIdByName(config, normalizedRole);
  if (!roleId) {
    throw notFoundError(`Role not found: ${normalizedRole}`);
  }

  addUserRole(config, {
    userId: id,
    roleId,
    roleName: normalizedRole,
    requestId,
  });

  return {
    userId: id,
    role: normalizedRole,
  };
};

export const userRoleRemove = (
  config: AppConfig,
  requestId: string,
  id: string,
  role: string,
  token?: string,
): UserRoleMutationResult => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const normalizedRole = role.toUpperCase();

  if (!hasUser(config, id)) {
    throw notFoundError(`User not found: ${id}`);
  }

  const roleId = findRoleIdByName(config, normalizedRole);
  if (!roleId) {
    throw notFoundError(`Role not found: ${normalizedRole}`);
  }

  removeUserRole(config, {
    userId: id,
    roleId,
    roleName: normalizedRole,
    requestId,
  });

  return {
    userId: id,
    role: normalizedRole,
  };
};


===== FILE: src/cli/config.ts =====
import { cosmiconfig } from "cosmiconfig";
import { z } from "zod";
import { AppConfig, GlobalOptions } from "./types";

const envSchema = z.enum(["local", "staging", "prod"]);

const configFileSchema = z.object({
  env: envSchema.optional(),
  db: z
    .object({
      mode: z.literal("sqlite").optional(),
      file: z.string().min(1).optional(),
      busyTimeoutMs: z.number().int().positive().optional(),
    })
    .optional(),
  security: z
    .object({
      requireTokenInStaging: z.boolean().optional(),
      requireTokenInProd: z.boolean().optional(),
      dangerousOpsRequireExplicitProd: z.boolean().optional(),
    })
    .optional(),
  audit: z
    .object({
      strict: z.boolean().optional(),
    })
    .optional(),
  output: z
    .object({
      defaultFormat: z.enum(["text", "json"]).optional(),
    })
    .optional(),
});

type ConfigFileShape = z.infer<typeof configFileSchema>;

export const defaultConfig: AppConfig = {
  env: "local",
  db: {
    mode: "sqlite",
    file: "./data/app.db",
    busyTimeoutMs: 5000,
  },
  security: {
    requireTokenInStaging: true,
    requireTokenInProd: true,
    dangerousOpsRequireExplicitProd: true,
  },
  audit: {
    strict: true,
  },
  output: {
    defaultFormat: "text",
  },
};

interface ResolveConfigInput {
  fileConfig?: ConfigFileShape;
  envVars?: NodeJS.ProcessEnv;
  flags?: GlobalOptions;
}

const toBool = (value: string | undefined): boolean | undefined => {
  if (value === undefined) {
    return undefined;
  }
  if (value.toLowerCase() === "true") {
    return true;
  }
  if (value.toLowerCase() === "false") {
    return false;
  }
  return undefined;
};

const parseEnv = (envVars: NodeJS.ProcessEnv): ConfigFileShape => {
  const env = envSchema.safeParse(envVars.APPCTL_ENV);
  const outputFormat = z.enum(["text", "json"]).safeParse(envVars.APPCTL_OUTPUT_FORMAT);

  return {
    env: env.success ? env.data : undefined,
    db: {
      mode: "sqlite",
      file: envVars.APPCTL_DB_FILE,
      busyTimeoutMs: envVars.APPCTL_DB_BUSY_TIMEOUT_MS
        ? Number(envVars.APPCTL_DB_BUSY_TIMEOUT_MS)
        : undefined,
    },
    security: {
      requireTokenInStaging: toBool(envVars.APPCTL_REQUIRE_TOKEN_STAGING),
      requireTokenInProd: toBool(envVars.APPCTL_REQUIRE_TOKEN_PROD),
      dangerousOpsRequireExplicitProd: toBool(envVars.APPCTL_DANGEROUS_REQUIRE_EXPLICIT_PROD),
    },
    audit: {
      strict: toBool(envVars.APPCTL_AUDIT_STRICT),
    },
    output: {
      defaultFormat: outputFormat.success ? outputFormat.data : undefined,
    },
  };
};

const mergeConfig = (base: AppConfig, incoming: ConfigFileShape): AppConfig => ({
  env: incoming.env ?? base.env,
  db: {
    mode: incoming.db?.mode ?? base.db.mode,
    file: incoming.db?.file ?? base.db.file,
    busyTimeoutMs: incoming.db?.busyTimeoutMs ?? base.db.busyTimeoutMs,
  },
  security: {
    requireTokenInStaging:
      incoming.security?.requireTokenInStaging ?? base.security.requireTokenInStaging,
    requireTokenInProd: incoming.security?.requireTokenInProd ?? base.security.requireTokenInProd,
    dangerousOpsRequireExplicitProd:
      incoming.security?.dangerousOpsRequireExplicitProd ??
      base.security.dangerousOpsRequireExplicitProd,
  },
  audit: {
    strict: incoming.audit?.strict ?? base.audit.strict,
  },
  output: {
    defaultFormat: incoming.output?.defaultFormat ?? base.output.defaultFormat,
  },
});

export const resolveConfig = ({
  fileConfig,
  envVars = process.env,
  flags,
}: ResolveConfigInput): AppConfig => {
  let resolved = mergeConfig(defaultConfig, fileConfig ?? {});
  resolved = mergeConfig(resolved, parseEnv(envVars));

  if (flags?.env) {
    resolved.env = flags.env;
  }

  if (flags?.json) {
    resolved.output.defaultFormat = "json";
  }

  return resolved;
};

const searchPlaces = [
  "appctl.config.json",
  ".appctlrc",
  ".appctlrc.json",
  ".appctlrc.yaml",
  ".appctlrc.yml",
];

export const loadConfigFromDisk = async (cwd = process.cwd()): Promise<ConfigFileShape | undefined> => {
  const explorer = cosmiconfig("appctl", {
    stopDir: cwd,
    searchPlaces,
  });

  const result = await explorer.search(cwd);
  if (!result) {
    return undefined;
  }

  return configFileSchema.parse(result.config);
};


===== FILE: src/cli/db.ts =====
import { existsSync, mkdirSync } from "node:fs";
import { dirname, resolve } from "node:path";
import { createHash, randomUUID } from "node:crypto";
import Database from "better-sqlite3";
import { authError, preconditionError } from "./errors";
import { AppConfig, RuntimeEnv } from "./types";

interface Migration {
  name: string;
  sql: string;
}

const migrations: Migration[] = [
  {
    name: "001_core_schema",
    sql: `
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  status TEXT NOT NULL,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS roles (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS user_roles (
  user_id TEXT NOT NULL,
  role_id TEXT NOT NULL,
  UNIQUE(user_id, role_id),
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (role_id) REFERENCES roles(id)
);

CREATE TABLE IF NOT EXISTS service_tokens (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  token_hash TEXT NOT NULL,
  created_at TEXT NOT NULL,
  revoked_at TEXT,
  last_used_at TEXT
);

CREATE TABLE IF NOT EXISTS events (
  id TEXT PRIMARY KEY,
  slug TEXT NOT NULL UNIQUE,
  title TEXT NOT NULL,
  start_at TEXT NOT NULL,
  end_at TEXT NOT NULL,
  timezone TEXT NOT NULL,
  status TEXT NOT NULL,
  capacity INTEGER,
  created_by TEXT,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS event_registrations (
  id TEXT PRIMARY KEY,
  event_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  status TEXT NOT NULL,
  UNIQUE(event_id, user_id),
  FOREIGN KEY (event_id) REFERENCES events(id),
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS audit_log (
  id TEXT PRIMARY KEY,
  actor_type TEXT NOT NULL,
  actor_id TEXT,
  action TEXT NOT NULL,
  target_type TEXT NOT NULL,
  target_id TEXT,
  metadata TEXT,
  created_at TEXT NOT NULL,
  request_id TEXT NOT NULL
);
`,
  },
];

const ensureMetaTable = (db: Database.Database): void => {
  db.exec(`
CREATE TABLE IF NOT EXISTS app_migrations (
  name TEXT PRIMARY KEY,
  applied_at TEXT NOT NULL
);
`);
};

const openDb = (config: AppConfig, enforcePragmas = true): Database.Database => {
  const dbPath = resolve(config.db.file);
  mkdirSync(dirname(dbPath), { recursive: true });

  const db = new Database(dbPath);
  if (enforcePragmas) {
    db.pragma(`busy_timeout = ${config.db.busyTimeoutMs}`);
    db.pragma("foreign_keys = ON");
    db.pragma("journal_mode = WAL");
  }
  return db;
};

const getAppliedMigrationNames = (db: Database.Database): string[] => {
  const hasMeta = db
    .prepare("SELECT COUNT(1) AS count FROM sqlite_master WHERE type = 'table' AND name = 'app_migrations'")
    .get() as { count: number };

  if (hasMeta.count === 0) {
    return [];
  }

  const rows = db.prepare("SELECT name FROM app_migrations ORDER BY applied_at ASC").all() as {
    name: string;
  }[];
  return rows.map((row) => row.name);
};

const appendAudit = (
  db: Database.Database,
  action: string,
  requestId: string,
  metadata?: Record<string, unknown>,
): void => {
  db.prepare(
    `
INSERT INTO audit_log (
  id,
  actor_type,
  actor_id,
  action,
  target_type,
  target_id,
  metadata,
  created_at,
  request_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
  ).run(
    randomUUID(),
    "SERVICE",
    null,
    action,
    "system",
    null,
    metadata ? JSON.stringify(metadata) : null,
    new Date().toISOString(),
    requestId,
  );
};

export interface DbStatus {
  currentMigration: string | null;
  pendingCount: number;
  appliedCount: number;
  pendingMigrations: string[];
}

const statusFromDb = (db: Database.Database): DbStatus => {
  const applied = getAppliedMigrationNames(db);
  const pending = migrations.filter((migration) => !applied.includes(migration.name));

  return {
    currentMigration: applied.length > 0 ? applied[applied.length - 1] : null,
    pendingCount: pending.length,
    appliedCount: applied.length,
    pendingMigrations: pending.map((migration) => migration.name),
  };
};

export const dbStatus = (config: AppConfig): DbStatus => {
  const db = openDb(config);
  try {
    return statusFromDb(db);
  } finally {
    db.close();
  }
};

export interface MigrateResult {
  applied: string[];
  pendingBefore: number;
}

export const dbMigrate = (config: AppConfig, requestId: string): MigrateResult => {
  const db = openDb(config);
  try {
    ensureMetaTable(db);
    const applied = getAppliedMigrationNames(db);
    const pending = migrations.filter((migration) => !applied.includes(migration.name));

    const run = db.transaction(() => {
      for (const migration of pending) {
        db.exec(migration.sql);
        db.prepare("INSERT INTO app_migrations (name, applied_at) VALUES (?, ?)").run(
          migration.name,
          new Date().toISOString(),
        );
      }

      appendAudit(db, "db.migrate", requestId, {
        appliedCount: pending.length,
        migrations: pending.map((migration) => migration.name),
      });
    });

    run();

    return {
      applied: pending.map((migration) => migration.name),
      pendingBefore: pending.length,
    };
  } finally {
    db.close();
  }
};

const hashToken = (token: string): string =>
  createHash("sha256").update(token).digest("hex");

const resolveActiveToken = (config: AppConfig, token: string): { id: string } | undefined => {
  const db = openDb(config);
  try {
    const tokenHash = hashToken(token);
    return db
      .prepare("SELECT id FROM service_tokens WHERE token_hash = ? AND revoked_at IS NULL")
      .get(tokenHash) as { id: string } | undefined;
  } finally {
    db.close();
  }
};

const requireDangerousProdGuard = (args: {
  config: AppConfig;
  operation: string;
  forceProd?: boolean;
  yes?: boolean;
  token?: string;
}): void => {
  if (args.config.env !== "prod") {
    return;
  }

  if (!args.forceProd || !args.yes) {
    throw preconditionError(
      `${args.operation} in prod requires both --force-prod and --yes.`,
    );
  }

  if (!args.token) {
    throw authError(`A valid token is required for ${args.operation} in prod.`);
  }

  const token = resolveActiveToken(args.config, args.token);
  if (!token) {
    throw authError(`Invalid or revoked token for ${args.operation} in prod.`);
  }
};

export interface DbBackupResult {
  out: string;
  env: RuntimeEnv;
}

export const dbBackup = async (
  config: AppConfig,
  requestId: string,
  out: string,
  options?: {
    forceProd?: boolean;
    yes?: boolean;
    token?: string;
  },
): Promise<DbBackupResult> => {
  const status = dbStatus(config);
  if (status.pendingCount > 0) {
    throw preconditionError("Migrations are pending. Run `appctl db migrate` first.");
  }

  requireDangerousProdGuard({
    config,
    operation: "db backup",
    forceProd: options?.forceProd,
    yes: options?.yes,
    token: options?.token,
  });

  const outputPath = resolve(out);
  mkdirSync(dirname(outputPath), { recursive: true });

  const db = openDb(config);
  try {
    await db.backup(outputPath);

    appendAudit(db, "db.backup", requestId, {
      out: outputPath,
      env: config.env,
    });

    return {
      out: outputPath,
      env: config.env,
    };
  } finally {
    db.close();
  }
};

export interface DbRestoreResult {
  from: string;
  target: string;
  env: RuntimeEnv;
}

export const dbRestore = async (
  config: AppConfig,
  requestId: string,
  from: string,
  options?: {
    forceProd?: boolean;
    yes?: boolean;
    token?: string;
  },
): Promise<DbRestoreResult> => {
  if (!options?.yes) {
    throw preconditionError("db restore requires --yes confirmation.");
  }

  requireDangerousProdGuard({
    config,
    operation: "db restore",
    forceProd: options?.forceProd,
    yes: options?.yes,
    token: options?.token,
  });

  const sourcePath = resolve(from);
  if (!existsSync(sourcePath)) {
    throw preconditionError(`Backup file not found: ${sourcePath}`);
  }

  const targetPath = resolve(config.db.file);
  mkdirSync(dirname(targetPath), { recursive: true });

  const sourceDb = new Database(sourcePath, {
    readonly: true,
    fileMustExist: true,
  });

  try {
    await sourceDb.backup(targetPath);
  } finally {
    sourceDb.close();
  }

  const restoredDb = openDb(config);
  try {
    appendAudit(restoredDb, "db.restore", requestId, {
      from: sourcePath,
      target: targetPath,
      env: config.env,
    });
  } finally {
    restoredDb.close();
  }

  return {
    from: sourcePath,
    target: targetPath,
    env: config.env,
  };
};

export interface SeedResult {
  seededRoles: number;
}

export const dbSeed = (config: AppConfig, requestId: string, fixture?: string): SeedResult => {
  const status = dbStatus(config);
  if (status.pendingCount > 0) {
    throw preconditionError("Migrations are pending. Run `appctl db migrate` first.");
  }

  const db = openDb(config);
  try {
    const roleNames = ["USER", "ADMIN", "SUPER_ADMIN"];

    const run = db.transaction(() => {
      for (const roleName of roleNames) {
        db.prepare("INSERT OR IGNORE INTO roles (id, name) VALUES (?, ?)").run(
          randomUUID(),
          roleName,
        );
      }

      appendAudit(db, "db.seed", requestId, {
        fixture: fixture ?? "default",
      });
    });

    run();

    const seededRoles = db.prepare("SELECT COUNT(*) AS count FROM roles").get() as { count: number };

    return {
      seededRoles: seededRoles.count,
    };
  } finally {
    db.close();
  }
};

export interface DoctorResult {
  dbReachable: boolean;
  schemaCurrent: boolean;
  walEnabled: boolean;
  foreignKeysEnabled: boolean;
  writable: boolean;
  dbPath: string;
}

export const doctor = (config: AppConfig): DoctorResult => {
  const dbPath = resolve(config.db.file);
  const db = openDb(config, false);

  try {
    const status = statusFromDb(db);
    const journal = db.pragma("journal_mode", { simple: true }) as string;
    const foreignKeys = db.pragma("foreign_keys", { simple: true }) as number;
    const busyTimeout = db.pragma("busy_timeout", { simple: true }) as number;

    const writeProbe = db.transaction(() => {
      db.exec("CREATE TABLE IF NOT EXISTS __appctl_write_probe (id INTEGER PRIMARY KEY)");
      db.exec("INSERT INTO __appctl_write_probe DEFAULT VALUES");
      db.exec("DELETE FROM __appctl_write_probe");
    });
    writeProbe();

    const result: DoctorResult = {
      dbReachable: true,
      schemaCurrent: status.pendingCount === 0,
      walEnabled: journal.toLowerCase() === "wal",
      foreignKeysEnabled: foreignKeys === 1,
      writable: true,
      dbPath,
    };

    if (!result.schemaCurrent) {
      throw preconditionError("Schema is not up to date. Run `appctl db migrate`.");
    }

    if (!result.walEnabled || !result.foreignKeysEnabled) {
      throw preconditionError("SQLite pragmas invalid. Require WAL mode and foreign_keys=ON.");
    }

    if (busyTimeout <= 0) {
      throw preconditionError("SQLite busy timeout invalid. Must be greater than 0.");
    }

    return result;
  } finally {
    db.close();
  }
};


===== FILE: src/cli/errors.ts =====
import { ExitCode } from "./types";

export class CliError extends Error {
  public readonly exitCode: ExitCode;

  constructor(message: string, exitCode: ExitCode) {
    super(message);
    this.name = "CliError";
    this.exitCode = exitCode;
  }
}

export const usageError = (message: string): CliError => new CliError(message, 2);
export const authError = (message: string): CliError => new CliError(message, 3);
export const notFoundError = (message: string): CliError => new CliError(message, 4);
export const conflictError = (message: string): CliError => new CliError(message, 5);
export const preconditionError = (message: string): CliError => new CliError(message, 6);


===== FILE: src/cli/events-repository.ts =====
import { randomUUID } from "node:crypto";
import Database from "better-sqlite3";
import { appendServiceAudit, openCliDb } from "./repository-helpers";
import { AppConfig } from "./types";

export interface EventRecord {
  id: string;
  slug: string;
  title: string;
  start_at: string;
  end_at: string;
  timezone: string;
  status: "DRAFT" | "PUBLISHED" | "CANCELLED";
  capacity: number | null;
  created_by: string | null;
  created_at: string;
  updated_at: string;
}

export class DuplicateEventSlugError extends Error {
  constructor(public readonly slug: string) {
    super(`Duplicate event slug: ${slug}`);
    this.name = "DuplicateEventSlugError";
  }
}

const appendAudit = (
  db: Database.Database,
  action: string,
  requestId: string,
  metadata?: Record<string, unknown>,
): void => {
  appendServiceAudit(db, {
    action,
    requestId,
    targetType: "event",
    metadata,
  });
};

export const createEvent = (
  config: AppConfig,
  args: {
    id: string;
    slug: string;
    title: string;
    startAt: string;
    endAt: string;
    timezone: string;
    capacity: number | null;
    now: string;
    requestId: string;
  },
): EventRecord => {
  const db = openCliDb(config);
  try {
    const run = db.transaction(() => {
      try {
        db.prepare(
          `
INSERT INTO events (
  id, slug, title, start_at, end_at, timezone, status, capacity, created_by, created_at, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
        ).run(args.id, args.slug, args.title, args.startAt, args.endAt, args.timezone, "DRAFT", args.capacity, null, args.now, args.now);
      } catch (error) {
        if (error instanceof Error && error.message.includes("UNIQUE constraint failed: events.slug")) {
          throw new DuplicateEventSlugError(args.slug);
        }
        throw error;
      }

      appendAudit(db, "event.create", args.requestId, {
        eventId: args.id,
        slug: args.slug,
      });
    });

    run();

    return db.prepare("SELECT * FROM events WHERE id = ?").get(args.id) as EventRecord;
  } finally {
    db.close();
  }
};

export const findEventBySlug = (config: AppConfig, slug: string): EventRecord | undefined => {
  const db = openCliDb(config);
  try {
    return db.prepare("SELECT * FROM events WHERE slug = ?").get(slug) as EventRecord | undefined;
  } finally {
    db.close();
  }
};

export const updateEventBySlug = (
  config: AppConfig,
  args: {
    slug: string;
    title: string;
    startAt: string;
    endAt: string;
    capacity: number | null;
    now: string;
    requestId: string;
  },
): EventRecord => {
  const db = openCliDb(config);
  try {
    const run = db.transaction(() => {
      db.prepare(
        `
UPDATE events
SET title = ?, start_at = ?, end_at = ?, capacity = ?, updated_at = ?
WHERE slug = ?
`,
      ).run(args.title, args.startAt, args.endAt, args.capacity, args.now, args.slug);

      appendAudit(db, "event.update", args.requestId, {
        slug: args.slug,
      });
    });

    run();

    return db.prepare("SELECT * FROM events WHERE slug = ?").get(args.slug) as EventRecord;
  } finally {
    db.close();
  }
};

export const publishEventBySlug = (
  config: AppConfig,
  args: {
    slug: string;
    now: string;
    requestId: string;
    wasPublished: boolean;
  },
): EventRecord => {
  const db = openCliDb(config);
  try {
    const run = db.transaction(() => {
      if (!args.wasPublished) {
        db.prepare("UPDATE events SET status = 'PUBLISHED', updated_at = ? WHERE slug = ?").run(args.now, args.slug);
      }

      appendAudit(db, "event.publish", args.requestId, {
        slug: args.slug,
        idempotent: args.wasPublished,
      });
    });

    run();

    return db.prepare("SELECT * FROM events WHERE slug = ?").get(args.slug) as EventRecord;
  } finally {
    db.close();
  }
};

export const cancelEventBySlug = (
  config: AppConfig,
  args: {
    slug: string;
    reason: string;
    now: string;
    requestId: string;
  },
): EventRecord => {
  const db = openCliDb(config);
  try {
    const run = db.transaction(() => {
      db.prepare("UPDATE events SET status = 'CANCELLED', updated_at = ? WHERE slug = ?").run(args.now, args.slug);

      appendAudit(db, "event.cancel", args.requestId, {
        slug: args.slug,
        reason: args.reason,
      });
    });

    run();

    return db.prepare("SELECT * FROM events WHERE slug = ?").get(args.slug) as EventRecord;
  } finally {
    db.close();
  }
};

export const listEvents = (
  config: AppConfig,
  filters: { status?: string; fromIso?: string; toIso?: string },
): EventRecord[] => {
  const db = openCliDb(config);
  try {
    const params: unknown[] = [];
    const clauses: string[] = [];

    if (filters.status) {
      clauses.push("status = ?");
      params.push(filters.status.toUpperCase());
    }

    if (filters.fromIso) {
      clauses.push("start_at >= ?");
      params.push(filters.fromIso);
    }

    if (filters.toIso) {
      clauses.push("start_at <= ?");
      params.push(filters.toIso);
    }

    const query = `
SELECT *
FROM events
${clauses.length ? `WHERE ${clauses.join(" AND ")}` : ""}
ORDER BY start_at ASC
`;

    return db.prepare(query).all(...params) as EventRecord[];
  } finally {
    db.close();
  }
};


===== FILE: src/cli/events.ts =====
import { randomUUID } from "node:crypto";
import { conflictError, notFoundError, usageError } from "./errors";
import {
  EventRecord,
  listEvents,
} from "./events-repository";
import { SqliteAuditSink } from "../core/infrastructure/sqlite/audit-sink";
import { SqliteEventRepository } from "../core/infrastructure/sqlite/repositories";
import { EventAlreadyExistsError, EventNotFoundError, InvalidInputError } from "../core/domain/errors";
import { cancelEvent as cancelEventUseCase } from "../core/use-cases/cancel-event";
import { createEvent as createEventUseCase } from "../core/use-cases/create-event";
import { publishEvent as publishEventUseCase } from "../core/use-cases/publish-event";
import { updateEvent as updateEventUseCase } from "../core/use-cases/update-event";
import { executeWithAudit } from "../core/use-cases/with-audit";
import { requireSchemaCurrent } from "./schema-guard";
import { AppConfig } from "./types";
import { requireWriteAuth } from "./write-auth";

const parseIso = (value: string, field: string): string => {
  const parsed = new Date(value);
  if (Number.isNaN(parsed.getTime())) {
    throw usageError(`Invalid ISO datetime for ${field}: ${value}`);
  }

  return parsed.toISOString();
};

export const eventCreate = (
  config: AppConfig,
  requestId: string,
  args: {
    slug: string;
    title: string;
    start: string;
    end: string;
    timezone: string;
    capacity?: number;
  },
  token?: string,
): EventRecord => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);
  const events = new SqliteEventRepository(config);
  const audit = new SqliteAuditSink(config);

  try {
    return executeWithAudit({
      action: "event.create",
      requestId,
      targetType: "event",
      audit,
      execute: () =>
        createEventUseCase(args, {
          events,
          id: () => randomUUID(),
          now: () => new Date().toISOString(),
        }),
      metadata: (result) => ({
        eventId: result.id,
        slug: result.slug,
      }),
    });
  } catch (error) {
    if (error instanceof EventAlreadyExistsError) {
      throw conflictError(`Event already exists for slug: ${args.slug.trim()}`);
    }
    if (error instanceof InvalidInputError) {
      throw usageError(error.message);
    }
    throw error;
  }
};

export const eventUpdate = (
  config: AppConfig,
  requestId: string,
  slug: string,
  changes: {
    title?: string;
    start?: string;
    end?: string;
    capacity?: number;
  },
  token?: string,
): EventRecord => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const events = new SqliteEventRepository(config);
  const audit = new SqliteAuditSink(config);
  try {
    return executeWithAudit({
      action: "event.update",
      requestId,
      targetType: "event",
      audit,
      execute: () =>
        updateEventUseCase(
          {
            slug,
            title: changes.title,
            start: changes.start,
            end: changes.end,
            capacity: changes.capacity,
          },
          {
            events,
            now: () => new Date().toISOString(),
          },
        ),
      metadata: () => ({ slug }),
    });
  } catch (error) {
    if (error instanceof EventNotFoundError) {
      throw notFoundError(error.message);
    }
    if (error instanceof InvalidInputError) {
      throw usageError(error.message);
    }
    throw error;
  }
};

export const eventPublish = (
  config: AppConfig,
  requestId: string,
  slug: string,
  token?: string,
): EventRecord => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const events = new SqliteEventRepository(config);
  const audit = new SqliteAuditSink(config);
  try {
    const result = executeWithAudit({
      action: "event.publish",
      requestId,
      targetType: "event",
      audit,
      execute: () =>
        publishEventUseCase(
          { slug },
          {
            events,
            now: () => new Date().toISOString(),
          },
        ),
      metadata: (out) => ({ slug, idempotent: out.idempotent }),
    });

    return result.event;
  } catch (error) {
    if (error instanceof EventNotFoundError) {
      throw notFoundError(error.message);
    }
    throw error;
  }
};

export const eventCancel = (
  config: AppConfig,
  requestId: string,
  slug: string,
  reason: string,
  token?: string,
): EventRecord => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const events = new SqliteEventRepository(config);
  const audit = new SqliteAuditSink(config);
  try {
    return executeWithAudit({
      action: "event.cancel",
      requestId,
      targetType: "event",
      audit,
      execute: () =>
        cancelEventUseCase(
          {
            slug,
            reason,
          },
          {
            events,
            now: () => new Date().toISOString(),
          },
        ),
      metadata: () => ({ slug, reason: reason.trim() }),
    });
  } catch (error) {
    if (error instanceof EventNotFoundError) {
      throw notFoundError(error.message);
    }
    if (error instanceof InvalidInputError) {
      throw usageError(error.message);
    }
    throw error;
  }
};

export const eventList = (
  config: AppConfig,
  filters: { status?: string; from?: string; to?: string },
): EventRecord[] => {
  requireSchemaCurrent(config);

  return listEvents(config, {
    status: filters.status,
    fromIso: filters.from ? parseIso(filters.from, "from") : undefined,
    toIso: filters.to ? parseIso(filters.to, "to") : undefined,
  });
};


===== FILE: src/cli/main.ts =====
import { runCli } from "./run-cli";

const argv = process.argv.slice(2);

runCli(argv).then((exitCode) => {
  process.exitCode = exitCode;
});


===== FILE: src/cli/registrations-repository.ts =====
import { randomUUID } from "node:crypto";
import Database from "better-sqlite3";
import { notFoundError, preconditionError } from "./errors";
import { appendServiceAudit, openCliDb } from "./repository-helpers";
import { AppConfig } from "./types";

interface EventRow {
  id: string;
  slug: string;
  capacity: number | null;
}

interface UserRow {
  id: string;
  email: string;
}

export interface RegistrationRow {
  id: string;
  event_id: string;
  user_id: string;
  status: "REGISTERED" | "WAITLISTED" | "CANCELLED" | "CHECKED_IN";
}

export interface RegistrationListRow {
  id: string;
  event_slug: string;
  user_id: string;
  user_email: string;
  status: "REGISTERED" | "WAITLISTED" | "CANCELLED" | "CHECKED_IN";
}

export interface ExportRegistrationRow {
  id: string;
  status: string;
  user_id: string;
  user_email: string;
}

const appendAudit = (
  db: Database.Database,
  action: string,
  requestId: string,
  metadata?: Record<string, unknown>,
): void => {
  appendServiceAudit(db, {
    action,
    requestId,
    targetType: "registration",
    metadata,
  });
};

const resolveEvent = (db: Database.Database, slug: string): EventRow => {
  const event = db.prepare("SELECT id, slug, capacity FROM events WHERE slug = ?").get(slug) as
    | EventRow
    | undefined;

  if (!event) {
    throw notFoundError(`Event not found: ${slug}`);
  }

  return event;
};

const resolveUser = (db: Database.Database, identifier: string): UserRow => {
  const looksLikeEmail = identifier.includes("@");

  const user = looksLikeEmail
    ? (db.prepare("SELECT id, email FROM users WHERE email = ?").get(identifier.toLowerCase()) as
        | UserRow
        | undefined)
    : (db.prepare("SELECT id, email FROM users WHERE id = ?").get(identifier) as UserRow | undefined);

  if (!user) {
    throw notFoundError(`User not found: ${identifier}`);
  }

  return user;
};

const computeRegistrationStatus = (
  db: Database.Database,
  eventId: string,
  capacity: number | null,
): "REGISTERED" | "WAITLISTED" => {
  if (capacity === null) {
    return "REGISTERED";
  }

  const activeCount = db
    .prepare(
      "SELECT COUNT(*) AS count FROM event_registrations WHERE event_id = ? AND status IN ('REGISTERED','CHECKED_IN')",
    )
    .get(eventId) as { count: number };

  return activeCount.count >= capacity ? "WAITLISTED" : "REGISTERED";
};

export const addRegistration = (
  config: AppConfig,
  args: {
    requestId: string;
    eventSlug: string;
    userIdentifier: string;
  },
): RegistrationRow => {
  const db = openCliDb(config);
  try {
    const event = resolveEvent(db, args.eventSlug);
    const user = resolveUser(db, args.userIdentifier);

    const run = db.transaction(() => {
      const existing = db
        .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
        .get(event.id, user.id) as RegistrationRow | undefined;

      const status = computeRegistrationStatus(db, event.id, event.capacity);

      if (!existing) {
        db.prepare("INSERT INTO event_registrations (id, event_id, user_id, status) VALUES (?, ?, ?, ?)").run(
          randomUUID(),
          event.id,
          user.id,
          status,
        );
      } else if (existing.status === "CANCELLED") {
        db.prepare("UPDATE event_registrations SET status = ? WHERE id = ?").run(status, existing.id);
      }

      appendAudit(db, "registration.add", args.requestId, {
        eventSlug: args.eventSlug,
        userId: user.id,
      });
    });

    run();

    return db
      .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
      .get(event.id, user.id) as RegistrationRow;
  } finally {
    db.close();
  }
};

export const removeRegistration = (
  config: AppConfig,
  args: {
    requestId: string;
    eventSlug: string;
    userIdentifier: string;
    reason?: string;
  },
): RegistrationRow => {
  const db = openCliDb(config);
  try {
    const event = resolveEvent(db, args.eventSlug);
    const user = resolveUser(db, args.userIdentifier);

    const run = db.transaction(() => {
      const existing = db
        .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
        .get(event.id, user.id) as RegistrationRow | undefined;

      if (!existing) {
        throw notFoundError(`Registration not found for event=${args.eventSlug} user=${args.userIdentifier}`);
      }

      db.prepare("UPDATE event_registrations SET status = 'CANCELLED' WHERE id = ?").run(existing.id);

      appendAudit(db, "registration.cancel", args.requestId, {
        eventSlug: args.eventSlug,
        userId: user.id,
        reason: args.reason ?? null,
      });
    });

    run();

    return db
      .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
      .get(event.id, user.id) as RegistrationRow;
  } finally {
    db.close();
  }
};

export const listRegistrations = (
  config: AppConfig,
  args: { eventSlug: string; status?: string },
): RegistrationListRow[] => {
  const db = openCliDb(config);
  try {
    const event = resolveEvent(db, args.eventSlug);
    const params: unknown[] = [event.id];
    const clauses = ["r.event_id = ?"];

    if (args.status) {
      clauses.push("r.status = ?");
      params.push(args.status.toUpperCase());
    }

    return db
      .prepare(
        `
SELECT r.id, e.slug AS event_slug, u.id AS user_id, u.email AS user_email, r.status
FROM event_registrations r
JOIN events e ON e.id = r.event_id
JOIN users u ON u.id = r.user_id
WHERE ${clauses.join(" AND ")}
ORDER BY u.email ASC
`,
      )
      .all(...params) as RegistrationListRow[];
  } finally {
    db.close();
  }
};

export const checkinRegistration = (
  config: AppConfig,
  args: {
    requestId: string;
    eventSlug: string;
    userIdentifier: string;
  },
): RegistrationRow => {
  const db = openCliDb(config);
  try {
    const event = resolveEvent(db, args.eventSlug);
    const user = resolveUser(db, args.userIdentifier);

    const run = db.transaction(() => {
      const existing = db
        .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
        .get(event.id, user.id) as RegistrationRow | undefined;

      if (!existing) {
        throw notFoundError(`Registration not found for event=${args.eventSlug} user=${args.userIdentifier}`);
      }

      if (existing.status === "CANCELLED") {
        throw preconditionError("Cannot check in a cancelled registration.");
      }

      db.prepare("UPDATE event_registrations SET status = 'CHECKED_IN' WHERE id = ?").run(existing.id);

      appendAudit(db, "registration.checkin", args.requestId, {
        eventSlug: args.eventSlug,
        userId: user.id,
      });
    });

    run();

    return db
      .prepare("SELECT * FROM event_registrations WHERE event_id = ? AND user_id = ?")
      .get(event.id, user.id) as RegistrationRow;
  } finally {
    db.close();
  }
};

export const getEventExportRows = (
  config: AppConfig,
  slug: string,
): ExportRegistrationRow[] => {
  const db = openCliDb(config);
  try {
    const event = resolveEvent(db, slug);

    return db
      .prepare(
        `
SELECT r.id, r.status, u.id AS user_id, u.email AS user_email
FROM event_registrations r
JOIN users u ON u.id = r.user_id
WHERE r.event_id = ?
ORDER BY u.email ASC
`,
      )
      .all(event.id) as ExportRegistrationRow[];
  } finally {
    db.close();
  }
};

export const appendEventExportAudit = (
  config: AppConfig,
  args: {
    requestId: string;
    slug: string;
    format: "csv" | "json";
    out: string;
    includeEmail: boolean;
    count: number;
  },
): void => {
  const db = openCliDb(config);
  try {
    const run = db.transaction(() => {
      appendAudit(db, "event.export", args.requestId, {
        slug: args.slug,
        format: args.format,
        out: args.out,
        includeEmail: args.includeEmail,
        count: args.count,
      });
    });

    run();
  } finally {
    db.close();
  }
};


===== FILE: src/cli/registrations.ts =====
import { randomUUID } from "node:crypto";
import { mkdirSync, writeFileSync } from "node:fs";
import { dirname, resolve } from "node:path";
import {
  CancelledRegistrationCheckinError,
  EventNotFoundError,
  RegistrationNotFoundError,
  UserNotFoundError,
} from "../core/domain/errors";
import { SqliteAuditSink } from "../core/infrastructure/sqlite/audit-sink";
import {
  SqliteEventRepository,
  SqliteRegistrationRepository,
  SqliteUserRepository,
} from "../core/infrastructure/sqlite/repositories";
import { checkInParticipant } from "../core/use-cases/check-in-participant";
import { removeParticipant } from "../core/use-cases/remove-participant";
import { registerParticipant } from "../core/use-cases/register-participant";
import { executeWithAudit } from "../core/use-cases/with-audit";
import { notFoundError, preconditionError } from "./errors";
import {
  appendEventExportAudit,
  getEventExportRows,
  listRegistrations,
  RegistrationListRow,
  RegistrationRow,
} from "./registrations-repository";
import { requireSchemaCurrent } from "./schema-guard";
import { AppConfig } from "./types";
import { requireWriteAuth } from "./write-auth";

export const regAdd = (
  config: AppConfig,
  requestId: string,
  eventSlug: string,
  userIdentifier: string,
  token?: string,
): RegistrationRow => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const users = new SqliteUserRepository(config);
  const events = new SqliteEventRepository(config);
  const registrations = new SqliteRegistrationRepository(config);
  const audit = new SqliteAuditSink(config);

  try {
    return executeWithAudit({
      action: "registration.add",
      requestId,
      targetType: "registration",
      audit,
      execute: () =>
        registerParticipant(
          {
            eventSlug,
            userIdentifier,
          },
          {
            users,
            events,
            registrations,
            id: () => randomUUID(),
          },
        ),
      metadata: (result) => ({
        eventSlug,
        userId: result.user_id,
      }),
    });
  } catch (error) {
    if (error instanceof EventNotFoundError) {
      throw notFoundError(error.message);
    }
    if (error instanceof UserNotFoundError) {
      throw notFoundError(error.message);
    }
    throw error;
  }
};

export const regRemove = (
  config: AppConfig,
  requestId: string,
  eventSlug: string,
  userIdentifier: string,
  token?: string,
  reason?: string,
): RegistrationRow => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const users = new SqliteUserRepository(config);
  const events = new SqliteEventRepository(config);
  const registrations = new SqliteRegistrationRepository(config);
  const audit = new SqliteAuditSink(config);

  try {
    return executeWithAudit({
      action: "registration.cancel",
      requestId,
      targetType: "registration",
      audit,
      execute: () =>
        removeParticipant(
          {
            eventSlug,
            userIdentifier,
          },
          {
            users,
            events,
            registrations,
          },
        ),
      metadata: (result) => ({
        eventSlug,
        userId: result.user_id,
        reason: reason ?? null,
      }),
    });
  } catch (error) {
    if (error instanceof EventNotFoundError || error instanceof UserNotFoundError || error instanceof RegistrationNotFoundError) {
      throw notFoundError(error.message);
    }
    throw error;
  }
};

export const regList = (
  config: AppConfig,
  eventSlug: string,
  status?: string,
): RegistrationListRow[] => {
  requireSchemaCurrent(config);

  return listRegistrations(config, { eventSlug, status });
};

export const regCheckin = (
  config: AppConfig,
  requestId: string,
  eventSlug: string,
  userIdentifier: string,
  token?: string,
): RegistrationRow => {
  requireSchemaCurrent(config);
  requireWriteAuth(config, token);

  const users = new SqliteUserRepository(config);
  const events = new SqliteEventRepository(config);
  const registrations = new SqliteRegistrationRepository(config);
  const audit = new SqliteAuditSink(config);

  try {
    return executeWithAudit({
      action: "registration.checkin",
      requestId,
      targetType: "registration",
      audit,
      execute: () =>
        checkInParticipant(
          {
            eventSlug,
            userIdentifier,
          },
          {
            users,
            events,
            registrations,
          },
        ),
      metadata: (result) => ({
        eventSlug,
        userId: result.user_id,
      }),
    });
  } catch (error) {
    if (error instanceof EventNotFoundError || error instanceof UserNotFoundError || error instanceof RegistrationNotFoundError) {
      throw notFoundError(error.message);
    }
    if (error instanceof CancelledRegistrationCheckinError) {
      throw preconditionError(error.message);
    }
    throw error;
  }
};

export interface ExportResult {
  slug: string;
  format: "csv" | "json";
  out: string;
  count: number;
  includeEmail: boolean;
}

export const eventExport = (
  config: AppConfig,
  requestId: string,
  args: {
    slug: string;
    format: "csv" | "json";
    out: string;
    includeEmail: boolean;
  },
  token?: string,
): ExportResult => {
  requireSchemaCurrent(config);

  if (args.includeEmail && config.env !== "local") {
    requireWriteAuth(config, token);
  }

  const rows = getEventExportRows(config, args.slug);

  const includeEmail = args.includeEmail;

  const serializable = rows.map((row) =>
    includeEmail
      ? {
          id: row.id,
          status: row.status,
          user_id: row.user_id,
          user_email: row.user_email,
        }
      : {
          id: row.id,
          status: row.status,
          user_id: row.user_id,
        },
  );

  const outputPath = resolve(args.out);
  mkdirSync(dirname(outputPath), { recursive: true });

  if (args.format === "json") {
    writeFileSync(outputPath, `${JSON.stringify(serializable, null, 2)}\n`, "utf8");
  } else {
    const headers = includeEmail ? ["id", "status", "user_id", "user_email"] : ["id", "status", "user_id"];
    const body = serializable
      .map((row) => headers.map((header) => JSON.stringify((row as Record<string, string>)[header] ?? "")).join(","))
      .join("\n");
    const csv = `${headers.join(",")}\n${body}${body ? "\n" : ""}`;
    writeFileSync(outputPath, csv, "utf8");
  }

  appendEventExportAudit(config, {
    requestId,
    slug: args.slug,
    format: args.format,
    out: outputPath,
    includeEmail,
    count: rows.length,
  });

  return {
    slug: args.slug,
    format: args.format,
    out: outputPath,
    count: rows.length,
    includeEmail,
  };
};


===== FILE: src/cli/repository-helpers.ts =====
import { randomUUID } from "node:crypto";
import { mkdirSync } from "node:fs";
import { dirname, resolve } from "node:path";
import Database from "better-sqlite3";
import { AppConfig } from "./types";

export const openCliDb = (config: AppConfig): Database.Database => {
  const dbPath = resolve(config.db.file);
  mkdirSync(dirname(dbPath), { recursive: true });

  const db = new Database(dbPath);
  db.pragma(`busy_timeout = ${config.db.busyTimeoutMs}`);
  db.pragma("foreign_keys = ON");
  db.pragma("journal_mode = WAL");
  return db;
};

export const appendServiceAudit = (
  db: Database.Database,
  args: {
    action: string;
    requestId: string;
    targetType: "system" | "event" | "registration";
    metadata?: Record<string, unknown>;
  },
): void => {
  db.prepare(
    `
INSERT INTO audit_log (
  id,
  actor_type,
  actor_id,
  action,
  target_type,
  target_id,
  metadata,
  created_at,
  request_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
  ).run(
    randomUUID(),
    "SERVICE",
    null,
    args.action,
    args.targetType,
    null,
    args.metadata ? JSON.stringify(args.metadata) : null,
    new Date().toISOString(),
    args.requestId,
  );
};

export const appendAuditLog = (
  db: Database.Database,
  args: {
    actorType: "USER" | "SERVICE";
    actorId: string | null;
    action: string;
    targetType: string;
    requestId: string;
    metadata?: Record<string, unknown>;
  },
): void => {
  db.prepare(
    `
INSERT INTO audit_log (
  id,
  actor_type,
  actor_id,
  action,
  target_type,
  target_id,
  metadata,
  created_at,
  request_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
  ).run(
    randomUUID(),
    args.actorType,
    args.actorId,
    args.action,
    args.targetType,
    null,
    args.metadata ? JSON.stringify(args.metadata) : null,
    new Date().toISOString(),
    args.requestId,
  );
};


===== FILE: src/cli/run-cli.ts =====
import { randomUUID } from "node:crypto";
import { Command, CommanderError, Option } from "commander";
import pino from "pino";
import {
  authTokenCreate,
  authTokenRevoke,
  userCreate,
  userDisable,
  userEnable,
  userList,
  userRoleAdd,
  userRoleRemove,
  userShow,
} from "./auth-users";
import { loadConfigFromDisk, resolveConfig } from "./config";
import { dbBackup, dbMigrate, dbRestore, dbSeed, dbStatus, doctor } from "./db";
import { eventCancel, eventCreate, eventList, eventPublish, eventUpdate } from "./events";
import { CliError } from "./errors";
import { eventExport, regAdd, regCheckin, regList, regRemove } from "./registrations";
import { CliIo, ExitCode, GlobalOptions, JsonEnvelope, RuntimeEnv } from "./types";

const logger = pino({ enabled: false });

const defaultIo: CliIo = {
  writeStdout: (message: string) => {
    process.stdout.write(message);
  },
  writeStderr: (message: string) => {
    process.stderr.write(message);
  },
};

const usageErrorCodes = new Set([
  "commander.invalidArgument",
  "commander.unknownOption",
  "commander.unknownCommand",
  "commander.excessArguments",
  "commander.missingMandatoryOptionValue",
  "commander.optionMissingArgument",
]);

const isUsageError = (error: CommanderError): boolean => usageErrorCodes.has(error.code);

export const mapErrorToExitCode = (error: unknown): ExitCode => {
  if (error instanceof CliError) {
    return error.exitCode;
  }

  if (error instanceof CommanderError) {
    if (error.code === "commander.helpDisplayed") {
      return 0;
    }
    if (isUsageError(error)) {
      return 2;
    }
  }

  return 1;
};

const writeJsonEnvelope = (io: CliIo, envelope: JsonEnvelope): void => {
  io.writeStdout(`${JSON.stringify(envelope)}\n`);
};

const writeDoctorText = (io: CliIo, env: RuntimeEnv): void => {
  io.writeStdout(`doctor ok (env=${env})\n`);
};

const writeText = (io: CliIo, message: string): void => {
  io.writeStdout(`${message}\n`);
};

const normalizeOptions = (raw: Record<string, unknown>): GlobalOptions => ({
  env: raw.env as RuntimeEnv | undefined,
  json: Boolean(raw.json),
  quiet: Boolean(raw.quiet),
  color: Boolean(raw.color),
  trace: Boolean(raw.trace),
  dryRun: Boolean(raw.dryRun),
  yes: Boolean(raw.yes),
  token: typeof raw.token === "string" ? raw.token : undefined,
});

const createProgram = (io: CliIo): Command => {
  const program = new Command();

  program
    .name("appctl")
    .description("Super Admin Control Plane CLI")
    .option("--json", "emit strict JSON output")
    .option("--quiet", "reduce human-readable output")
    .option("--no-color", "disable ANSI colors")
    .option("--trace", "show stack traces for errors")
    .option("--dry-run", "validate request without mutating state")
    .option("--yes", "skip interactive confirmations")
    .option("--token <token>", "super-admin service token override")
    .showHelpAfterError()
    .exitOverride();

  program.addOption(
    new Option("--env <env>", "runtime environment").choices(["local", "staging", "prod"]),
  );

  program.configureOutput({
    writeOut: io.writeStdout,
    writeErr: io.writeStderr,
  });

  const resolveRuntimeConfig = async (): Promise<ReturnType<typeof resolveConfig>> => {
    const options = normalizeOptions(program.opts<Record<string, unknown>>());
    const fileConfig = await loadConfigFromDisk();
    return resolveConfig({ fileConfig, flags: options });
  };

  const outputResult = (
    commandName: string,
    env: RuntimeEnv,
    data: unknown,
    textSummary: string,
    outputAsJson: boolean,
  ): void => {
    if (outputAsJson) {
      const envelope: JsonEnvelope = {
        ok: true,
        command: commandName,
        env,
        data,
        warnings: [],
        errors: [],
        request_id: randomUUID(),
      };
      writeJsonEnvelope(io, envelope);
      return;
    }

    writeText(io, textSummary);
  };

  program
    .command("doctor")
    .description("Validate config and runtime prerequisites")
    .action(async () => {
      const config = await resolveRuntimeConfig();
      const result = doctor(config);

      logger.debug({ command: "doctor" }, "doctor command executed");

      if (config.output.defaultFormat === "json") {
        outputResult(
          "doctor",
          config.env,
          {
            status: "ok",
            config: {
              env: config.env,
              db: config.db,
            },
            checks: result,
          },
          "doctor ok",
          true,
        );
        return;
      }

      writeDoctorText(io, config.env);
    });

  const dbCommand = program.command("db").description("Database lifecycle commands");

  dbCommand
    .command("status")
    .description("Show current migration status")
    .action(async () => {
      const config = await resolveRuntimeConfig();
      const status = dbStatus(config);

      outputResult(
        "db.status",
        config.env,
        status,
        `db status: applied=${status.appliedCount}, pending=${status.pendingCount}`,
        config.output.defaultFormat === "json",
      );
    });

  dbCommand
    .command("migrate")
    .description("Apply pending migrations")
    .action(async () => {
      const config = await resolveRuntimeConfig();
      const result = dbMigrate(config, randomUUID());

      outputResult(
        "db.migrate",
        config.env,
        result,
        `db migrate: applied=${result.applied.length}`,
        config.output.defaultFormat === "json",
      );
    });

  dbCommand
    .command("seed")
    .description("Seed baseline data")
    .option("--fixture <name>", "optional fixture name")
    .action(async (args: { fixture?: string }) => {
      const config = await resolveRuntimeConfig();
      const result = dbSeed(config, randomUUID(), args.fixture);

      outputResult(
        "db.seed",
        config.env,
        result,
        `db seed: roles=${result.seededRoles}`,
        config.output.defaultFormat === "json",
      );
    });

  dbCommand
    .command("backup")
    .description("Create a consistent DB backup artifact")
    .requiredOption("--out <file>", "backup output file")
    .option("--force-prod", "allow dangerous operation in prod")
    .action(async (args: { out: string; forceProd?: boolean }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = await dbBackup(config, randomUUID(), args.out, {
        forceProd: Boolean(args.forceProd),
        yes: options.yes,
        token: options.token,
      });

      outputResult(
        "db.backup",
        config.env,
        result,
        `db backup: out=${result.out}`,
        config.output.defaultFormat === "json",
      );
    });

  dbCommand
    .command("restore")
    .description("Restore DB from backup artifact")
    .requiredOption("--from <file>", "backup file to restore from")
    .option("--force-prod", "allow dangerous operation in prod")
    .action(async (args: { from: string; forceProd?: boolean }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = await dbRestore(config, randomUUID(), args.from, {
        forceProd: Boolean(args.forceProd),
        yes: options.yes,
        token: options.token,
      });

      outputResult(
        "db.restore",
        config.env,
        result,
        `db restore: from=${result.from} target=${result.target}`,
        config.output.defaultFormat === "json",
      );
    });

  const authCommand = program.command("auth").description("Authentication and service tokens");
  const authTokenCommand = authCommand.command("token").description("Service token commands");

  authTokenCommand
    .command("create")
    .description("Create a service token")
    .requiredOption("--name <label>", "token label")
    .option("--ttl-days <n>", "optional token ttl in days")
    .action(async (args: { name: string; ttlDays?: string }) => {
      const config = await resolveRuntimeConfig();
      const ttlDays = args.ttlDays ? Number(args.ttlDays) : undefined;

      const result = authTokenCreate(config, randomUUID(), args.name, ttlDays);

      outputResult(
        "auth.token.create",
        config.env,
        result,
        `token created: id=${result.id} token=${result.token}`,
        config.output.defaultFormat === "json",
      );
    });

  authTokenCommand
    .command("revoke")
    .description("Revoke a service token")
    .requiredOption("--id <tokenId>", "token id")
    .action(async (args: { id: string }) => {
      const config = await resolveRuntimeConfig();
      const result = authTokenRevoke(config, randomUUID(), args.id);

      outputResult(
        "auth.token.revoke",
        config.env,
        result,
        `token revoked: id=${result.id}`,
        config.output.defaultFormat === "json",
      );
    });

  const userCommand = program.command("user").description("User management commands");

  userCommand
    .command("create")
    .description("Create a user")
    .requiredOption("--email <email>", "user email")
    .option("--status <status>", "PENDING|ACTIVE|DISABLED")
    .action(async (args: { email: string; status?: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = userCreate(config, randomUUID(), args.email, args.status, options.token);

      outputResult(
        "user.create",
        config.env,
        result,
        `user created: id=${result.id} email=${result.email} status=${result.status}`,
        config.output.defaultFormat === "json",
      );
    });

  userCommand
    .command("list")
    .description("List users")
    .option("--role <role>", "filter by role")
    .option("--status <status>", "filter by status")
    .option("--search <q>", "filter by email search")
    .action(async (args: { role?: string; status?: string; search?: string }) => {
      const config = await resolveRuntimeConfig();
      const users = userList(config, {
        role: args.role,
        status: args.status,
        search: args.search,
      });

      outputResult(
        "user.list",
        config.env,
        users,
        `users: count=${users.length}`,
        config.output.defaultFormat === "json",
      );
    });

  userCommand
    .command("show")
    .description("Show a user by id or email")
    .option("--id <id>", "user id")
    .option("--email <email>", "user email")
    .action(async (args: { id?: string; email?: string }) => {
      const config = await resolveRuntimeConfig();
      const result = userShow(config, {
        id: args.id,
        email: args.email,
      });

      outputResult(
        "user.show",
        config.env,
        result,
        `user: id=${result.id} email=${result.email} status=${result.status}`,
        config.output.defaultFormat === "json",
      );
    });

  userCommand
    .command("disable")
    .description("Disable a user")
    .requiredOption("--id <id>", "user id")
    .option("--reason <text>", "optional reason")
    .action(async (args: { id: string; reason?: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = userDisable(config, randomUUID(), args.id, options.token, args.reason);

      outputResult(
        "user.disable",
        config.env,
        result,
        `user disabled: id=${result.id}`,
        config.output.defaultFormat === "json",
      );
    });

  userCommand
    .command("enable")
    .description("Enable a user")
    .requiredOption("--id <id>", "user id")
    .action(async (args: { id: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = userEnable(config, randomUUID(), args.id, options.token);

      outputResult(
        "user.enable",
        config.env,
        result,
        `user enabled: id=${result.id}`,
        config.output.defaultFormat === "json",
      );
    });

  const roleCommand = userCommand.command("role").description("User role operations");

  roleCommand
    .command("add")
    .description("Add role to user")
    .requiredOption("--id <id>", "user id")
    .requiredOption("--role <role>", "role name")
    .action(async (args: { id: string; role: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = userRoleAdd(config, randomUUID(), args.id, args.role, options.token);

      outputResult(
        "user.role.add",
        config.env,
        result,
        `role added: user=${result.userId} role=${result.role}`,
        config.output.defaultFormat === "json",
      );
    });

  roleCommand
    .command("remove")
    .description("Remove role from user")
    .requiredOption("--id <id>", "user id")
    .requiredOption("--role <role>", "role name")
    .action(async (args: { id: string; role: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = userRoleRemove(config, randomUUID(), args.id, args.role, options.token);

      outputResult(
        "user.role.remove",
        config.env,
        result,
        `role removed: user=${result.userId} role=${result.role}`,
        config.output.defaultFormat === "json",
      );
    });

  const eventCommand = program.command("event").description("Event lifecycle commands");

  eventCommand
    .command("create")
    .description("Create an event in DRAFT status")
    .requiredOption("--slug <slug>", "event slug")
    .requiredOption("--title <title>", "event title")
    .requiredOption("--start <iso>", "start datetime ISO")
    .requiredOption("--end <iso>", "end datetime ISO")
    .requiredOption("--tz <iana>", "IANA timezone")
    .option("--capacity <n>", "optional capacity")
    .action(
      async (args: {
        slug: string;
        title: string;
        start: string;
        end: string;
        tz: string;
        capacity?: string;
      }) => {
        const config = await resolveRuntimeConfig();
        const options = normalizeOptions(program.opts<Record<string, unknown>>());
        const capacity = args.capacity === undefined ? undefined : Number(args.capacity);
        const result = eventCreate(
          config,
          randomUUID(),
          {
            slug: args.slug,
            title: args.title,
            start: args.start,
            end: args.end,
            timezone: args.tz,
            capacity,
          },
          options.token,
        );

        outputResult(
          "event.create",
          config.env,
          result,
          `event created: slug=${result.slug} status=${result.status}`,
          config.output.defaultFormat === "json",
        );
      },
    );

  eventCommand
    .command("update")
    .description("Update mutable event fields")
    .requiredOption("--slug <slug>", "event slug")
    .option("--title <title>", "new title")
    .option("--start <iso>", "new start datetime ISO")
    .option("--end <iso>", "new end datetime ISO")
    .option("--capacity <n>", "new capacity")
    .action(
      async (args: { slug: string; title?: string; start?: string; end?: string; capacity?: string }) => {
        const config = await resolveRuntimeConfig();
        const options = normalizeOptions(program.opts<Record<string, unknown>>());
        const result = eventUpdate(
          config,
          randomUUID(),
          args.slug,
          {
            title: args.title,
            start: args.start,
            end: args.end,
            capacity: args.capacity === undefined ? undefined : Number(args.capacity),
          },
          options.token,
        );

        outputResult(
          "event.update",
          config.env,
          result,
          `event updated: slug=${result.slug}`,
          config.output.defaultFormat === "json",
        );
      },
    );

  eventCommand
    .command("publish")
    .description("Publish an event")
    .requiredOption("--slug <slug>", "event slug")
    .action(async (args: { slug: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = eventPublish(config, randomUUID(), args.slug, options.token);

      outputResult(
        "event.publish",
        config.env,
        result,
        `event published: slug=${result.slug} status=${result.status}`,
        config.output.defaultFormat === "json",
      );
    });

  eventCommand
    .command("cancel")
    .description("Cancel an event")
    .requiredOption("--slug <slug>", "event slug")
    .requiredOption("--reason <text>", "cancel reason")
    .action(async (args: { slug: string; reason: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = eventCancel(config, randomUUID(), args.slug, args.reason, options.token);

      outputResult(
        "event.cancel",
        config.env,
        result,
        `event cancelled: slug=${result.slug} status=${result.status}`,
        config.output.defaultFormat === "json",
      );
    });

  eventCommand
    .command("list")
    .description("List events")
    .option("--status <status>", "filter by status")
    .option("--from <iso>", "start lower bound")
    .option("--to <iso>", "start upper bound")
    .action(async (args: { status?: string; from?: string; to?: string }) => {
      const config = await resolveRuntimeConfig();
      const result = eventList(config, {
        status: args.status,
        from: args.from,
        to: args.to,
      });

      outputResult(
        "event.list",
        config.env,
        result,
        `events: count=${result.length}`,
        config.output.defaultFormat === "json",
      );
    });

  eventCommand
    .command("export")
    .description("Export registrations for an event")
    .requiredOption("--slug <slug>", "event slug")
    .requiredOption("--format <format>", "csv|json")
    .requiredOption("--out <file>", "output file path")
    .option("--include-email", "include user email in export")
    .action(async (args: { slug: string; format: string; out: string; includeEmail?: boolean }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const format = args.format.toLowerCase();
      if (format !== "csv" && format !== "json") {
        throw new CliError("Invalid format. Allowed: csv, json.", 2);
      }

      const result = eventExport(
        config,
        randomUUID(),
        {
          slug: args.slug,
          format,
          out: args.out,
          includeEmail: Boolean(args.includeEmail),
        },
        options.token,
      );

      outputResult(
        "event.export",
        config.env,
        result,
        `event export: slug=${result.slug} format=${result.format} count=${result.count} out=${result.out}`,
        config.output.defaultFormat === "json",
      );
    });

  const regCommand = program.command("reg").description("Event registration commands");

  regCommand
    .command("add")
    .description("Add registration for event/user")
    .requiredOption("--event <slug>", "event slug")
    .requiredOption("--user <emailOrId>", "user email or id")
    .action(async (args: { event: string; user: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = regAdd(config, randomUUID(), args.event, args.user, options.token);

      outputResult(
        "reg.add",
        config.env,
        result,
        `registration added: event=${args.event} user=${args.user} status=${result.status}`,
        config.output.defaultFormat === "json",
      );
    });

  regCommand
    .command("remove")
    .description("Cancel registration for event/user")
    .requiredOption("--event <slug>", "event slug")
    .requiredOption("--user <emailOrId>", "user email or id")
    .option("--reason <text>", "optional reason")
    .action(async (args: { event: string; user: string; reason?: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = regRemove(config, randomUUID(), args.event, args.user, options.token, args.reason);

      outputResult(
        "reg.remove",
        config.env,
        result,
        `registration cancelled: event=${args.event} user=${args.user} status=${result.status}`,
        config.output.defaultFormat === "json",
      );
    });

  regCommand
    .command("list")
    .description("List registrations for an event")
    .requiredOption("--event <slug>", "event slug")
    .option("--status <status>", "registration status filter")
    .action(async (args: { event: string; status?: string }) => {
      const config = await resolveRuntimeConfig();
      const result = regList(config, args.event, args.status);

      outputResult(
        "reg.list",
        config.env,
        result,
        `registrations: event=${args.event} count=${result.length}`,
        config.output.defaultFormat === "json",
      );
    });

  program
    .command("checkin")
    .description("Check in a registered user")
    .requiredOption("--event <slug>", "event slug")
    .requiredOption("--user <emailOrId>", "user email or id")
    .action(async (args: { event: string; user: string }) => {
      const config = await resolveRuntimeConfig();
      const options = normalizeOptions(program.opts<Record<string, unknown>>());
      const result = regCheckin(config, randomUUID(), args.event, args.user, options.token);

      outputResult(
        "registration.checkin",
        config.env,
        result,
        `checkin complete: event=${args.event} user=${args.user} status=${result.status}`,
        config.output.defaultFormat === "json",
      );
    });

  return program;
};

export const runCli = async (argv: string[], io: CliIo = defaultIo): Promise<ExitCode> => {
  const program = createProgram(io);

  if (argv.length === 0) {
    program.outputHelp();
    return 2;
  }

  try {
    await program.parseAsync(argv, { from: "user" });
    return 0;
  } catch (error) {
    const exitCode = mapErrorToExitCode(error);

    if (error instanceof CommanderError) {
      return exitCode;
    }

    if (error instanceof CliError) {
      io.writeStderr(`${error.message}\n`);
      return exitCode;
    }

    const unexpectedMessage = error instanceof Error ? error.message : "Unknown error";
    io.writeStderr(`${unexpectedMessage}\n`);
    return exitCode;
  }
};


===== FILE: src/cli/schema-guard.ts =====
import { dbStatus } from "./db";
import { preconditionError } from "./errors";
import { AppConfig } from "./types";

export const requireSchemaCurrent = (config: AppConfig): void => {
  const status = dbStatus(config);
  if (status.pendingCount > 0) {
    throw preconditionError("Migrations are pending. Run `appctl db migrate` first.");
  }
};


===== FILE: src/cli/service-token-repository.ts =====
import { openCliDb } from "./repository-helpers";
import { AppConfig } from "./types";

export const findActiveServiceTokenByHash = (
  config: AppConfig,
  tokenHash: string,
): { id: string } | undefined => {
  const db = openCliDb(config);
  try {
    return db
      .prepare("SELECT id FROM service_tokens WHERE token_hash = ? AND revoked_at IS NULL")
      .get(tokenHash) as { id: string } | undefined;
  } finally {
    db.close();
  }
};


===== FILE: src/cli/types.ts =====
export type RuntimeEnv = "local" | "staging" | "prod";

export type OutputFormat = "text" | "json";

export type ExitCode = 0 | 1 | 2 | 3 | 4 | 5 | 6;

export interface GlobalOptions {
  env?: RuntimeEnv;
  json?: boolean;
  quiet?: boolean;
  color?: boolean;
  trace?: boolean;
  dryRun?: boolean;
  yes?: boolean;
  token?: string;
}

export interface DbConfig {
  mode: "sqlite";
  file: string;
  busyTimeoutMs: number;
}

export interface SecurityConfig {
  requireTokenInStaging: boolean;
  requireTokenInProd: boolean;
  dangerousOpsRequireExplicitProd: boolean;
}

export interface AuditConfig {
  strict: boolean;
}

export interface OutputConfig {
  defaultFormat: OutputFormat;
}

export interface AppConfig {
  env: RuntimeEnv;
  db: DbConfig;
  security: SecurityConfig;
  audit: AuditConfig;
  output: OutputConfig;
}

export interface JsonEnvelope<TData = unknown> {
  ok: boolean;
  command: string;
  env: RuntimeEnv;
  data: TData;
  warnings: string[];
  errors: string[];
  request_id: string;
}

export interface CliIo {
  writeStdout(message: string): void;
  writeStderr(message: string): void;
}


===== FILE: src/cli/write-auth.ts =====
import { createHash } from "node:crypto";
import { authError } from "./errors";
import { findActiveServiceTokenByHash } from "./service-token-repository";
import { AppConfig } from "./types";

export const hashToken = (token: string): string => createHash("sha256").update(token).digest("hex");

export const requireWriteAuth = (config: AppConfig, providedToken?: string): void => {
  if (config.env === "local") {
    return;
  }

  if (!providedToken) {
    throw authError("A valid super-admin token is required for write commands in staging/prod.");
  }

  const token = findActiveServiceTokenByHash(config, hashToken(providedToken));
  if (!token) {
    throw authError("Invalid or revoked token.");
  }
};


===== FILE: src/components/problem-details.tsx =====
"use client";

import { useState } from "react";
import type { ProblemDetails } from "@/lib/hal-client";

type ProblemDetailsProps = {
  problem: ProblemDetails;
};

export function ProblemDetailsPanel({ problem }: ProblemDetailsProps) {
  const [copied, setCopied] = useState(false);

  const onCopy = async () => {
    if (!problem.request_id) {
      return;
    }

    try {
      await navigator.clipboard.writeText(problem.request_id);
      setCopied(true);
      window.setTimeout(() => setCopied(false), 1200);
    } catch {
      setCopied(false);
    }
  };

  return (
    <div className="rounded-md border p-4">
      <h2 className="text-lg font-semibold">{problem.title}</h2>
      <p className="mt-1 text-sm">Status: {problem.status}</p>
      {problem.detail ? <p className="mt-1 text-sm">{problem.detail}</p> : null}
      {Array.isArray(problem.errors) && problem.errors.length > 0 ? (
        <ul className="mt-2 list-disc pl-5 text-sm">
          {problem.errors.map((error) => (
            <li key={error}>{error}</li>
          ))}
        </ul>
      ) : null}
      {problem.request_id ? (
        <div className="mt-2 flex items-center gap-2 text-xs">
          <p>request_id: {problem.request_id}</p>
          <button
            type="button"
            onClick={() => void onCopy()}
            className="rounded border px-2 py-1"
          >
            {copied ? "Copied" : "Copy"}
          </button>
        </div>
      ) : null}
    </div>
  );
}


===== FILE: src/core/domain/errors.ts =====
export class DomainError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "DomainError";
  }
}

export class InvalidInputError extends DomainError {
  constructor(message: string) {
    super(message);
    this.name = "InvalidInputError";
  }
}

export class UserAlreadyExistsError extends DomainError {
  constructor(public readonly email: string) {
    super(`User already exists: ${email}`);
    this.name = "UserAlreadyExistsError";
  }
}

export class UserNotFoundError extends DomainError {
  constructor(public readonly identifier: string) {
    super(`User not found: ${identifier}`);
    this.name = "UserNotFoundError";
  }
}

export class EventAlreadyExistsError extends DomainError {
  constructor(public readonly slug: string) {
    super(`Event already exists: ${slug}`);
    this.name = "EventAlreadyExistsError";
  }
}

export class EventNotFoundError extends DomainError {
  constructor(public readonly slug: string) {
    super(`Event not found: ${slug}`);
    this.name = "EventNotFoundError";
  }
}

export class EventCapacityReachedError extends DomainError {
  constructor(public readonly slug: string) {
    super(`Event capacity reached: ${slug}`);
    this.name = "EventCapacityReachedError";
  }
}

export class RegistrationNotFoundError extends DomainError {
  constructor(public readonly eventSlug: string, public readonly userIdentifier: string) {
    super(`Registration not found for event=${eventSlug} user=${userIdentifier}`);
    this.name = "RegistrationNotFoundError";
  }
}

export class CancelledRegistrationCheckinError extends DomainError {
  constructor() {
    super("Cannot check in a cancelled registration.");
    this.name = "CancelledRegistrationCheckinError";
  }
}


===== FILE: src/core/infrastructure/sqlite/audit-sink.ts =====
import { openCliDb } from "../../../cli/repository-helpers";
import { appendServiceAudit } from "../../../cli/repository-helpers";
import { AppConfig } from "../../../cli/types";
import { AuditSink } from "../../ports/repositories";

export class SqliteAuditSink implements AuditSink {
  constructor(private readonly config: AppConfig) {}

  record(args: {
    action: string;
    requestId: string;
    targetType: "system" | "event" | "registration";
    metadata?: Record<string, unknown>;
  }): void {
    const db = openCliDb(this.config);
    try {
      appendServiceAudit(db, args);
    } finally {
      db.close();
    }
  }
}


===== FILE: src/core/infrastructure/sqlite/auth-queries.ts =====
import { randomUUID } from "node:crypto";
import Database from "better-sqlite3";

export interface SessionUserRow {
  id: string;
  email: string;
  status: string;
}

export interface PasswordResetRow {
  id: string;
  user_id: string;
  expires_at: string;
  used_at: string | null;
}

export interface EmailVerificationRow {
  id: string;
  user_id: string;
  expires_at: string;
  used_at: string | null;
}

export interface UserStatusRow {
  id: string;
  status: string;
}

export interface LoginCredentialRow {
  id: string;
  email: string;
  status: string;
  password_hash: string;
}

export const ensureRoleByName = (db: Database.Database, role: "USER" | "ADMIN" | "SUPER_ADMIN"): string => {
  const found = db.prepare("SELECT id FROM roles WHERE name = ?").get(role) as { id: string } | undefined;
  if (found) {
    return found.id;
  }

  const id = randomUUID();
  db.prepare("INSERT INTO roles (id, name) VALUES (?, ?)").run(id, role);
  return id;
};

export const insertUserAccount = (
  db: Database.Database,
  args: {
    id: string;
    email: string;
    status: string;
    createdAtIso: string;
    updatedAtIso: string;
  },
): void => {
  db.prepare("INSERT INTO users (id, email, status, created_at, updated_at) VALUES (?, ?, ?, ?, ?)").run(
    args.id,
    args.email,
    args.status,
    args.createdAtIso,
    args.updatedAtIso,
  );
};

export const insertApiCredential = (
  db: Database.Database,
  args: { userId: string; passwordHash: string; createdAtIso: string; updatedAtIso: string },
): void => {
  db.prepare("INSERT INTO api_credentials (user_id, password_hash, created_at, updated_at) VALUES (?, ?, ?, ?)").run(
    args.userId,
    args.passwordHash,
    args.createdAtIso,
    args.updatedAtIso,
  );
};

export const assignUserRole = (db: Database.Database, args: { userId: string; roleId: string }): void => {
  db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(args.userId, args.roleId);
};

export const insertPolicyConsent = (
  db: Database.Database,
  args: {
    id: string;
    userId: string;
    policy: string;
    acceptedAtIso: string;
    policyVersion: string;
  },
): void => {
  db.prepare(
    "INSERT INTO api_policy_consents (id, user_id, policy, accepted_at, policy_version) VALUES (?, ?, ?, ?, ?)",
  ).run(args.id, args.userId, args.policy, args.acceptedAtIso, args.policyVersion);
};

export const insertApiSession = (
  db: Database.Database,
  args: {
    id: string;
    userId: string;
    sessionTokenHash: string;
    createdAtIso: string;
    expiresAtIso: string;
    lastSeenAtIso: string;
  },
): void => {
  db.prepare(
    `
INSERT INTO api_sessions (
  id,
  user_id,
  session_token_hash,
  created_at,
  expires_at,
  last_seen_at,
  revoked_at
) VALUES (?, ?, ?, ?, ?, ?, NULL)
`,
  ).run(args.id, args.userId, args.sessionTokenHash, args.createdAtIso, args.expiresAtIso, args.lastSeenAtIso);
};

export const listUserRoleNames = (db: Database.Database, userId: string): string[] => {
  const rows = db
    .prepare(
      `
SELECT r.name
FROM roles r
JOIN user_roles ur ON ur.role_id = r.id
WHERE ur.user_id = ?
ORDER BY r.name ASC
`,
    )
    .all(userId) as { name: string }[];

  return rows.map((row) => row.name);
};

export const findActiveSessionUserByTokenHash = (
  db: Database.Database,
  args: { tokenHash: string; nowIso: string },
): SessionUserRow | undefined => {
  return db
    .prepare(
      `
SELECT u.id, u.email, u.status
FROM api_sessions s
JOIN users u ON u.id = s.user_id
WHERE s.session_token_hash = ?
  AND s.revoked_at IS NULL
  AND s.expires_at > ?
`,
    )
    .get(args.tokenHash, args.nowIso) as SessionUserRow | undefined;
};

export const revokeActiveSessionByTokenHash = (
  db: Database.Database,
  args: { tokenHash: string; revokedAtIso: string },
): number => {
  return db
    .prepare("UPDATE api_sessions SET revoked_at = ? WHERE session_token_hash = ? AND revoked_at IS NULL")
    .run(args.revokedAtIso, args.tokenHash).changes;
};

export const hasUserById = (db: Database.Database, userId: string): boolean => {
  const found = db.prepare("SELECT id FROM users WHERE id = ?").get(userId) as { id: string } | undefined;
  return Boolean(found);
};

export const applyAccountDeletion = (
  db: Database.Database,
  args: { userId: string; nowIso: string; retentionUntilIso: string; deletionId: string },
): void => {
  db.prepare("UPDATE users SET status = 'DISABLED', email = ?, updated_at = ? WHERE id = ?").run(
    `deleted+${args.userId}@deleted.local`,
    args.nowIso,
    args.userId,
  );

  db.prepare("DELETE FROM user_roles WHERE user_id = ?").run(args.userId);

  db.prepare("UPDATE api_sessions SET revoked_at = ? WHERE user_id = ? AND revoked_at IS NULL").run(
    args.nowIso,
    args.userId,
  );

  db.prepare(
    "UPDATE event_registrations SET status = 'CANCELLED' WHERE user_id = ? AND status IN ('REGISTERED', 'WAITLISTED', 'CHECKED_IN')",
  ).run(args.userId);

  db.prepare(
    "INSERT INTO api_account_deletions (id, user_id, deleted_at, retention_until) VALUES (?, ?, ?, ?)",
  ).run(args.deletionId, args.userId, args.nowIso, args.retentionUntilIso);
};

export const findUserIdByEmail = (db: Database.Database, email: string): string | undefined => {
  const row = db.prepare("SELECT id FROM users WHERE email = ?").get(email) as { id: string } | undefined;
  return row?.id;
};

export const findLoginCredentialByEmail = (
  db: Database.Database,
  email: string,
): LoginCredentialRow | undefined => {
  return db
    .prepare(
      `
SELECT u.id, u.email, u.status, ac.password_hash
FROM users u
JOIN api_credentials ac ON ac.user_id = u.id
WHERE u.email = ?
`,
    )
    .get(email) as LoginCredentialRow | undefined;
};

export const markUnusedPasswordResetsUsed = (
  db: Database.Database,
  args: { userId: string; usedAtIso: string },
): void => {
  db.prepare("UPDATE api_password_resets SET used_at = ? WHERE user_id = ? AND used_at IS NULL").run(
    args.usedAtIso,
    args.userId,
  );
};

export const insertPasswordReset = (
  db: Database.Database,
  args: {
    id: string;
    userId: string;
    tokenHash: string;
    createdAtIso: string;
    expiresAtIso: string;
  },
): void => {
  db.prepare(
    `
INSERT INTO api_password_resets (
  id,
  user_id,
  token_hash,
  created_at,
  expires_at,
  used_at
) VALUES (?, ?, ?, ?, ?, NULL)
`,
  ).run(args.id, args.userId, args.tokenHash, args.createdAtIso, args.expiresAtIso);
};

export const findPasswordResetByTokenHash = (
  db: Database.Database,
  tokenHash: string,
): PasswordResetRow | undefined => {
  return db
    .prepare(
      `
SELECT id, user_id, expires_at, used_at
FROM api_password_resets
WHERE token_hash = ?
`,
    )
    .get(tokenHash) as PasswordResetRow | undefined;
};

export const updateCredentialPasswordHash = (
  db: Database.Database,
  args: { userId: string; passwordHash: string; updatedAtIso: string },
): void => {
  db.prepare("UPDATE api_credentials SET password_hash = ?, updated_at = ? WHERE user_id = ?").run(
    args.passwordHash,
    args.updatedAtIso,
    args.userId,
  );
};

export const markPasswordResetUsedById = (
  db: Database.Database,
  args: { id: string; usedAtIso: string },
): void => {
  db.prepare("UPDATE api_password_resets SET used_at = ? WHERE id = ?").run(args.usedAtIso, args.id);
};

export const findLatestPasswordResetIdForUser = (db: Database.Database, userId: string): string | undefined => {
  const row = db
    .prepare(
      `
SELECT id
FROM api_password_resets
WHERE user_id = ?
ORDER BY created_at DESC
LIMIT 1
`,
    )
    .get(userId) as { id: string } | undefined;
  return row?.id;
};

export const findUserStatusByEmail = (db: Database.Database, email: string): UserStatusRow | undefined => {
  return db.prepare("SELECT id, status FROM users WHERE email = ?").get(email) as UserStatusRow | undefined;
};

export const markUnusedEmailVerificationsUsed = (
  db: Database.Database,
  args: { userId: string; usedAtIso: string },
): void => {
  db.prepare("UPDATE api_email_verifications SET used_at = ? WHERE user_id = ? AND used_at IS NULL").run(
    args.usedAtIso,
    args.userId,
  );
};

export const insertEmailVerification = (
  db: Database.Database,
  args: {
    id: string;
    userId: string;
    tokenHash: string;
    createdAtIso: string;
    expiresAtIso: string;
  },
): void => {
  db.prepare(
    `
INSERT INTO api_email_verifications (
  id,
  user_id,
  token_hash,
  created_at,
  expires_at,
  used_at
) VALUES (?, ?, ?, ?, ?, NULL)
`,
  ).run(args.id, args.userId, args.tokenHash, args.createdAtIso, args.expiresAtIso);
};

export const findEmailVerificationByTokenHash = (
  db: Database.Database,
  tokenHash: string,
): EmailVerificationRow | undefined => {
  return db
    .prepare(
      `
SELECT id, user_id, expires_at, used_at
FROM api_email_verifications
WHERE token_hash = ?
`,
    )
    .get(tokenHash) as EmailVerificationRow | undefined;
};

export const activateUserAndMarkEmailVerificationUsed = (
  db: Database.Database,
  args: { userId: string; verificationId: string; updatedAtIso: string },
): void => {
  db.prepare("UPDATE users SET status = 'ACTIVE', updated_at = ? WHERE id = ?").run(args.updatedAtIso, args.userId);
  db.prepare("UPDATE api_email_verifications SET used_at = ? WHERE id = ?").run(args.updatedAtIso, args.verificationId);
};


===== FILE: src/core/infrastructure/sqlite/auth-schema.ts =====
import Database from "better-sqlite3";

export const ensureAuthSchema = (db: Database.Database): void => {
  db.exec(`
CREATE TABLE IF NOT EXISTS api_credentials (
  user_id TEXT PRIMARY KEY,
  password_hash TEXT NOT NULL,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS api_sessions (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  session_token_hash TEXT NOT NULL UNIQUE,
  created_at TEXT NOT NULL,
  expires_at TEXT NOT NULL,
  last_seen_at TEXT,
  revoked_at TEXT,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS api_password_resets (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  token_hash TEXT NOT NULL UNIQUE,
  created_at TEXT NOT NULL,
  expires_at TEXT NOT NULL,
  used_at TEXT,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS api_email_verifications (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  token_hash TEXT NOT NULL UNIQUE,
  created_at TEXT NOT NULL,
  expires_at TEXT NOT NULL,
  used_at TEXT,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS api_policy_consents (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  policy TEXT NOT NULL,
  accepted_at TEXT NOT NULL,
  policy_version TEXT NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS api_account_deletions (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  deleted_at TEXT NOT NULL,
  retention_until TEXT NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);
`);
};


===== FILE: src/core/infrastructure/sqlite/read-repositories.ts =====
import { openCliDb } from "../../../cli/repository-helpers";
import { AppConfig } from "../../../cli/types";

export interface EventReadRecord {
  id: string;
  slug: string;
  title: string;
  start_at: string;
  end_at: string;
  timezone: string;
  status: "DRAFT" | "PUBLISHED" | "CANCELLED";
  capacity: number | null;
  created_by: string | null;
  created_at: string;
  updated_at: string;
}

export interface UserReadRecord {
  id: string;
  email: string;
  status: string;
  created_at: string;
  updated_at: string;
  roles: string[];
}

export interface EventRegistrationReadEvent {
  id: string;
  slug: string;
  capacity: number | null;
}

export interface EventRegistrationReadRow {
  id: string;
  event_slug: string;
  user_id: string;
  user_email: string;
  status: "REGISTERED" | "WAITLISTED" | "CANCELLED" | "CHECKED_IN";
}

export interface EventRegistrationExportRow {
  id: string;
  status: "REGISTERED" | "WAITLISTED" | "CANCELLED" | "CHECKED_IN";
  user_id: string;
  user_email: string;
}

export interface UserRegistrationHistoryReadRow {
  registration_id: string;
  event_id: string;
  event_slug: string;
  event_title: string;
  status: "REGISTERED" | "WAITLISTED" | "CANCELLED" | "CHECKED_IN";
}

export class SqliteEventReadRepository {
  constructor(private readonly config: AppConfig) {}

  list(args: {
    status?: string;
    q?: string;
    fromIso?: string;
    toIso?: string;
    limit: number;
    offset: number;
  }): EventReadRecord[] {
    const db = openCliDb(this.config);
    try {
      const clauses: string[] = [];
      const params: unknown[] = [];

      if (args.status) {
        clauses.push("status = ?");
        params.push(args.status.toUpperCase());
      }

      if (args.q) {
        clauses.push("title LIKE ?");
        params.push(`%${args.q}%`);
      }

      if (args.fromIso) {
        clauses.push("start_at >= ?");
        params.push(args.fromIso);
      }

      if (args.toIso) {
        clauses.push("start_at <= ?");
        params.push(args.toIso);
      }

      const whereClause = clauses.length > 0 ? `WHERE ${clauses.join(" AND ")}` : "";

      return db
        .prepare(
          `
SELECT *
FROM events
${whereClause}
ORDER BY start_at ASC
LIMIT ? OFFSET ?
`,
        )
        .all(...params, args.limit, args.offset) as EventReadRecord[];
    } finally {
      db.close();
    }
  }

  findBySlug(slug: string): EventReadRecord | undefined {
    const db = openCliDb(this.config);
    try {
      return db.prepare("SELECT * FROM events WHERE slug = ?").get(slug) as EventReadRecord | undefined;
    } finally {
      db.close();
    }
  }
}

export class SqliteUserReadRepository {
  constructor(private readonly config: AppConfig) {}

  private getRolesForUser(db: ReturnType<typeof openCliDb>, userId: string): string[] {
    const rows = db
      .prepare(
        `
SELECT r.name
FROM roles r
JOIN user_roles ur ON ur.role_id = r.id
WHERE ur.user_id = ?
ORDER BY r.name ASC
`,
      )
      .all(userId) as { name: string }[];
    return rows.map((row) => row.name);
  }

  list(args: { role?: string; status?: string; search?: string; limit: number; offset: number }): UserReadRecord[] {
    const db = openCliDb(this.config);
    try {
      const joins: string[] = [];
      const clauses: string[] = [];
      const params: unknown[] = [];

      if (args.role) {
        joins.push("JOIN user_roles ur ON ur.user_id = u.id", "JOIN roles r ON r.id = ur.role_id");
        clauses.push("r.name = ?");
        params.push(args.role.toUpperCase());
      }

      if (args.status) {
        clauses.push("u.status = ?");
        params.push(args.status.toUpperCase());
      }

      if (args.search) {
        clauses.push("u.email LIKE ?");
        params.push(`%${args.search}%`);
      }

      const whereClause = clauses.length > 0 ? `WHERE ${clauses.join(" AND ")}` : "";
      const query = `
SELECT DISTINCT u.id, u.email, u.status, u.created_at, u.updated_at
FROM users u
${joins.join(" ")}
${whereClause}
ORDER BY u.created_at ASC
LIMIT ? OFFSET ?
`;

      const rows = db.prepare(query).all(...params, args.limit, args.offset) as {
        id: string;
        email: string;
        status: string;
        created_at: string;
        updated_at: string;
      }[];

      return rows.map((row) => ({
        ...row,
        roles: this.getRolesForUser(db, row.id),
      }));
    } finally {
      db.close();
    }
  }

  findById(id: string): UserReadRecord | undefined {
    const db = openCliDb(this.config);
    try {
      const row = db
        .prepare("SELECT id, email, status, created_at, updated_at FROM users WHERE id = ?")
        .get(id) as
        | {
            id: string;
            email: string;
            status: string;
            created_at: string;
            updated_at: string;
          }
        | undefined;

      if (!row) {
        return undefined;
      }

      return {
        ...row,
        roles: this.getRolesForUser(db, row.id),
      };
    } finally {
      db.close();
    }
  }
}

export class SqliteRegistrationReadRepository {
  constructor(private readonly config: AppConfig) {}

  findEventBySlug(slug: string): EventRegistrationReadEvent | undefined {
    const db = openCliDb(this.config);
    try {
      return db.prepare("SELECT id, slug, capacity FROM events WHERE slug = ?").get(slug) as
        | EventRegistrationReadEvent
        | undefined;
    } finally {
      db.close();
    }
  }

  listByEvent(args: { eventId: string; status?: string }): EventRegistrationReadRow[] {
    const db = openCliDb(this.config);
    try {
      const params: unknown[] = [args.eventId];
      const clauses = ["r.event_id = ?"];

      if (args.status) {
        clauses.push("r.status = ?");
        params.push(args.status.toUpperCase());
      }

      return db
        .prepare(
          `
SELECT r.id, e.slug AS event_slug, u.id AS user_id, u.email AS user_email, r.status
FROM event_registrations r
JOIN events e ON e.id = r.event_id
JOIN users u ON u.id = r.user_id
WHERE ${clauses.join(" AND ")}
ORDER BY u.email ASC
`,
        )
        .all(...params) as EventRegistrationReadRow[];
    } finally {
      db.close();
    }
  }

  listForExport(eventId: string): EventRegistrationExportRow[] {
    const db = openCliDb(this.config);
    try {
      return db
        .prepare(
          `
SELECT r.id, r.status, u.id AS user_id, u.email AS user_email
FROM event_registrations r
JOIN users u ON u.id = r.user_id
WHERE r.event_id = ?
ORDER BY u.email ASC
`,
        )
        .all(eventId) as EventRegistrationExportRow[];
    } finally {
      db.close();
    }
  }

  listForUser(userId: string): UserRegistrationHistoryReadRow[] {
    const db = openCliDb(this.config);
    try {
      return db
        .prepare(
          `
SELECT
  r.id AS registration_id,
  e.id AS event_id,
  e.slug AS event_slug,
  e.title AS event_title,
  r.status
FROM event_registrations r
JOIN events e ON e.id = r.event_id
WHERE r.user_id = ?
ORDER BY e.start_at ASC
`,
        )
        .all(userId) as UserRegistrationHistoryReadRow[];
    } finally {
      db.close();
    }
  }
}


===== FILE: src/core/infrastructure/sqlite/repositories.ts =====
import { openCliDb } from "../../../cli/repository-helpers";
import { AppConfig } from "../../../cli/types";
import { Event, EventRepository, Registration, RegistrationRepository, User, UserRepository } from "../../ports/repositories";

export class SqliteUserRepository implements UserRepository {
  constructor(private readonly config: AppConfig) {}

  findByEmail(email: string): User | undefined {
    const db = openCliDb(this.config);
    try {
      return db.prepare("SELECT id, email, status, created_at, updated_at FROM users WHERE email = ?").get(email) as
        | User
        | undefined;
    } finally {
      db.close();
    }
  }

  findByIdentifier(identifier: string): User | undefined {
    const db = openCliDb(this.config);
    try {
      if (identifier.includes("@")) {
        return db.prepare("SELECT id, email, status, created_at, updated_at FROM users WHERE email = ?").get(identifier.toLowerCase()) as
          | User
          | undefined;
      }
      return db.prepare("SELECT id, email, status, created_at, updated_at FROM users WHERE id = ?").get(identifier) as
        | User
        | undefined;
    } finally {
      db.close();
    }
  }

  create(user: User): void {
    const db = openCliDb(this.config);
    try {
      db.prepare("INSERT INTO users (id, email, status, created_at, updated_at) VALUES (?, ?, ?, ?, ?)").run(
        user.id,
        user.email,
        user.status,
        user.created_at,
        user.updated_at,
      );
    } finally {
      db.close();
    }
  }
}

export class SqliteEventRepository implements EventRepository {
  constructor(private readonly config: AppConfig) {}

  findBySlug(slug: string): Event | undefined {
    const db = openCliDb(this.config);
    try {
      return db.prepare("SELECT * FROM events WHERE slug = ?").get(slug) as Event | undefined;
    } finally {
      db.close();
    }
  }

  create(event: Event): void {
    const db = openCliDb(this.config);
    try {
      db.prepare(
        `
INSERT INTO events (
  id, slug, title, start_at, end_at, timezone, status, capacity, created_by, created_at, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
      ).run(
        event.id,
        event.slug,
        event.title,
        event.start_at,
        event.end_at,
        event.timezone,
        event.status,
        event.capacity,
        event.created_by,
        event.created_at,
        event.updated_at,
      );
    } finally {
      db.close();
    }
  }

  update(event: Event): void {
    const db = openCliDb(this.config);
    try {
      db.prepare(
        `
UPDATE events
SET title = ?, start_at = ?, end_at = ?, timezone = ?, status = ?, capacity = ?, updated_at = ?
WHERE id = ?
`,
      ).run(
        event.title,
        event.start_at,
        event.end_at,
        event.timezone,
        event.status,
        event.capacity,
        event.updated_at,
        event.id,
      );
    } finally {
      db.close();
    }
  }

  countActiveRegistrations(eventId: string): number {
    const db = openCliDb(this.config);
    try {
      const row = db
        .prepare(
          "SELECT COUNT(*) AS count FROM event_registrations WHERE event_id = ? AND status IN ('REGISTERED','CHECKED_IN')",
        )
        .get(eventId) as { count: number };
      return row.count;
    } finally {
      db.close();
    }
  }
}

export class SqliteRegistrationRepository implements RegistrationRepository {
  constructor(private readonly config: AppConfig) {}

  findByEventAndUser(eventId: string, userId: string): Registration | undefined {
    const db = openCliDb(this.config);
    try {
      return db
        .prepare("SELECT id, event_id, user_id, status FROM event_registrations WHERE event_id = ? AND user_id = ?")
        .get(eventId, userId) as Registration | undefined;
    } finally {
      db.close();
    }
  }

  create(registration: Registration): void {
    const db = openCliDb(this.config);
    try {
      db.prepare("INSERT INTO event_registrations (id, event_id, user_id, status) VALUES (?, ?, ?, ?)").run(
        registration.id,
        registration.event_id,
        registration.user_id,
        registration.status,
      );
    } finally {
      db.close();
    }
  }

  updateStatus(id: string, status: Registration["status"]): void {
    const db = openCliDb(this.config);
    try {
      db.prepare("UPDATE event_registrations SET status = ? WHERE id = ?").run(status, id);
    } finally {
      db.close();
    }
  }
}


===== FILE: src/core/ports/repositories.ts =====
export interface User {
  id: string;
  email: string;
  status: string;
  created_at: string;
  updated_at: string;
}

export interface Event {
  id: string;
  slug: string;
  title: string;
  start_at: string;
  end_at: string;
  timezone: string;
  status: "DRAFT" | "PUBLISHED" | "CANCELLED";
  capacity: number | null;
  created_by: string | null;
  created_at: string;
  updated_at: string;
}

export interface Registration {
  id: string;
  event_id: string;
  user_id: string;
  status: "REGISTERED" | "WAITLISTED" | "CANCELLED" | "CHECKED_IN";
}

export interface UserRepository {
  findByEmail(email: string): User | undefined;
  findByIdentifier(identifier: string): User | undefined;
  create(user: User): void;
}

export interface EventRepository {
  findBySlug(slug: string): Event | undefined;
  create(event: Event): void;
  update(event: Event): void;
  countActiveRegistrations(eventId: string): number;
}

export interface RegistrationRepository {
  findByEventAndUser(eventId: string, userId: string): Registration | undefined;
  create(registration: Registration): void;
  updateStatus(id: string, status: Registration["status"]): void;
}

export interface AuditSink {
  record(args: {
    action: string;
    requestId: string;
    targetType: "system" | "event" | "registration";
    metadata?: Record<string, unknown>;
  }): void;
}


===== FILE: src/core/use-cases/__tests__/use-cases.unit.test.ts =====
import { describe, expect, it } from "vitest";
import {
  CancelledRegistrationCheckinError,
  EventAlreadyExistsError,
  UserAlreadyExistsError,
} from "../../domain/errors";
import { Event, EventRepository, Registration, RegistrationRepository, User, UserRepository } from "../../ports/repositories";
import { checkInParticipant } from "../check-in-participant";
import { cancelEvent } from "../cancel-event";
import { createEvent } from "../create-event";
import { publishEvent } from "../publish-event";
import { removeParticipant } from "../remove-participant";
import { registerParticipant } from "../register-participant";
import { registerUser } from "../register-user";
import { updateEvent } from "../update-event";

class InMemoryUserRepository implements UserRepository {
  constructor(public users: User[] = []) {}

  findByEmail(email: string): User | undefined {
    return this.users.find((user) => user.email === email);
  }

  findByIdentifier(identifier: string): User | undefined {
    if (identifier.includes("@")) {
      return this.findByEmail(identifier.toLowerCase());
    }
    return this.users.find((user) => user.id === identifier);
  }

  create(user: User): void {
    this.users.push(user);
  }
}

class InMemoryEventRepository implements EventRepository {
  constructor(
    public events: Event[] = [],
    private readonly registrations: Registration[] = [],
  ) {}

  findBySlug(slug: string): Event | undefined {
    return this.events.find((event) => event.slug === slug);
  }

  create(event: Event): void {
    this.events.push(event);
  }

  update(event: Event): void {
    const index = this.events.findIndex((existing) => existing.id === event.id);
    if (index >= 0) {
      this.events[index] = event;
    }
  }

  countActiveRegistrations(eventId: string): number {
    return this.registrations.filter(
      (registration) =>
        registration.event_id === eventId &&
        (registration.status === "REGISTERED" || registration.status === "CHECKED_IN"),
    ).length;
  }
}

class InMemoryRegistrationRepository implements RegistrationRepository {
  constructor(public registrations: Registration[] = []) {}

  findByEventAndUser(eventId: string, userId: string): Registration | undefined {
    return this.registrations.find((registration) => registration.event_id === eventId && registration.user_id === userId);
  }

  create(registration: Registration): void {
    this.registrations.push(registration);
  }

  updateStatus(id: string, status: Registration["status"]): void {
    const existing = this.registrations.find((registration) => registration.id === id);
    if (existing) {
      existing.status = status;
    }
  }
}

describe("core use cases (unit)", () => {
  it("registerUser enforces unique email", () => {
    const users = new InMemoryUserRepository([
      {
        id: "u-1",
        email: "dup@example.com",
        status: "ACTIVE",
        created_at: "2026-01-01T00:00:00.000Z",
        updated_at: "2026-01-01T00:00:00.000Z",
      },
    ]);

    expect(() =>
      registerUser(
        { email: "dup@example.com", status: "ACTIVE" },
        {
          users,
          id: () => "u-2",
          now: () => "2026-02-01T00:00:00.000Z",
        },
      ),
    ).toThrow(UserAlreadyExistsError);
  });

  it("createEvent enforces unique slug", () => {
    const events = new InMemoryEventRepository([
      {
        id: "e-1",
        slug: "spring-launch",
        title: "Spring Launch",
        start_at: "2026-04-01T14:00:00.000Z",
        end_at: "2026-04-01T15:00:00.000Z",
        timezone: "UTC",
        status: "DRAFT",
        capacity: 10,
        created_by: null,
        created_at: "2026-02-01T00:00:00.000Z",
        updated_at: "2026-02-01T00:00:00.000Z",
      },
    ]);

    expect(() =>
      createEvent(
        {
          slug: "spring-launch",
          title: "Duplicate",
          start: "2026-05-01T14:00:00Z",
          end: "2026-05-01T15:00:00Z",
          timezone: "UTC",
          capacity: 10,
        },
        {
          events,
          id: () => "e-2",
          now: () => "2026-02-01T00:00:00.000Z",
        },
      ),
    ).toThrow(EventAlreadyExistsError);
  });

  it("registerParticipant applies waitlist when capacity is full", () => {
    const registrations = new InMemoryRegistrationRepository([
      {
        id: "r-1",
        event_id: "e-1",
        user_id: "u-1",
        status: "REGISTERED",
      },
    ]);

    const users = new InMemoryUserRepository([
      {
        id: "u-1",
        email: "one@example.com",
        status: "ACTIVE",
        created_at: "2026-01-01T00:00:00.000Z",
        updated_at: "2026-01-01T00:00:00.000Z",
      },
      {
        id: "u-2",
        email: "two@example.com",
        status: "ACTIVE",
        created_at: "2026-01-01T00:00:00.000Z",
        updated_at: "2026-01-01T00:00:00.000Z",
      },
    ]);

    const events = new InMemoryEventRepository(
      [
        {
          id: "e-1",
          slug: "capacity-test",
          title: "Capacity Test",
          start_at: "2026-04-01T14:00:00.000Z",
          end_at: "2026-04-01T15:00:00.000Z",
          timezone: "UTC",
          status: "PUBLISHED",
          capacity: 1,
          created_by: null,
          created_at: "2026-01-01T00:00:00.000Z",
          updated_at: "2026-01-01T00:00:00.000Z",
        },
      ],
      registrations.registrations,
    );

    const added = registerParticipant(
      {
        eventSlug: "capacity-test",
        userIdentifier: "two@example.com",
      },
      {
        users,
        events,
        registrations,
        id: () => "r-2",
      },
    );

    expect(added.status).toBe("WAITLISTED");
  });

  it("checkInParticipant rejects cancelled registrations", () => {
    const registrations = new InMemoryRegistrationRepository([
      {
        id: "r-1",
        event_id: "e-1",
        user_id: "u-1",
        status: "CANCELLED",
      },
    ]);

    const users = new InMemoryUserRepository([
      {
        id: "u-1",
        email: "one@example.com",
        status: "ACTIVE",
        created_at: "2026-01-01T00:00:00.000Z",
        updated_at: "2026-01-01T00:00:00.000Z",
      },
    ]);

    const events = new InMemoryEventRepository([
      {
        id: "e-1",
        slug: "checkin-test",
        title: "Checkin Test",
        start_at: "2026-04-01T14:00:00.000Z",
        end_at: "2026-04-01T15:00:00.000Z",
        timezone: "UTC",
        status: "PUBLISHED",
        capacity: null,
        created_by: null,
        created_at: "2026-01-01T00:00:00.000Z",
        updated_at: "2026-01-01T00:00:00.000Z",
      },
    ]);

    expect(() =>
      checkInParticipant(
        {
          eventSlug: "checkin-test",
          userIdentifier: "one@example.com",
        },
        {
          users,
          events,
          registrations,
        },
      ),
    ).toThrow(CancelledRegistrationCheckinError);
  });

  it("updateEvent updates selected fields", () => {
    const events = new InMemoryEventRepository([
      {
        id: "e-1",
        slug: "update-me",
        title: "Before",
        start_at: "2026-04-01T14:00:00.000Z",
        end_at: "2026-04-01T15:00:00.000Z",
        timezone: "UTC",
        status: "DRAFT",
        capacity: 1,
        created_by: null,
        created_at: "2026-01-01T00:00:00.000Z",
        updated_at: "2026-01-01T00:00:00.000Z",
      },
    ]);

    const updated = updateEvent(
      {
        slug: "update-me",
        title: "After",
      },
      {
        events,
        now: () => "2026-02-01T00:00:00.000Z",
      },
    );

    expect(updated.title).toBe("After");
    expect(updated.updated_at).toBe("2026-02-01T00:00:00.000Z");
  });

  it("publishEvent is idempotent", () => {
    const events = new InMemoryEventRepository([
      {
        id: "e-1",
        slug: "publish-me",
        title: "Publish Me",
        start_at: "2026-04-01T14:00:00.000Z",
        end_at: "2026-04-01T15:00:00.000Z",
        timezone: "UTC",
        status: "PUBLISHED",
        capacity: null,
        created_by: null,
        created_at: "2026-01-01T00:00:00.000Z",
        updated_at: "2026-01-01T00:00:00.000Z",
      },
    ]);

    const result = publishEvent(
      { slug: "publish-me" },
      {
        events,
        now: () => "2026-02-01T00:00:00.000Z",
      },
    );

    expect(result.idempotent).toBe(true);
    expect(result.event.status).toBe("PUBLISHED");
  });

  it("cancelEvent marks event as cancelled", () => {
    const events = new InMemoryEventRepository([
      {
        id: "e-1",
        slug: "cancel-me",
        title: "Cancel Me",
        start_at: "2026-04-01T14:00:00.000Z",
        end_at: "2026-04-01T15:00:00.000Z",
        timezone: "UTC",
        status: "PUBLISHED",
        capacity: null,
        created_by: null,
        created_at: "2026-01-01T00:00:00.000Z",
        updated_at: "2026-01-01T00:00:00.000Z",
      },
    ]);

    const result = cancelEvent(
      { slug: "cancel-me", reason: "ops" },
      {
        events,
        now: () => "2026-02-01T00:00:00.000Z",
      },
    );

    expect(result.status).toBe("CANCELLED");
  });

  it("removeParticipant sets registration to cancelled", () => {
    const registrations = new InMemoryRegistrationRepository([
      {
        id: "r-1",
        event_id: "e-1",
        user_id: "u-1",
        status: "REGISTERED",
      },
    ]);

    const users = new InMemoryUserRepository([
      {
        id: "u-1",
        email: "one@example.com",
        status: "ACTIVE",
        created_at: "2026-01-01T00:00:00.000Z",
        updated_at: "2026-01-01T00:00:00.000Z",
      },
    ]);

    const events = new InMemoryEventRepository([
      {
        id: "e-1",
        slug: "remove-test",
        title: "Remove Test",
        start_at: "2026-04-01T14:00:00.000Z",
        end_at: "2026-04-01T15:00:00.000Z",
        timezone: "UTC",
        status: "PUBLISHED",
        capacity: null,
        created_by: null,
        created_at: "2026-01-01T00:00:00.000Z",
        updated_at: "2026-01-01T00:00:00.000Z",
      },
    ]);

    const removed = removeParticipant(
      {
        eventSlug: "remove-test",
        userIdentifier: "one@example.com",
      },
      {
        users,
        events,
        registrations,
      },
    );

    expect(removed.status).toBe("CANCELLED");
  });
});


===== FILE: src/core/use-cases/cancel-event.ts =====
import { EventNotFoundError, InvalidInputError } from "../domain/errors";
import { Event, EventRepository } from "../ports/repositories";

export const cancelEvent = (
  input: { slug: string; reason: string },
  deps: { events: EventRepository; now: () => string },
): Event => {
  const reason = input.reason.trim();
  if (!reason) {
    throw new InvalidInputError("Cancel reason is required.");
  }

  const existing = deps.events.findBySlug(input.slug);
  if (!existing) {
    throw new EventNotFoundError(input.slug);
  }

  const next: Event = {
    ...existing,
    status: "CANCELLED",
    updated_at: deps.now(),
  };

  deps.events.update(next);
  return next;
};


===== FILE: src/core/use-cases/check-in-participant.ts =====
import {
  CancelledRegistrationCheckinError,
  EventNotFoundError,
  RegistrationNotFoundError,
  UserNotFoundError,
} from "../domain/errors";
import { Registration, RegistrationRepository, UserRepository, EventRepository } from "../ports/repositories";

export const checkInParticipant = (
  input: { eventSlug: string; userIdentifier: string },
  deps: {
    events: EventRepository;
    users: UserRepository;
    registrations: RegistrationRepository;
  },
): Registration => {
  const event = deps.events.findBySlug(input.eventSlug);
  if (!event) {
    throw new EventNotFoundError(input.eventSlug);
  }

  const user = deps.users.findByIdentifier(input.userIdentifier);
  if (!user) {
    throw new UserNotFoundError(input.userIdentifier);
  }

  const existing = deps.registrations.findByEventAndUser(event.id, user.id);
  if (!existing) {
    throw new RegistrationNotFoundError(input.eventSlug, input.userIdentifier);
  }

  if (existing.status === "CANCELLED") {
    throw new CancelledRegistrationCheckinError();
  }

  if (existing.status !== "CHECKED_IN") {
    deps.registrations.updateStatus(existing.id, "CHECKED_IN");
  }

  return {
    ...existing,
    status: "CHECKED_IN",
  };
};


===== FILE: src/core/use-cases/create-event.ts =====
import { EventAlreadyExistsError, InvalidInputError } from "../domain/errors";
import { Event, EventRepository } from "../ports/repositories";

const parseIso = (value: string, field: string): string => {
  const parsed = new Date(value);
  if (Number.isNaN(parsed.getTime())) {
    throw new InvalidInputError(`Invalid ISO datetime for ${field}: ${value}`);
  }
  return parsed.toISOString();
};

const parseTimezone = (timezone: string): string => {
  try {
    Intl.DateTimeFormat(undefined, { timeZone: timezone });
    return timezone;
  } catch {
    throw new InvalidInputError(`Invalid IANA timezone: ${timezone}`);
  }
};

const parseCapacity = (value?: number): number | null => {
  if (value === undefined) {
    return null;
  }
  if (!Number.isInteger(value) || value < 0) {
    throw new InvalidInputError("Capacity must be a non-negative integer.");
  }
  return value;
};

export const createEvent = (
  input: { slug: string; title: string; start: string; end: string; timezone: string; capacity?: number; createdBy?: string | null },
  deps: {
    events: EventRepository;
    now: () => string;
    id: () => string;
  },
): Event => {
  const slug = input.slug.trim();
  const title = input.title.trim();

  if (!slug) {
    throw new InvalidInputError("Slug is required.");
  }
  if (!title) {
    throw new InvalidInputError("Title is required.");
  }

  if (deps.events.findBySlug(slug)) {
    throw new EventAlreadyExistsError(slug);
  }

  const startAt = parseIso(input.start, "start");
  const endAt = parseIso(input.end, "end");
  if (new Date(startAt).getTime() >= new Date(endAt).getTime()) {
    throw new InvalidInputError("Event start must be before end.");
  }

  const event: Event = {
    id: deps.id(),
    slug,
    title,
    start_at: startAt,
    end_at: endAt,
    timezone: parseTimezone(input.timezone),
    status: "DRAFT",
    capacity: parseCapacity(input.capacity),
    created_by: input.createdBy ?? null,
    created_at: deps.now(),
    updated_at: deps.now(),
  };

  deps.events.create(event);
  return event;
};


===== FILE: src/core/use-cases/publish-event.ts =====
import { EventNotFoundError } from "../domain/errors";
import { Event, EventRepository } from "../ports/repositories";

export const publishEvent = (
  input: { slug: string },
  deps: { events: EventRepository; now: () => string },
): { event: Event; idempotent: boolean } => {
  const existing = deps.events.findBySlug(input.slug);
  if (!existing) {
    throw new EventNotFoundError(input.slug);
  }

  if (existing.status === "PUBLISHED") {
    return { event: existing, idempotent: true };
  }

  const next: Event = {
    ...existing,
    status: "PUBLISHED",
    updated_at: deps.now(),
  };
  deps.events.update(next);
  return { event: next, idempotent: false };
};


===== FILE: src/core/use-cases/register-participant.ts =====
import { EventNotFoundError, UserNotFoundError } from "../domain/errors";
import { Event, Registration, RegistrationRepository, UserRepository, EventRepository } from "../ports/repositories";

const computeStatus = (
  event: Event,
  events: EventRepository,
): Registration["status"] => {
  if (event.capacity === null) {
    return "REGISTERED";
  }

  const activeCount = events.countActiveRegistrations(event.id);
  return activeCount >= event.capacity ? "WAITLISTED" : "REGISTERED";
};

export const registerParticipant = (
  input: { eventSlug: string; userIdentifier: string },
  deps: {
    events: EventRepository;
    users: UserRepository;
    registrations: RegistrationRepository;
    id: () => string;
  },
): Registration => {
  const event = deps.events.findBySlug(input.eventSlug);
  if (!event) {
    throw new EventNotFoundError(input.eventSlug);
  }

  const user = deps.users.findByIdentifier(input.userIdentifier);
  if (!user) {
    throw new UserNotFoundError(input.userIdentifier);
  }

  const existing = deps.registrations.findByEventAndUser(event.id, user.id);
  const nextStatus = computeStatus(event, deps.events);

  if (!existing) {
    const created: Registration = {
      id: deps.id(),
      event_id: event.id,
      user_id: user.id,
      status: nextStatus,
    };
    deps.registrations.create(created);
    return created;
  }

  if (existing.status === "CANCELLED") {
    deps.registrations.updateStatus(existing.id, nextStatus);
    return {
      ...existing,
      status: nextStatus,
    };
  }

  return existing;
};


===== FILE: src/core/use-cases/register-user.ts =====
import { InvalidInputError, UserAlreadyExistsError } from "../domain/errors";
import { User, UserRepository } from "../ports/repositories";

export const registerUser = (
  input: { email: string; status: string },
  deps: {
    users: UserRepository;
    now: () => string;
    id: () => string;
  },
): User => {
  const normalizedEmail = input.email.trim().toLowerCase();
  if (!normalizedEmail) {
    throw new InvalidInputError("Email is required.");
  }

  if (deps.users.findByEmail(normalizedEmail)) {
    throw new UserAlreadyExistsError(normalizedEmail);
  }

  const now = deps.now();
  const user: User = {
    id: deps.id(),
    email: normalizedEmail,
    status: input.status,
    created_at: now,
    updated_at: now,
  };

  deps.users.create(user);
  return user;
};


===== FILE: src/core/use-cases/remove-participant.ts =====
import { EventNotFoundError, RegistrationNotFoundError, UserNotFoundError } from "../domain/errors";
import { Registration, RegistrationRepository, UserRepository, EventRepository } from "../ports/repositories";

export const removeParticipant = (
  input: { eventSlug: string; userIdentifier: string },
  deps: {
    events: EventRepository;
    users: UserRepository;
    registrations: RegistrationRepository;
  },
): Registration => {
  const event = deps.events.findBySlug(input.eventSlug);
  if (!event) {
    throw new EventNotFoundError(input.eventSlug);
  }

  const user = deps.users.findByIdentifier(input.userIdentifier);
  if (!user) {
    throw new UserNotFoundError(input.userIdentifier);
  }

  const existing = deps.registrations.findByEventAndUser(event.id, user.id);
  if (!existing) {
    throw new RegistrationNotFoundError(input.eventSlug, input.userIdentifier);
  }

  if (existing.status !== "CANCELLED") {
    deps.registrations.updateStatus(existing.id, "CANCELLED");
  }

  return {
    ...existing,
    status: "CANCELLED",
  };
};


===== FILE: src/core/use-cases/update-event.ts =====
import { EventNotFoundError, InvalidInputError } from "../domain/errors";
import { Event, EventRepository } from "../ports/repositories";

const parseIso = (value: string, field: string): string => {
  const parsed = new Date(value);
  if (Number.isNaN(parsed.getTime())) {
    throw new InvalidInputError(`Invalid ISO datetime for ${field}: ${value}`);
  }
  return parsed.toISOString();
};

const parseCapacity = (value?: number): number | null => {
  if (value === undefined) {
    return null;
  }
  if (!Number.isInteger(value) || value < 0) {
    throw new InvalidInputError("Capacity must be a non-negative integer.");
  }
  return value;
};

export const updateEvent = (
  input: {
    slug: string;
    title?: string;
    start?: string;
    end?: string;
    capacity?: number;
  },
  deps: {
    events: EventRepository;
    now: () => string;
  },
): Event => {
  const existing = deps.events.findBySlug(input.slug);
  if (!existing) {
    throw new EventNotFoundError(input.slug);
  }

  const title = input.title?.trim() || existing.title;
  const startAt = input.start ? parseIso(input.start, "start") : existing.start_at;
  const endAt = input.end ? parseIso(input.end, "end") : existing.end_at;

  if (new Date(startAt).getTime() >= new Date(endAt).getTime()) {
    throw new InvalidInputError("Event start must be before end.");
  }

  const parsedCapacity = input.capacity === undefined ? existing.capacity : parseCapacity(input.capacity);
  const next: Event = {
    ...existing,
    title,
    start_at: startAt,
    end_at: endAt,
    capacity: parsedCapacity,
    updated_at: deps.now(),
  };

  deps.events.update(next);
  return next;
};


===== FILE: src/core/use-cases/with-audit.ts =====
import { AuditSink } from "../ports/repositories";

export const executeWithAudit = <T>(args: {
  action: string;
  requestId: string;
  targetType: "system" | "event" | "registration";
  audit: AuditSink;
  execute: () => T;
  metadata?: (result: T) => Record<string, unknown>;
}): T => {
  const result = args.execute();
  args.audit.record({
    action: args.action,
    requestId: args.requestId,
    targetType: args.targetType,
    metadata: args.metadata ? args.metadata(result) : undefined,
  });
  return result;
};


===== FILE: src/lib/__tests__/admin-events-view.test.ts =====
import { describe, expect, it } from "vitest";

import { getEventActionHrefs, toEventCreatePayload } from "../admin-events-view";

describe("admin events view helpers", () => {
  it("extracts publish/cancel links from HAL resources", () => {
    const links = getEventActionHrefs({
      _links: {
        self: { href: "/api/v1/events/test" },
        "app:publish": { href: "/api/v1/events/test/publish" },
      },
    });

    expect(links.publish).toBe("/api/v1/events/test/publish");
    expect(links.cancel).toBeNull();
  });

  it("builds create payload and parses capacity", () => {
    const payload = toEventCreatePayload({
      slug: " test-slug ",
      title: " Test Event ",
      start: "2026-07-01T10:00:00.000Z",
      end: "2026-07-01T11:00:00.000Z",
      timezone: "UTC",
      capacity: "25",
    });

    expect(payload).toEqual({
      slug: "test-slug",
      title: "Test Event",
      start: "2026-07-01T10:00:00.000Z",
      end: "2026-07-01T11:00:00.000Z",
      timezone: "UTC",
      capacity: 25,
    });
  });
});


===== FILE: src/lib/__tests__/admin-registration-view.test.ts =====
import { describe, expect, it } from "vitest";

import {
  buildExportFileName,
  buildRegistrationPayload,
  canCancel,
  canCheckIn,
} from "../admin-registration-view";

describe("admin registration ui helpers", () => {
  it("evaluates check-in/cancel action eligibility by status", () => {
    expect(canCheckIn("REGISTERED")).toBe(true);
    expect(canCheckIn("WAITLISTED")).toBe(true);
    expect(canCheckIn("CHECKED_IN")).toBe(false);
    expect(canCheckIn("CANCELLED")).toBe(false);

    expect(canCancel("REGISTERED")).toBe(true);
    expect(canCancel("WAITLISTED")).toBe(true);
    expect(canCancel("CHECKED_IN")).toBe(true);
    expect(canCancel("CANCELLED")).toBe(false);
  });

  it("builds registration payload from user identifier", () => {
    expect(buildRegistrationPayload("person@example.com")).toEqual({
      user_email: "person@example.com",
    });
    expect(buildRegistrationPayload("abc-123")).toEqual({ user_id: "abc-123" });
    expect(buildRegistrationPayload("   ")).toEqual({});
  });

  it("builds export file names", () => {
    expect(buildExportFileName("my-event", "json")).toBe("my-event-registrations.json");
    expect(buildExportFileName("my-event", "csv")).toBe("my-event-registrations.csv");
  });
});


===== FILE: src/lib/__tests__/admin-users-ui.test.ts =====
import { describe, expect, it } from "vitest";

import {
  MUTABLE_ROLES,
  buildUsersListHref,
  canAddRole,
  canRemoveRole,
} from "../admin-users-ui";

describe("admin users ui helpers", () => {
  it("builds users list href with search, role, and status filters", () => {
    const href = buildUsersListHref({
      search: "  alice@example.com  ",
      role: "ADMIN",
      status: "ACTIVE",
    });

    expect(href).toBe("/api/v1/users?search=alice%40example.com&status=ACTIVE&role=ADMIN");
  });

  it("returns base users href when filters are empty", () => {
    const href = buildUsersListHref({
      search: "   ",
      status: "",
      role: "",
    });

    expect(href).toBe("/api/v1/users");
  });

  it("supports idempotent role actions and excludes super admin mutation", () => {
    expect(MUTABLE_ROLES).toEqual(["ADMIN"]);
    expect(canAddRole(["USER"], "ADMIN")).toBe(true);
    expect(canAddRole(["USER", "ADMIN"], "ADMIN")).toBe(false);
    expect(canRemoveRole(["USER", "ADMIN"], "ADMIN")).toBe(true);
    expect(canRemoveRole(["USER"], "ADMIN")).toBe(false);
  });
});


===== FILE: src/lib/__tests__/auth-forms.test.ts =====
import { describe, expect, it } from "vitest";

import { loginSchema, registerSchema } from "../auth-forms";

describe("auth form schemas", () => {
  it("validates login input", () => {
    const valid = loginSchema.safeParse({
      email: "person@example.com",
      password: "Password123!",
    });

    const invalid = loginSchema.safeParse({
      email: "bad-email",
      password: "short",
    });

    expect(valid.success).toBe(true);
    expect(invalid.success).toBe(false);
  });

  it("validates register input and confirm password", () => {
    const valid = registerSchema.safeParse({
      email: "person@example.com",
      password: "Password123!",
      confirmPassword: "Password123!",
      termsAccepted: true,
    });

    const invalid = registerSchema.safeParse({
      email: "person@example.com",
      password: "Password123!",
      confirmPassword: "Password123",
      termsAccepted: false,
    });

    expect(valid.success).toBe(true);
    expect(invalid.success).toBe(false);
  });
});


===== FILE: src/lib/__tests__/hal-client.test.ts =====
import { beforeEach, describe, expect, it, vi } from "vitest";

import { follow, requestHal, type HalResource } from "../hal-client";

describe("hal client", () => {
  beforeEach(() => {
    vi.restoreAllMocks();
  });

  it("follows relations from HAL links", () => {
    const resource: HalResource = {
      _links: {
        self: { href: "/api/v1" },
        events: { href: "/api/v1/events" },
      },
    };

    const events = follow(resource, "events");
    expect(events?.href).toBe("/api/v1/events");
    expect(follow(resource, "missing")).toBeNull();
  });

  it("parses problem details for non-2xx responses", async () => {
    vi.spyOn(globalThis, "fetch").mockResolvedValue(
      new Response(
        JSON.stringify({
          type: "about:blank",
          title: "Unauthorized",
          status: 401,
          request_id: "req-1",
        }),
        { status: 401, headers: { "content-type": "application/problem+json" } },
      ),
    );

    const result = await requestHal<{ ok: true }>("/api/v1/me");
    expect(result.ok).toBe(false);
    if (!result.ok) {
      expect(result.problem.status).toBe(401);
      expect(result.problem.request_id).toBe("req-1");
    }
  });
});


===== FILE: src/lib/__tests__/ui-access.test.ts =====
import { describe, expect, it } from "vitest";

import { canAccessAdminFromMe } from "../ui-access";

describe("ui access", () => {
  it("allows admin when /me exposes users affordance", () => {
    const allowed = canAccessAdminFromMe({
      _links: {
        self: { href: "/api/v1/me" },
        users: { href: "/api/v1/users" },
      },
    });

    expect(allowed).toBe(true);
  });

  it("denies admin when /me lacks users affordance", () => {
    const allowed = canAccessAdminFromMe({
      _links: {
        self: { href: "/api/v1/me" },
      },
    });

    expect(allowed).toBe(false);
  });
});


===== FILE: src/lib/admin-events-view.ts =====
import type { HalResource } from "./hal-client";

export const getEventActionHrefs = (resource: HalResource) => {
  return {
    publish: resource._links["app:publish"]?.href ?? null,
    cancel: resource._links["app:cancel"]?.href ?? null,
  };
};

export const toEventCreatePayload = (input: {
  slug: string;
  title: string;
  start: string;
  end: string;
  timezone: string;
  capacity?: string;
}) => {
  const payload: Record<string, string | number> = {
    slug: input.slug.trim(),
    title: input.title.trim(),
    start: input.start.trim(),
    end: input.end.trim(),
    timezone: input.timezone.trim(),
  };

  if (input.capacity && input.capacity.trim().length > 0) {
    payload.capacity = Number(input.capacity);
  }

  return payload;
};


===== FILE: src/lib/admin-registration-view.ts =====
export type RegistrationStatus = "REGISTERED" | "WAITLISTED" | "CANCELLED" | "CHECKED_IN";

export const canCheckIn = (status: RegistrationStatus): boolean => {
  return status === "REGISTERED" || status === "WAITLISTED";
};

export const canCancel = (status: RegistrationStatus): boolean => {
  return status === "REGISTERED" || status === "WAITLISTED" || status === "CHECKED_IN";
};

export const buildRegistrationPayload = (identifier: string): { user_id?: string; user_email?: string } => {
  const value = identifier.trim();
  if (!value) {
    return {};
  }

  if (value.includes("@")) {
    return { user_email: value.toLowerCase() };
  }

  return { user_id: value };
};

export const buildExportFileName = (slug: string, format: "json" | "csv") => {
  return `${slug}-registrations.${format}`;
};


===== FILE: src/lib/admin-users-ui.ts =====
export const MUTABLE_ROLES = ["ADMIN"] as const;

type UserFilterInput = {
  search?: string;
  status?: string;
  role?: string;
};

export const buildUsersListHref = (filters: UserFilterInput) => {
  const query = new URLSearchParams();

  if (filters.search && filters.search.trim().length > 0) {
    query.set("search", filters.search.trim());
  }

  if (filters.status && filters.status.trim().length > 0) {
    query.set("status", filters.status.trim());
  }

  if (filters.role && filters.role.trim().length > 0) {
    query.set("role", filters.role.trim());
  }

  const queryString = query.toString();
  return queryString.length > 0 ? `/api/v1/users?${queryString}` : "/api/v1/users";
};

export const normalizeRoles = (roles: string[]) => {
  return roles.map((role) => role.toUpperCase());
};

export const canAddRole = (roles: string[], role: string) => {
  const current = normalizeRoles(roles);
  return !current.includes(role.toUpperCase());
};

export const canRemoveRole = (roles: string[], role: string) => {
  const current = normalizeRoles(roles);
  return current.includes(role.toUpperCase());
};


===== FILE: src/lib/api/__tests__/foundation.test.ts =====
import { describe, expect, it } from "vitest";

import { GET as getApiRoot } from "../../../app/api/v1/route";
import { GET as getApiDocs } from "../../../app/api/v1/docs/route";
import { hal, mediaTypes, problem } from "../response";

describe("API foundation response builders", () => {
  it("returns HAL payload with links and content type", async () => {
    const response = hal(
      { service: "test" },
      {
        self: { href: "/api/v1" },
      },
      { requestId: "req-hal-1" },
    );

    const body = await response.json();

    expect(response.status).toBe(200);
    expect(response.headers.get("content-type")).toContain(mediaTypes.hal);
    expect(response.headers.get("x-request-id")).toBe("req-hal-1");
    expect(body).toEqual({
      service: "test",
      _links: {
        self: { href: "/api/v1" },
      },
    });
  });

  it("returns RFC 9457 problem payload with request correlation", async () => {
    const request = new Request("http://localhost:3000/api/v1/events");
    const response = problem(
      {
        type: "https://example.com/problems/unauthorized",
        title: "Unauthorized",
        status: 401,
        detail: "Missing or invalid credentials",
      },
      request,
      { requestId: "req-problem-1" },
    );

    const body = await response.json();

    expect(response.status).toBe(401);
    expect(response.headers.get("content-type")).toContain(mediaTypes.problem);
    expect(response.headers.get("x-request-id")).toBe("req-problem-1");
    expect(body).toMatchObject({
      type: "https://example.com/problems/unauthorized",
      title: "Unauthorized",
      status: 401,
      detail: "Missing or invalid credentials",
      instance: "http://localhost:3000/api/v1/events",
      request_id: "req-problem-1",
    });
  });
});

describe("API foundation routes", () => {
  it("serves /api/v1 as HAL discoverability root", async () => {
    const response = await getApiRoot();
    const body = await response.json();

    expect(response.status).toBe(200);
    expect(response.headers.get("content-type")).toContain(mediaTypes.hal);
    expect(body._links).toMatchObject({
      self: { href: "/api/v1" },
      docs: { href: "/api/v1/docs" },
      auth_register: { href: "/api/v1/auth/register" },
      auth_login: { href: "/api/v1/auth/login" },
      me: { href: "/api/v1/me" },
      events: { href: "/api/v1/events" },
    });
  });

  it("serves /api/v1/docs as OpenAPI 3.1 JSON", async () => {
    const response = await getApiDocs();
    const body = await response.json();

    expect(response.status).toBe(200);
    expect(response.headers.get("content-type")).toContain("application/json");
    expect(body).toMatchObject({
      openapi: "3.1.0",
      info: {
        title: "LMS 219 API",
      },
    });
    expect(body.paths).toHaveProperty("/api/v1");
    expect(body.paths).toHaveProperty("/api/v1/docs");
  });
});


===== FILE: src/lib/api/audit.ts =====
import { mkdirSync } from "node:fs";
import { dirname, resolve } from "node:path";
import Database from "better-sqlite3";

import { resolveConfig } from "../../cli/config";
import { AppConfig } from "../../cli/types";

export type AuditEntry = {
  id: string;
  actor_type: string;
  actor_id: string | null;
  action: string;
  target_type: string;
  target_id: string | null;
  metadata: Record<string, unknown> | null;
  created_at: string;
  request_id: string;
};

const openDb = (config: AppConfig): Database.Database => {
  const dbPath = resolve(config.db.file);
  mkdirSync(dirname(dbPath), { recursive: true });
  const db = new Database(dbPath);
  db.pragma(`busy_timeout = ${config.db.busyTimeoutMs}`);
  db.pragma("foreign_keys = ON");
  db.pragma("journal_mode = WAL");
  return db;
};

const sensitiveKey = (key: string) => /(token|password|secret|email)/i.test(key);

const redactValue = (value: unknown): unknown => {
  if (Array.isArray(value)) {
    return value.map((item) => redactValue(item));
  }

  if (value && typeof value === "object") {
    const input = value as Record<string, unknown>;
    const output: Record<string, unknown> = {};
    for (const [key, nested] of Object.entries(input)) {
      output[key] = sensitiveKey(key) ? "[REDACTED]" : redactValue(nested);
    }
    return output;
  }

  return value;
};

const parseAndRedactMetadata = (raw: string | null): Record<string, unknown> | null => {
  if (!raw) {
    return null;
  }

  try {
    const parsed = JSON.parse(raw) as unknown;
    const redacted = redactValue(parsed);
    if (redacted && typeof redacted === "object" && !Array.isArray(redacted)) {
      return redacted as Record<string, unknown>;
    }
    return { value: redacted };
  } catch {
    return null;
  }
};

export const listAuditEntries = (filters: {
  action?: string;
  actor_id?: string;
  from?: string;
  to?: string;
  limit?: number;
  offset?: number;
}): { count: number; limit: number; offset: number; items: AuditEntry[] } => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);

  try {
    const clauses: string[] = [];
    const params: unknown[] = [];

    if (filters.action) {
      clauses.push("action = ?");
      params.push(filters.action);
    }

    if (filters.actor_id) {
      clauses.push("actor_id = ?");
      params.push(filters.actor_id);
    }

    if (filters.from) {
      clauses.push("created_at >= ?");
      params.push(filters.from);
    }

    if (filters.to) {
      clauses.push("created_at <= ?");
      params.push(filters.to);
    }

    const whereClause = clauses.length > 0 ? `WHERE ${clauses.join(" AND ")}` : "";
    const limit = Math.min(Math.max(filters.limit ?? 50, 1), 200);
    const offset = Math.max(filters.offset ?? 0, 0);

    const rows = db
      .prepare(
        `
SELECT id, actor_type, actor_id, action, target_type, target_id, metadata, created_at, request_id
FROM audit_log
${whereClause}
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`,
      )
      .all(...params, limit, offset) as Array<{
      id: string;
      actor_type: string;
      actor_id: string | null;
      action: string;
      target_type: string;
      target_id: string | null;
      metadata: string | null;
      created_at: string;
      request_id: string;
    }>;

    const items: AuditEntry[] = rows.map((row) => ({
      id: row.id,
      actor_type: row.actor_type,
      actor_id: row.actor_id,
      action: row.action,
      target_type: row.target_type,
      target_id: row.target_id,
      metadata: parseAndRedactMetadata(row.metadata),
      created_at: row.created_at,
      request_id: row.request_id,
    }));

    return {
      count: items.length,
      limit,
      offset,
      items,
    };
  } finally {
    db.close();
  }
};


===== FILE: src/lib/api/auth.ts =====
import { createHash, randomUUID } from "node:crypto";
import { hash, verify } from "@node-rs/argon2";
import Database from "better-sqlite3";

import { resolveConfig } from "../../cli/config";
import { appendAuditLog, openCliDb } from "../../cli/repository-helpers";
import {
  activateUserAndMarkEmailVerificationUsed,
  assignUserRole,
  applyAccountDeletion,
  ensureRoleByName,
  findActiveSessionUserByTokenHash,
  findEmailVerificationByTokenHash,
  findLatestPasswordResetIdForUser,
  findLoginCredentialByEmail,
  findPasswordResetByTokenHash,
  findUserIdByEmail,
  findUserStatusByEmail,
  hasUserById,
  insertApiCredential,
  insertApiSession,
  insertEmailVerification,
  insertPolicyConsent,
  insertPasswordReset,
  insertUserAccount,
  listUserRoleNames,
  markPasswordResetUsedById,
  markUnusedEmailVerificationsUsed,
  markUnusedPasswordResetsUsed,
  revokeActiveSessionByTokenHash,
  updateCredentialPasswordHash,
} from "../../core/infrastructure/sqlite/auth-queries";
import { ensureAuthSchema } from "../../core/infrastructure/sqlite/auth-schema";
import { AppConfig, RuntimeEnv } from "../../cli/types";

const SESSION_COOKIE = "lms_session";
const SESSION_DAYS = 7;

type Role = "USER" | "ADMIN" | "SUPER_ADMIN";

export interface SessionUser {
  id: string;
  email: string;
  status: string;
  roles: string[];
}

interface AuthContext {
  config: AppConfig;
  env: RuntimeEnv;
}

export class InvalidRegisterPayloadError extends Error {
  constructor() {
    super("invalid_register_payload");
    this.name = "InvalidRegisterPayloadError";
  }
}

export class InvalidTermsAcknowledgmentError extends Error {
  constructor() {
    super("invalid_terms_ack");
    this.name = "InvalidTermsAcknowledgmentError";
  }
}

export class EmailAlreadyRegisteredError extends Error {
  constructor() {
    super("email_already_registered");
    this.name = "EmailAlreadyRegisteredError";
  }
}

export class InvalidCredentialsError extends Error {
  constructor() {
    super("invalid_credentials");
    this.name = "InvalidCredentialsError";
  }
}

export class EmailUnverifiedError extends Error {
  constructor() {
    super("email_unverified");
    this.name = "EmailUnverifiedError";
  }
}

export class InvalidPasswordResetPayloadError extends Error {
  constructor() {
    super("invalid_reset_payload");
    this.name = "InvalidPasswordResetPayloadError";
  }
}

export class ResetTokenInvalidError extends Error {
  constructor() {
    super("reset_token_invalid");
    this.name = "ResetTokenInvalidError";
  }
}

export class ResetTokenUsedError extends Error {
  constructor() {
    super("reset_token_used");
    this.name = "ResetTokenUsedError";
  }
}

export class ResetTokenExpiredError extends Error {
  constructor() {
    super("reset_token_expired");
    this.name = "ResetTokenExpiredError";
  }
}

export class InvalidVerifyTokenError extends Error {
  constructor() {
    super("invalid_verify_token");
    this.name = "InvalidVerifyTokenError";
  }
}

export class VerifyTokenInvalidError extends Error {
  constructor() {
    super("verify_token_invalid");
    this.name = "VerifyTokenInvalidError";
  }
}

export class VerifyTokenUsedError extends Error {
  constructor() {
    super("verify_token_used");
    this.name = "VerifyTokenUsedError";
  }
}

export class VerifyTokenExpiredError extends Error {
  constructor() {
    super("verify_token_expired");
    this.name = "VerifyTokenExpiredError";
  }
}

export class AccountDeletionUserNotFoundError extends Error {
  constructor(public readonly userId: string) {
    super("account_deletion_user_not_found");
    this.name = "AccountDeletionUserNotFoundError";
  }
}

const appendAudit = (
  db: Database.Database,
  action: string,
  requestId: string,
  metadata?: Record<string, unknown>,
): void => {
  appendAuditLog(db, {
    actorType: "USER",
    actorId: null,
    action,
    targetType: "api",
    requestId,
    metadata,
  });
};

const hashSessionToken = (token: string): string =>
  createHash("sha256").update(token).digest("hex");

const hashPasswordResetToken = (token: string): string =>
  createHash("sha256").update(token).digest("hex");

const hashEmailVerificationToken = (token: string): string =>
  createHash("sha256").update(token).digest("hex");

const isEmailVerificationRequired = (): boolean => {
  const value = process.env.APPCTL_REQUIRE_EMAIL_VERIFICATION;
  return value === "1" || value === "true" || value === "yes";
};

export const getAuthContext = (): AuthContext => {
  const config = resolveConfig({ envVars: process.env });
  return {
    config,
    env: config.env,
  };
};

export const parseSessionTokenFromCookie = (cookieHeader: string | null): string | null => {
  if (!cookieHeader) {
    return null;
  }

  const segments = cookieHeader.split(";").map((segment) => segment.trim());
  for (const segment of segments) {
    if (segment.startsWith(`${SESSION_COOKIE}=`)) {
      return segment.substring(`${SESSION_COOKIE}=`.length);
    }
  }

  return null;
};

export const buildSessionCookie = (token: string, env: RuntimeEnv): string => {
  const parts = [
    `${SESSION_COOKIE}=${token}`,
    "Path=/",
    "HttpOnly",
    "SameSite=Lax",
    `Max-Age=${SESSION_DAYS * 24 * 60 * 60}`,
  ];

  if (env === "prod") {
    parts.push("Secure");
  }

  return parts.join("; ");
};

export const buildSessionClearCookie = (env: RuntimeEnv): string => {
  const parts = [`${SESSION_COOKIE}=`, "Path=/", "HttpOnly", "SameSite=Lax", "Max-Age=0"];
  if (env === "prod") {
    parts.push("Secure");
  }
  return parts.join("; ");
};

export const isSameOriginMutation = (request: Request): boolean => {
  const origin = request.headers.get("origin");
  if (!origin) {
    return true;
  }

  return origin === new URL(request.url).origin;
};

export const registerUser = async (
  email: string,
  password: string,
  termsAccepted = true,
  requestId: string,
): Promise<SessionUser & { verification_token?: string }> => {
  const { config } = getAuthContext();
  const db = openCliDb(config);

  try {
    ensureAuthSchema(db);

    const normalizedEmail = email.trim().toLowerCase();
    if (!normalizedEmail || !password) {
      throw new InvalidRegisterPayloadError();
    }

    if (!termsAccepted) {
      throw new InvalidTermsAcknowledgmentError();
    }

    const passwordHash = await hash(password, {
      algorithm: 2,
      memoryCost: 19456,
      timeCost: 2,
      parallelism: 1,
    });

    const id = randomUUID();
    const now = new Date().toISOString();

    const run = db.transaction(() => {
      const requireVerification = isEmailVerificationRequired();
      const accountStatus = requireVerification ? "PENDING" : "ACTIVE";
      let verificationToken: string | undefined;

      try {
        insertUserAccount(db, {
          id,
          email: normalizedEmail,
          status: accountStatus,
          createdAtIso: now,
          updatedAtIso: now,
        });
      } catch (error) {
        if (error instanceof Error && error.message.includes("UNIQUE constraint failed: users.email")) {
          throw new EmailAlreadyRegisteredError();
        }
        throw error;
      }

      insertApiCredential(db, {
        userId: id,
        passwordHash,
        createdAtIso: now,
        updatedAtIso: now,
      });

      const userRoleId = ensureRoleByName(db, "USER");
      assignUserRole(db, {
        userId: id,
        roleId: userRoleId,
      });

      appendAudit(db, "api.auth.register", requestId, {
        userId: id,
        email: normalizedEmail,
        verificationRequired: requireVerification,
      });

      insertPolicyConsent(db, {
        id: randomUUID(),
        userId: id,
        policy: "TERMS",
        acceptedAtIso: now,
        policyVersion: "2026-02-17",
      });

      insertPolicyConsent(db, {
        id: randomUUID(),
        userId: id,
        policy: "PRIVACY",
        acceptedAtIso: now,
        policyVersion: "2026-02-17",
      });

      if (requireVerification) {
        verificationToken = `verify_${randomUUID().replace(/-/g, "")}`;
        db.prepare(
          `
INSERT INTO api_email_verifications (
  id,
  user_id,
  token_hash,
  created_at,
  expires_at,
  used_at
) VALUES (?, ?, ?, ?, ?, NULL)
`,
        ).run(
          randomUUID(),
          id,
          hashEmailVerificationToken(verificationToken),
          now,
          new Date(Date.now() + 1000 * 60 * 30).toISOString(),
        );

        appendAudit(db, "api.auth.email_verification.issue", requestId, {
          userId: id,
          reason: "register",
        });
      }

      return {
        id,
        email: normalizedEmail,
        status: accountStatus,
        roles: ["USER"],
        verification_token: config.env === "local" ? verificationToken : undefined,
      };
    });

    return run();
  } finally {
    db.close();
  }
};

export const loginUser = async (
  email: string,
  password: string,
  requestId: string,
): Promise<{ sessionToken: string; user: SessionUser }> => {
  const { config } = getAuthContext();
  const db = openCliDb(config);

  try {
    ensureAuthSchema(db);

    const normalizedEmail = email.trim().toLowerCase();
    const row = findLoginCredentialByEmail(db, normalizedEmail);

    if (!row) {
      throw new InvalidCredentialsError();
    }

    const verified = await verify(row.password_hash, password);
    if (!verified) {
      throw new InvalidCredentialsError();
    }

    if (row.status === "PENDING") {
      throw new EmailUnverifiedError();
    }

    if (row.status !== "ACTIVE") {
      throw new InvalidCredentialsError();
    }

    const result = db.transaction(() => {
      const sessionToken = `sess_${randomUUID().replace(/-/g, "")}`;
      const sessionId = randomUUID();
      const now = new Date();
      const expires = new Date(now);
      expires.setDate(expires.getDate() + SESSION_DAYS);
      insertApiSession(db, {
        id: sessionId,
        userId: row.id,
        sessionTokenHash: hashSessionToken(sessionToken),
        createdAtIso: now.toISOString(),
        expiresAtIso: expires.toISOString(),
        lastSeenAtIso: now.toISOString(),
      });
      appendAudit(db, "api.auth.login", requestId, {
        userId: row.id,
        sessionId,
      });
      const roles = listUserRoleNames(db, row.id);
      return {
        session: {
          token: sessionToken,
          expiresAt: expires.toISOString(),
        },
        user: {
          id: row.id,
          email: row.email,
          status: row.status,
          roles,
        },
      };
    })();

    return {
      sessionToken: result.session.token,
      user: result.user,
    };
  } finally {
    db.close();
  }
};

export const logoutUser = (sessionToken: string, requestId: string): void => {
  const { config } = getAuthContext();
  const db = openCliDb(config);

  try {
    ensureAuthSchema(db);

    db.transaction(() => {
      revokeActiveSessionByTokenHash(db, {
        revokedAtIso: new Date().toISOString(),
        tokenHash: hashSessionToken(sessionToken),
      });

      appendAudit(db, "api.auth.logout", requestId, {
        revoked: true,
      });
    })();
  } finally {
    db.close();
  }
};

export const getUserFromSession = (sessionToken: string): SessionUser | null => {
  const { config } = getAuthContext();
  const db = openCliDb(config);

  try {
    ensureAuthSchema(db);
    const now = new Date().toISOString();

    const row = findActiveSessionUserByTokenHash(db, {
      tokenHash: hashSessionToken(sessionToken),
      nowIso: now,
    });

    if (!row || row.status !== "ACTIVE") {
      return null;
    }

    const roles = listUserRoleNames(db, row.id);
    return {
      id: row.id,
      email: row.email,
      status: row.status,
      roles,
    };
  } finally {
    db.close();
  }
};

export const getSessionUserFromRequest = (request: Request): SessionUser | null => {
  const sessionToken = parseSessionTokenFromCookie(request.headers.get("cookie"));
  if (!sessionToken) {
    return null;
  }

  return getUserFromSession(sessionToken);
};

export const deleteOwnAccount = (userId: string, requestId: string): { deleted: true } => {
  const { config } = getAuthContext();
  const db = openCliDb(config);

  try {
    ensureAuthSchema(db);

    db.transaction(() => {
      if (!hasUserById(db, userId)) {
        throw new AccountDeletionUserNotFoundError(userId);
      }

      const now = new Date();
      const nowIso = now.toISOString();
      const retentionUntil = new Date(now.getTime() + 1000 * 60 * 60 * 24 * 30).toISOString();

      applyAccountDeletion(db, {
        userId,
        nowIso,
        retentionUntilIso: retentionUntil,
        deletionId: randomUUID(),
      });

      appendAudit(db, "api.account.delete", requestId, {
        userId,
        retentionUntil,
      });
    })();

    return { deleted: true };
  } finally {
    db.close();
  }
};

export const requestPasswordReset = (email: string, requestId: string): { accepted: true; token?: string } => {
  const { config } = getAuthContext();
  const db = openCliDb(config);

  try {
    ensureAuthSchema(db);

    const normalizedEmail = email.trim().toLowerCase();
    if (!normalizedEmail) {
      throw new Error("invalid_reset_email");
    }

    const token = `reset_${randomUUID().replace(/-/g, "")}`;
    const tokenHash = hashPasswordResetToken(token);
    const now = new Date();
    const expiresAt = new Date(now.getTime() + 1000 * 60 * 30).toISOString();

    db.transaction(() => {
      const userId = findUserIdByEmail(db, normalizedEmail);

      appendAudit(db, "api.auth.password_reset.request", requestId, {
        email: normalizedEmail,
        found: Boolean(userId),
      });

      if (!userId) {
        return;
      }

      markUnusedPasswordResetsUsed(db, {
        userId,
        usedAtIso: now.toISOString(),
      });

      insertPasswordReset(db, {
        id: randomUUID(),
        userId,
        tokenHash,
        createdAtIso: now.toISOString(),
        expiresAtIso: expiresAt,
      });
    })();

    if (config.env === "local") {
      return { accepted: true, token };
    }

    return { accepted: true };
  } finally {
    db.close();
  }
};

export const confirmPasswordReset = async (
  token: string,
  password: string,
  requestId: string,
): Promise<{ reset: true }> => {
  const { config } = getAuthContext();
  const db = openCliDb(config);

  try {
    ensureAuthSchema(db);

    const normalizedToken = token.trim();
    if (!normalizedToken || !password) {
      throw new InvalidPasswordResetPayloadError();
    }

    const now = new Date().toISOString();
    const found = findPasswordResetByTokenHash(db, hashPasswordResetToken(normalizedToken));

    if (!found) {
      throw new ResetTokenInvalidError();
    }

    if (found.used_at) {
      throw new ResetTokenUsedError();
    }

    if (found.expires_at <= now) {
      throw new ResetTokenExpiredError();
    }

    const passwordHash = await hash(password, {
      algorithm: 2,
      memoryCost: 19456,
      timeCost: 2,
      parallelism: 1,
    });

    db.transaction(() => {
      updateCredentialPasswordHash(db, {
        userId: found.user_id,
        passwordHash,
        updatedAtIso: now,
      });

      markPasswordResetUsedById(db, {
        id: found.id,
        usedAtIso: now,
      });

      appendAudit(db, "api.auth.password_reset.confirm", requestId, {
        userId: found.user_id,
      });
    })();

    return { reset: true };
  } finally {
    db.close();
  }
};

export const getLatestPasswordResetTokenForEmail = (email: string): string | null => {
  const { config } = getAuthContext();
  if (config.env !== "local") {
    return null;
  }

  const db = openCliDb(config);
  try {
    ensureAuthSchema(db);

    const userId = findUserIdByEmail(db, email.trim().toLowerCase());

    if (!userId) {
      return null;
    }

    return findLatestPasswordResetIdForUser(db, userId) ?? null;
  } finally {
    db.close();
  }
};

export const requestEmailVerification = (
  email: string,
  requestId: string,
): { accepted: true; token?: string } => {
  const { config } = getAuthContext();
  const db = openCliDb(config);

  try {
    ensureAuthSchema(db);

    const normalizedEmail = email.trim().toLowerCase();
    if (!normalizedEmail) {
      throw new Error("invalid_verify_email");
    }

    const now = new Date();
    const nowIso = now.toISOString();
    const token = `verify_${randomUUID().replace(/-/g, "")}`;

    db.transaction(() => {
      const user = findUserStatusByEmail(db, normalizedEmail);

      appendAudit(db, "api.auth.email_verification.request", requestId, {
        email: normalizedEmail,
        found: Boolean(user),
      });

      if (!user || user.status === "ACTIVE") {
        return;
      }

      markUnusedEmailVerificationsUsed(db, {
        userId: user.id,
        usedAtIso: nowIso,
      });

      insertEmailVerification(db, {
        id: randomUUID(),
        userId: user.id,
        tokenHash: hashEmailVerificationToken(token),
        createdAtIso: nowIso,
        expiresAtIso: new Date(now.getTime() + 1000 * 60 * 30).toISOString(),
      });
    })();

    if (config.env === "local") {
      return { accepted: true, token };
    }

    return { accepted: true };
  } finally {
    db.close();
  }
};

export const confirmEmailVerification = (
  token: string,
  requestId: string,
): { verified: true } => {
  const { config } = getAuthContext();
  const db = openCliDb(config);

  try {
    ensureAuthSchema(db);

    const normalizedToken = token.trim();
    if (!normalizedToken) {
      throw new InvalidVerifyTokenError();
    }

    const now = new Date().toISOString();
    const row = findEmailVerificationByTokenHash(db, hashEmailVerificationToken(normalizedToken));

    if (!row) {
      throw new VerifyTokenInvalidError();
    }

    if (row.used_at) {
      throw new VerifyTokenUsedError();
    }

    if (row.expires_at <= now) {
      throw new VerifyTokenExpiredError();
    }

    db.transaction(() => {
      activateUserAndMarkEmailVerificationUsed(db, {
        userId: row.user_id,
        verificationId: row.id,
        updatedAtIso: now,
      });

      appendAudit(db, "api.auth.email_verification.confirm", requestId, {
        userId: row.user_id,
      });
    })();

    return { verified: true };
  } finally {
    db.close();
  }
};


===== FILE: src/lib/api/events.ts =====
import { randomUUID } from "node:crypto";
import { EventAlreadyExistsError, EventNotFoundError, InvalidInputError } from "../../core/domain/errors";
import { SqliteAuditSink } from "../../core/infrastructure/sqlite/audit-sink";
import { SqliteEventReadRepository } from "../../core/infrastructure/sqlite/read-repositories";
import { SqliteEventRepository } from "../../core/infrastructure/sqlite/repositories";
import { cancelEvent as cancelEventUseCase } from "../../core/use-cases/cancel-event";
import { createEvent as createEventUseCase } from "../../core/use-cases/create-event";
import { publishEvent as publishEventUseCase } from "../../core/use-cases/publish-event";
import { updateEvent as updateEventUseCase } from "../../core/use-cases/update-event";
import { executeWithAudit } from "../../core/use-cases/with-audit";

import { resolveConfig } from "../../cli/config";

export class EventConflictAdapterError extends Error {
  constructor(public readonly slug: string) {
    super(`Event conflict: ${slug}`);
    this.name = "EventConflictAdapterError";
  }
}

export class InvalidEventPayloadAdapterError extends Error {
  constructor(public readonly reason: string) {
    super(`Invalid event payload: ${reason}`);
    this.name = "InvalidEventPayloadAdapterError";
  }
}

export class CancelReasonRequiredError extends Error {
  constructor() {
    super("Cancel reason required");
    this.name = "CancelReasonRequiredError";
  }
}

export type EventStatus = "DRAFT" | "PUBLISHED" | "CANCELLED";

export interface EventRecord {
  id: string;
  slug: string;
  title: string;
  start_at: string;
  end_at: string;
  timezone: string;
  status: EventStatus;
  capacity: number | null;
  created_by: string | null;
  created_at: string;
  updated_at: string;
}

const parseIso = (value: string, field: string): string => {
  const parsed = new Date(value);
  if (Number.isNaN(parsed.getTime())) {
    throw new Error(`invalid_${field}`);
  }
  return parsed.toISOString();
};

const baseEventLinks = (slug: string) => ({
  self: { href: `/api/v1/events/${slug}` },
  collection: { href: "/api/v1/events" },
});

export const eventLinksForState = (slug: string, status: EventStatus) => {
  const links: Record<string, { href: string }> = {
    ...baseEventLinks(slug),
  };

  if (status === "DRAFT") {
    links["app:publish"] = { href: `/api/v1/events/${slug}/publish` };
  }

  if (status === "PUBLISHED") {
    links["app:cancel"] = { href: `/api/v1/events/${slug}/cancel` };
    links["app:ics"] = { href: `/api/v1/events/${slug}/ics` };
  }

  return links;
};

export const listEvents = (filters: {
  status?: string;
  q?: string;
  from?: string;
  to?: string;
  limit?: number;
  offset?: number;
}) => {
  const config = resolveConfig({ envVars: process.env });
  const reads = new SqliteEventReadRepository(config);
  const limit = Math.min(Math.max(filters.limit ?? 25, 1), 100);
  const offset = Math.max(filters.offset ?? 0, 0);
  const rows = reads.list({
    status: filters.status,
    q: filters.q,
    fromIso: filters.from ? parseIso(filters.from, "from") : undefined,
    toIso: filters.to ? parseIso(filters.to, "to") : undefined,
    limit,
    offset,
  });

  return {
    count: rows.length,
    limit,
    offset,
    items: rows,
  };
};

export const getEventBySlug = (slug: string): EventRecord => {
  const config = resolveConfig({ envVars: process.env });
  const reads = new SqliteEventReadRepository(config);
  const found = reads.findBySlug(slug);
  if (!found) {
    throw new EventNotFoundError(slug);
  }
  return found;
};

export const createEvent = (
  args: {
    slug: string;
    title: string;
    start: string;
    end: string;
    timezone: string;
    capacity?: number;
  },
  actorId: string,
  requestId: string,
) => {
  const config = resolveConfig({ envVars: process.env });
  const events = new SqliteEventRepository(config);
  const audit = new SqliteAuditSink(config);

  try {
    return executeWithAudit({
      action: "api.event.create",
      requestId,
      targetType: "event",
      audit,
      execute: () =>
        createEventUseCase(
          {
            slug: args.slug,
            title: args.title,
            start: args.start,
            end: args.end,
            timezone: args.timezone,
            capacity: args.capacity,
            createdBy: actorId,
          },
          {
            events,
            id: () => randomUUID(),
            now: () => new Date().toISOString(),
          },
        ),
      metadata: (result) => ({
        eventId: result.id,
        slug: result.slug,
        actorId,
      }),
    });
  } catch (error) {
    if (error instanceof EventAlreadyExistsError) {
      throw new EventConflictAdapterError(args.slug);
    }
    if (error instanceof InvalidInputError) {
      throw new InvalidEventPayloadAdapterError(error.message);
    }
    throw error;
  }
};

export const updateEvent = (
  slug: string,
  changes: { title?: string; start?: string; end?: string; capacity?: number },
  actorId: string,
  requestId: string,
) => {
  const config = resolveConfig({ envVars: process.env });
  const events = new SqliteEventRepository(config);
  const audit = new SqliteAuditSink(config);

  try {
    return executeWithAudit({
      action: "api.event.update",
      requestId,
      targetType: "event",
      audit,
      execute: () =>
        updateEventUseCase(
          {
            slug,
            title: changes.title,
            start: changes.start,
            end: changes.end,
            capacity: changes.capacity,
          },
          {
            events,
            now: () => new Date().toISOString(),
          },
        ),
      metadata: () => ({ slug, actorId }),
    });
  } catch (error) {
    if (error instanceof EventNotFoundError) {
      throw error;
    }
    if (error instanceof InvalidInputError) {
      throw new InvalidEventPayloadAdapterError(error.message);
    }
    throw error;
  }
};

export const publishEvent = (slug: string, actorId: string, requestId: string) => {
  const config = resolveConfig({ envVars: process.env });
  const events = new SqliteEventRepository(config);
  const audit = new SqliteAuditSink(config);

  try {
    const result = executeWithAudit({
      action: "api.event.publish",
      requestId,
      targetType: "event",
      audit,
      execute: () =>
        publishEventUseCase(
          { slug },
          {
            events,
            now: () => new Date().toISOString(),
          },
        ),
      metadata: (out) => ({ slug, actorId, idempotent: out.idempotent }),
    });

    return result.event;
  } catch (error) {
    if (error instanceof EventNotFoundError) {
      throw error;
    }
    throw error;
  }
};

export const cancelEvent = (slug: string, reason: string, actorId: string, requestId: string) => {
  const config = resolveConfig({ envVars: process.env });
  const events = new SqliteEventRepository(config);
  const audit = new SqliteAuditSink(config);

  try {
    return executeWithAudit({
      action: "api.event.cancel",
      requestId,
      targetType: "event",
      audit,
      execute: () =>
        cancelEventUseCase(
          { slug, reason },
          {
            events,
            now: () => new Date().toISOString(),
          },
        ),
      metadata: () => ({ slug, actorId, reason: reason.trim() }),
    });
  } catch (error) {
    if (error instanceof EventNotFoundError) {
      throw error;
    }
    if (error instanceof InvalidInputError) {
      throw new CancelReasonRequiredError();
    }
    throw error;
  }
};


===== FILE: src/lib/api/invitations.ts =====
import { randomUUID, createHash } from "node:crypto";
import { mkdirSync } from "node:fs";
import { dirname, resolve } from "node:path";
import { hash } from "@node-rs/argon2";
import Database from "better-sqlite3";

import { resolveConfig } from "../../cli/config";
import type { AppConfig } from "../../cli/types";

export class InvalidEmailError extends Error {
  constructor() {
    super("invalid_email");
    this.name = "InvalidEmailError";
  }
}

export class ExistingAccountError extends Error {
  constructor() {
    super("existing_account");
    this.name = "ExistingAccountError";
  }
}

export class InvalidInvitationPayloadError extends Error {
  constructor() {
    super("invalid_payload");
    this.name = "InvalidInvitationPayloadError";
  }
}

export class InvitationNotFoundError extends Error {
  constructor() {
    super("invite_not_found");
    this.name = "InvitationNotFoundError";
  }
}

export class InvitationUsedError extends Error {
  constructor() {
    super("invite_used");
    this.name = "InvitationUsedError";
  }
}

export class InvitationExpiredError extends Error {
  constructor() {
    super("invite_expired");
    this.name = "InvitationExpiredError";
  }
}

const openDb = (config: AppConfig): Database.Database => {
  const dbPath = resolve(config.db.file);
  mkdirSync(dirname(dbPath), { recursive: true });
  const db = new Database(dbPath);
  db.pragma(`busy_timeout = ${config.db.busyTimeoutMs}`);
  db.pragma("foreign_keys = ON");
  db.pragma("journal_mode = WAL");
  return db;
};

const hashInviteToken = (token: string): string =>
  createHash("sha256").update(token).digest("hex");

const appendAudit = (
  db: Database.Database,
  action: string,
  actorId: string | null,
  requestId: string,
  metadata?: Record<string, unknown>,
): void => {
  db.prepare(
    `
INSERT INTO audit_log (
  id,
  actor_type,
  actor_id,
  action,
  target_type,
  target_id,
  metadata,
  created_at,
  request_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
  ).run(
    randomUUID(),
    "USER",
    actorId,
    action,
    "user",
    null,
    metadata ? JSON.stringify(metadata) : null,
    new Date().toISOString(),
    requestId,
  );
};

const ensureRole = (db: Database.Database, role: string): string => {
  const normalized = role.toUpperCase();
  const row = db.prepare("SELECT id FROM roles WHERE name = ?").get(normalized) as { id: string } | undefined;
  if (row) {
    return row.id;
  }

  const id = randomUUID();
  db.prepare("INSERT INTO roles (id, name) VALUES (?, ?)").run(id, normalized);
  return id;
};

const ensureInvitationTables = (db: Database.Database): void => {
  db.exec(`
CREATE TABLE IF NOT EXISTS api_credentials (
  user_id TEXT PRIMARY KEY,
  password_hash TEXT NOT NULL,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS api_admin_invitations (
  id TEXT PRIMARY KEY,
  email TEXT NOT NULL,
  role TEXT NOT NULL,
  token_hash TEXT NOT NULL UNIQUE,
  invited_by TEXT NOT NULL,
  created_at TEXT NOT NULL,
  expires_at TEXT NOT NULL,
  accepted_at TEXT,
  cancelled_at TEXT
);
`);
};

export const createAdminInvitation = (
  email: string,
  actorId: string,
  requestId: string,
): { email: string; role: "ADMIN"; token?: string } => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);

  try {
    ensureInvitationTables(db);
    const normalizedEmail = email.trim().toLowerCase();
    if (!normalizedEmail) {
      throw new InvalidEmailError();
    }

    const existingUser = db.prepare("SELECT id FROM users WHERE email = ?").get(normalizedEmail) as
      | { id: string }
      | undefined;

    if (existingUser) {
      throw new ExistingAccountError();
    }

    const now = new Date();
    const nowIso = now.toISOString();
    const token = `invite_${randomUUID().replace(/-/g, "")}`;

    db.transaction(() => {
      db.prepare(
        `
UPDATE api_admin_invitations
SET cancelled_at = ?
WHERE email = ? AND accepted_at IS NULL AND cancelled_at IS NULL
`,
      ).run(nowIso, normalizedEmail);

      db.prepare(
        `
INSERT INTO api_admin_invitations (
  id,
  email,
  role,
  token_hash,
  invited_by,
  created_at,
  expires_at,
  accepted_at,
  cancelled_at
) VALUES (?, ?, ?, ?, ?, ?, ?, NULL, NULL)
`,
      ).run(
        randomUUID(),
        normalizedEmail,
        "ADMIN",
        hashInviteToken(token),
        actorId,
        nowIso,
        new Date(now.getTime() + 1000 * 60 * 60 * 24).toISOString(),
      );

      appendAudit(db, "api.admin.invite.create", actorId, requestId, {
        email: normalizedEmail,
        role: "ADMIN",
      });
    })();

    return {
      email: normalizedEmail,
      role: "ADMIN",
      ...(config.env === "local" ? { token } : {}),
    };
  } finally {
    db.close();
  }
};

export const acceptAdminInvitation = async (
  token: string,
  password: string,
  requestId: string,
): Promise<{ id: string; email: string; role: "ADMIN" }> => {
  const config = resolveConfig({ envVars: process.env });
  const db = openDb(config);

  try {
    ensureInvitationTables(db);

    const normalizedToken = token.trim();
    if (!normalizedToken || !password) {
      throw new InvalidInvitationPayloadError();
    }

    const invite = db
      .prepare(
        `
SELECT id, email, role, expires_at, accepted_at, cancelled_at
FROM api_admin_invitations
WHERE token_hash = ?
`,
      )
      .get(hashInviteToken(normalizedToken)) as
      | {
          id: string;
          email: string;
          role: string;
          expires_at: string;
          accepted_at: string | null;
          cancelled_at: string | null;
        }
      | undefined;

    if (!invite) {
      throw new InvitationNotFoundError();
    }

    if (invite.accepted_at || invite.cancelled_at) {
      throw new InvitationUsedError();
    }

    if (invite.expires_at <= new Date().toISOString()) {
      throw new InvitationExpiredError();
    }

    const now = new Date().toISOString();

    const existingUser = db.prepare("SELECT id FROM users WHERE email = ?").get(invite.email) as
      | { id: string }
      | undefined;
    if (existingUser) {
      throw new ExistingAccountError();
    }

    const passwordHash = await hash(password, {
      algorithm: 2,
      memoryCost: 19456,
      timeCost: 2,
      parallelism: 1,
    });

    const userId = randomUUID();
    db.transaction(() => {
      db.prepare("INSERT INTO users (id, email, status, created_at, updated_at) VALUES (?, ?, ?, ?, ?)").run(
        userId,
        invite.email,
        "ACTIVE",
        now,
        now,
      );

      db.prepare(
        "INSERT INTO api_credentials (user_id, password_hash, created_at, updated_at) VALUES (?, ?, ?, ?)",
      ).run(userId, passwordHash, now, now);

      const userRole = ensureRole(db, "USER");
      const adminRole = ensureRole(db, "ADMIN");
      db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(userId, userRole);
      db.prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)").run(userId, adminRole);

      db.prepare("UPDATE api_admin_invitations SET accepted_at = ? WHERE id = ?").run(now, invite.id);

      appendAudit(db, "api.admin.invite.accept", userId, requestId, {
        email: invite.email,
        role: "ADMIN",
      });
    })();

    return {
      id: userId,
      email: invite.email,
      role: "ADMIN",
    };
  } finally {
    db.close();
  }
};


===== FILE: src/lib/api/openapi.ts =====
export const openApiDocument = {
  openapi: "3.1.0",
  info: {
    title: "LMS 219 API",
    version: "0.1.0",
    description: "API contract skeleton for Sprint 07 foundation.",
  },
  servers: [{ url: "/" }],
  paths: {
    "/api/v1": {
      get: {
        summary: "API root",
        responses: {
          "200": {
            description: "HAL root document",
          },
        },
      },
    },
    "/api/v1/docs": {
      get: {
        summary: "OpenAPI document",
        responses: {
          "200": {
            description: "OpenAPI 3.1 JSON",
          },
        },
      },
    },
  },
} as const;


===== FILE: src/lib/api/rate-limit.ts =====
type RateLimitEntry = {
  count: number;
  resetAt: number;
};

const buckets = new Map<string, RateLimitEntry>();

const nowMs = (): number => Date.now();

const getClientId = (request: Request): string => {
  const forwarded = request.headers.get("x-forwarded-for");
  if (forwarded) {
    return forwarded.split(",")[0]?.trim() || "unknown";
  }

  const realIp = request.headers.get("x-real-ip");
  if (realIp) {
    return realIp;
  }

  return "unknown";
};

export const consumeRateLimit = (
  request: Request,
  key: string,
  limit: number,
  windowMs: number,
): { allowed: boolean; retryAfterSeconds: number } => {
  const clientId = getClientId(request);
  const bucketKey = `${key}:${clientId}`;
  const current = buckets.get(bucketKey);
  const now = nowMs();

  if (!current || current.resetAt <= now) {
    buckets.set(bucketKey, {
      count: 1,
      resetAt: now + windowMs,
    });
    return { allowed: true, retryAfterSeconds: Math.ceil(windowMs / 1000) };
  }

  if (current.count >= limit) {
    return {
      allowed: false,
      retryAfterSeconds: Math.max(1, Math.ceil((current.resetAt - now) / 1000)),
    };
  }

  current.count += 1;
  buckets.set(bucketKey, current);
  return {
    allowed: true,
    retryAfterSeconds: Math.max(1, Math.ceil((current.resetAt - now) / 1000)),
  };
};

export const resetRateLimits = (): void => {
  buckets.clear();
};


===== FILE: src/lib/api/registrations.ts =====
import { randomUUID } from "node:crypto";
import {
  CancelledRegistrationCheckinError,
  EventNotFoundError,
  RegistrationNotFoundError,
  UserNotFoundError,
} from "../../core/domain/errors";
import { SqliteAuditSink } from "../../core/infrastructure/sqlite/audit-sink";
import {
  EventRegistrationExportRow,
  SqliteRegistrationReadRepository,
  UserRegistrationHistoryReadRow,
} from "../../core/infrastructure/sqlite/read-repositories";
import {
  SqliteEventRepository,
  SqliteRegistrationRepository,
  SqliteUserRepository,
} from "../../core/infrastructure/sqlite/repositories";
import { checkInParticipant } from "../../core/use-cases/check-in-participant";
import { removeParticipant } from "../../core/use-cases/remove-participant";
import { registerParticipant } from "../../core/use-cases/register-participant";
import { executeWithAudit } from "../../core/use-cases/with-audit";

import { appendAuditLog, openCliDb } from "../../cli/repository-helpers";
import { resolveConfig } from "../../cli/config";

export type RegistrationStatus = "REGISTERED" | "WAITLISTED" | "CANCELLED" | "CHECKED_IN";

export interface RegistrationRecord {
  id: string;
  event_id: string;
  user_id: string;
  status: RegistrationStatus;
}

export interface RegistrationListRow {
  id: string;
  event_slug: string;
  user_id: string;
  user_email: string;
  status: RegistrationStatus;
}

export interface UserRegistrationHistoryRow {
  registration_id: string;
  event_id: string;
  event_slug: string;
  event_title: string;
  status: RegistrationStatus;
}

export const addRegistration = (
  eventSlug: string,
  userIdentifier: string,
  actorId: string,
  requestId: string,
): RegistrationRecord => {
  const config = resolveConfig({ envVars: process.env });
  const users = new SqliteUserRepository(config);
  const events = new SqliteEventRepository(config);
  const registrations = new SqliteRegistrationRepository(config);
  const audit = new SqliteAuditSink(config);

  return executeWithAudit({
    action: "api.registration.add",
    requestId,
    targetType: "registration",
    audit,
    execute: () =>
      registerParticipant(
        {
          eventSlug,
          userIdentifier,
        },
        {
          users,
          events,
          registrations,
          id: () => randomUUID(),
        },
      ),
    metadata: (result) => ({ eventSlug, userId: result.user_id, actorId }),
  });
};

export const removeRegistration = (
  eventSlug: string,
  userIdentifier: string,
  actorId: string,
  requestId: string,
  reason?: string,
): RegistrationRecord => {
  const config = resolveConfig({ envVars: process.env });
  const users = new SqliteUserRepository(config);
  const events = new SqliteEventRepository(config);
  const registrations = new SqliteRegistrationRepository(config);
  const audit = new SqliteAuditSink(config);

  return executeWithAudit({
    action: "api.registration.cancel",
    requestId,
    targetType: "registration",
    audit,
    execute: () =>
      removeParticipant(
        {
          eventSlug,
          userIdentifier,
        },
        {
          users,
          events,
          registrations,
        },
      ),
    metadata: (result) => ({
      eventSlug,
      userId: result.user_id,
      actorId,
      reason: reason ?? null,
    }),
  });
};

export const listRegistrations = (eventSlug: string, status?: string): RegistrationListRow[] => {
  const config = resolveConfig({ envVars: process.env });
  const reads = new SqliteRegistrationReadRepository(config);
  const event = reads.findEventBySlug(eventSlug);
  if (!event) {
    throw new EventNotFoundError(eventSlug);
  }
  return reads.listByEvent({ eventId: event.id, status }) as RegistrationListRow[];
};

export const checkinRegistration = (
  eventSlug: string,
  userIdentifier: string,
  actorId: string,
  requestId: string,
): RegistrationRecord => {
  const config = resolveConfig({ envVars: process.env });
  const users = new SqliteUserRepository(config);
  const events = new SqliteEventRepository(config);
  const registrations = new SqliteRegistrationRepository(config);
  const audit = new SqliteAuditSink(config);

  return executeWithAudit({
    action: "api.registration.checkin",
    requestId,
    targetType: "registration",
    audit,
    execute: () =>
      checkInParticipant(
        {
          eventSlug,
          userIdentifier,
        },
        {
          users,
          events,
          registrations,
        },
      ),
    metadata: (result) => ({ eventSlug, userId: result.user_id, actorId }),
  });
};

export const exportEventData = (args: {
  slug: string;
  format: "csv" | "json";
  includeEmail: boolean;
  actorId: string;
  requestId: string;
}) => {
  const config = resolveConfig({ envVars: process.env });
  const reads = new SqliteRegistrationReadRepository(config);
  const event = reads.findEventBySlug(args.slug);
  if (!event) {
    throw new EventNotFoundError(args.slug);
  }

  const rows = reads.listForExport(event.id) as EventRegistrationExportRow[];
  const db = openCliDb(config);
  try {
    const serializable = rows.map((row) =>
      args.includeEmail
        ? {
            id: row.id,
            status: row.status,
            user_id: row.user_id,
            user_email: row.user_email,
          }
        : {
            id: row.id,
            status: row.status,
            user_id: row.user_id,
          },
    );

    appendAuditLog(db, {
      actorType: "USER",
      actorId: args.actorId,
      action: "api.event.export",
      targetType: "registration",
      requestId: args.requestId,
      metadata: {
        slug: args.slug,
        format: args.format,
        includeEmail: args.includeEmail,
        count: rows.length,
      },
    });

    if (args.format === "json") {
      return {
        format: "json" as const,
        body: JSON.stringify(serializable, null, 2),
      };
    }

    const headers = args.includeEmail ? ["id", "status", "user_id", "user_email"] : ["id", "status", "user_id"];
    const bodyRows = serializable
      .map((row) => headers.map((header) => JSON.stringify((row as Record<string, string>)[header] ?? "")).join(","))
      .join("\n");
    const csv = `${headers.join(",")}\n${bodyRows}${bodyRows ? "\n" : ""}`;

    return {
      format: "csv" as const,
      body: csv,
    };
  } finally {
    db.close();
  }
};

export const listRegistrationsForUser = (userId: string): UserRegistrationHistoryRow[] => {
  const config = resolveConfig({ envVars: process.env });
  const reads = new SqliteRegistrationReadRepository(config);
  return reads.listForUser(userId) as UserRegistrationHistoryReadRow[];
};


===== FILE: src/lib/api/response.ts =====
type HalLinks = Record<string, { href: string; [key: string]: unknown }>;

type HalOptions = {
  status?: number;
  requestId?: string;
  headers?: HeadersInit;
};

type ProblemInput = {
  type: string;
  title: string;
  status: number;
  detail?: string;
  instance?: string;
  [key: string]: unknown;
};

type ProblemOptions = {
  requestId?: string;
  headers?: HeadersInit;
};

const HAL_CONTENT_TYPE = "application/hal+json";
const PROBLEM_CONTENT_TYPE = "application/problem+json";

const createRequestId = () => {
  if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
    return crypto.randomUUID();
  }

  return `${Date.now()}-${Math.random().toString(16).slice(2)}`;
};

const withCommonHeaders = (
  requestId: string,
  contentType: string,
  headers?: HeadersInit,
) => {
  const merged = new Headers(headers);
  merged.set("content-type", contentType);
  merged.set("x-request-id", requestId);
  return merged;
};

export const hal = (
  payload: Record<string, unknown>,
  links: HalLinks,
  options: HalOptions = {},
) => {
  const requestId = options.requestId ?? createRequestId();
  return Response.json(
    {
      ...payload,
      _links: links,
    },
    {
      status: options.status ?? 200,
      headers: withCommonHeaders(requestId, HAL_CONTENT_TYPE, options.headers),
    },
  );
};

export const problem = (
  issue: ProblemInput,
  request?: Request,
  options: ProblemOptions = {},
) => {
  const requestId = options.requestId ?? createRequestId();
  return Response.json(
    {
      ...issue,
      instance: issue.instance ?? request?.url,
      request_id: requestId,
    },
    {
      status: issue.status,
      headers: withCommonHeaders(
        requestId,
        PROBLEM_CONTENT_TYPE,
        options.headers,
      ),
    },
  );
};

export const mediaTypes = {
  hal: HAL_CONTENT_TYPE,
  problem: PROBLEM_CONTENT_TYPE,
} as const;


===== FILE: src/lib/api/users.ts =====
import { randomUUID } from "node:crypto";
import Database from "better-sqlite3";
import { SqliteUserReadRepository } from "../../core/infrastructure/sqlite/read-repositories";

import { resolveConfig } from "../../cli/config";
import { appendAuditLog, openCliDb } from "../../cli/repository-helpers";

export class UserNotFoundError extends Error {
  constructor(public readonly userId: string) {
    super(`User not found: ${userId}`);
    this.name = "UserNotFoundError";
  }
}

export class InvalidUserStatusError extends Error {
  constructor(public readonly status: string) {
    super(`Invalid user status: ${status}`);
    this.name = "InvalidUserStatusError";
  }
}

export class SuperAdminRoleForbiddenError extends Error {
  constructor() {
    super("SUPER_ADMIN role changes are CLI-only");
    this.name = "SuperAdminRoleForbiddenError";
  }
}

const appendAudit = (
  db: Database.Database,
  action: string,
  actorId: string,
  requestId: string,
  metadata?: Record<string, unknown>,
): void => {
  appendAuditLog(db, {
    actorType: "USER",
    actorId,
    action,
    targetType: "user",
    requestId,
    metadata,
  });
};

const getRolesForUser = (db: Database.Database, userId: string): string[] => {
  const rows = db
    .prepare(
      `
SELECT r.name
FROM roles r
JOIN user_roles ur ON ur.role_id = r.id
WHERE ur.user_id = ?
ORDER BY r.name ASC
`,
    )
    .all(userId) as { name: string }[];
  return rows.map((row) => row.name);
};

const ensureUserExists = (db: Database.Database, userId: string): void => {
  const found = db.prepare("SELECT id FROM users WHERE id = ?").get(userId) as
    | { id: string }
    | undefined;
  if (!found) {
    throw new UserNotFoundError(userId);
  }
};

const ensureRoleExists = (db: Database.Database, role: string): string => {
  const normalizedRole = role.toUpperCase();
  const found = db.prepare("SELECT id FROM roles WHERE name = ?").get(normalizedRole) as
    | { id: string }
    | undefined;

  if (found) {
    return found.id;
  }

  const id = randomUUID();
  db.prepare("INSERT INTO roles (id, name) VALUES (?, ?)").run(id, normalizedRole);
  return id;
};

const toUserResponse = (
  db: Database.Database,
  row: { id: string; email: string; status: string; created_at: string; updated_at: string },
) => ({
  ...row,
  roles: getRolesForUser(db, row.id),
});

export const listUsers = (filters: {
  role?: string;
  status?: string;
  search?: string;
  limit?: number;
  offset?: number;
}) => {
  const config = resolveConfig({ envVars: process.env });
  const reads = new SqliteUserReadRepository(config);
  const limit = Math.min(Math.max(filters.limit ?? 25, 1), 100);
  const offset = Math.max(filters.offset ?? 0, 0);
  const rows = reads.list({
    role: filters.role,
    status: filters.status,
    search: filters.search,
    limit,
    offset,
  });

  return {
    count: rows.length,
    items: rows,
    limit,
    offset,
  };
};

export const getUserById = (id: string) => {
  const config = resolveConfig({ envVars: process.env });
  const reads = new SqliteUserReadRepository(config);
  const found = reads.findById(id);
  if (!found) {
    throw new UserNotFoundError(id);
  }
  return found;
};

export const updateUserStatus = (
  id: string,
  status: string,
  actorId: string,
  requestId: string,
) => {
  const normalizedStatus = status.toUpperCase();
  if (!["ACTIVE", "DISABLED", "PENDING"].includes(normalizedStatus)) {
    throw new InvalidUserStatusError(status);
  }

  const config = resolveConfig({ envVars: process.env });
  const db = openCliDb(config);

  try {
    const now = new Date().toISOString();
    const result = db.transaction(() => {
      const change = db
        .prepare("UPDATE users SET status = ?, updated_at = ? WHERE id = ?")
        .run(normalizedStatus, now, id);

      if (change.changes === 0) {
        throw new UserNotFoundError(id);
      }

      appendAudit(db, "api.user.update", actorId, requestId, {
        userId: id,
        status: normalizedStatus,
      });

      const row = db
        .prepare("SELECT id, email, status, created_at, updated_at FROM users WHERE id = ?")
        .get(id) as {
        id: string;
        email: string;
        status: string;
        created_at: string;
        updated_at: string;
      };

      return toUserResponse(db, row);
    })();

    return result;
  } finally {
    db.close();
  }
};

export const addUserRole = (id: string, role: string, actorId: string, requestId: string) => {
  const normalizedRole = role.toUpperCase();
  if (normalizedRole === "SUPER_ADMIN") {
    throw new SuperAdminRoleForbiddenError();
  }

  const config = resolveConfig({ envVars: process.env });
  const db = openCliDb(config);
  try {
    const result = db.transaction(() => {
      ensureUserExists(db, id);
      const roleId = ensureRoleExists(db, normalizedRole);
      const change = db
        .prepare("INSERT OR IGNORE INTO user_roles (user_id, role_id) VALUES (?, ?)")
        .run(id, roleId);

      appendAudit(db, "api.user.role.add", actorId, requestId, {
        userId: id,
        role: normalizedRole,
        changed: change.changes > 0,
      });

      return {
        changed: change.changes > 0,
        role: normalizedRole,
      };
    })();

    return result;
  } finally {
    db.close();
  }
};

export const removeUserRole = (id: string, role: string, actorId: string, requestId: string) => {
  const normalizedRole = role.toUpperCase();
  if (normalizedRole === "SUPER_ADMIN") {
    throw new SuperAdminRoleForbiddenError();
  }

  const config = resolveConfig({ envVars: process.env });
  const db = openCliDb(config);
  try {
    const result = db.transaction(() => {
      ensureUserExists(db, id);

      const roleRow = db.prepare("SELECT id FROM roles WHERE name = ?").get(normalizedRole) as
        | { id: string }
        | undefined;

      const change = roleRow
        ? db
            .prepare("DELETE FROM user_roles WHERE user_id = ? AND role_id = ?")
            .run(id, roleRow.id)
        : { changes: 0 };

      appendAudit(db, "api.user.role.remove", actorId, requestId, {
        userId: id,
        role: normalizedRole,
        changed: change.changes > 0,
      });

      return {
        changed: change.changes > 0,
        role: normalizedRole,
      };
    })();

    return result;
  } finally {
    db.close();
  }
};


===== FILE: src/lib/auth-forms.ts =====
import { z } from "zod";

export const loginSchema = z.object({
  email: z.string().email("Enter a valid email address."),
  password: z.string().min(8, "Password must be at least 8 characters."),
});

export const registerSchema = z
  .object({
    email: z.string().email("Enter a valid email address."),
    password: z.string().min(8, "Password must be at least 8 characters."),
    confirmPassword: z.string().min(8, "Confirm your password."),
    termsAccepted: z.boolean().refine((value) => value, {
      message: "You must accept Terms and Privacy.",
    }),
  })
  .refine((value) => value.password === value.confirmPassword, {
    path: ["confirmPassword"],
    message: "Passwords do not match.",
  });

export type LoginFormValues = z.infer<typeof loginSchema>;
export type RegisterFormValues = z.infer<typeof registerSchema>;


===== FILE: src/lib/hal-client.ts =====
export interface HalLink {
  href: string;
  [key: string]: unknown;
}

export interface HalResource {
  _links: Record<string, HalLink>;
  [key: string]: unknown;
}

export interface ProblemDetails {
  type: string;
  title: string;
  status: number;
  detail?: string;
  instance?: string;
  request_id?: string;
  errors?: string[];
  [key: string]: unknown;
}

export type HalResult<T> =
  | { ok: true; data: T }
  | { ok: false; problem: ProblemDetails };

const acceptHeader = "application/hal+json, application/problem+json, application/json";

const isProblem = (value: unknown): value is ProblemDetails => {
  return (
    typeof value === "object" &&
    value !== null &&
    "title" in value &&
    "status" in value &&
    typeof (value as { title: unknown }).title === "string" &&
    typeof (value as { status: unknown }).status === "number"
  );
};

export const follow = (resource: HalResource, rel: string): HalLink | null => {
  return resource._links[rel] ?? null;
};

const safeJson = async (response: Response): Promise<unknown> => {
  try {
    return await response.json();
  } catch {
    return null;
  }
};

export const requestHal = async <T>(
  href: string,
  init?: RequestInit,
): Promise<HalResult<T>> => {
  const response = await fetch(href, {
    ...init,
    credentials: "include",
    headers: {
      accept: acceptHeader,
      ...(init?.headers ?? {}),
    },
  });

  const body = await safeJson(response);

  if (!response.ok) {
    if (isProblem(body)) {
      return { ok: false, problem: body };
    }

    return {
      ok: false,
      problem: {
        type: "about:blank",
        title: "Request Failed",
        status: response.status,
        detail: "Request failed and no problem details were returned.",
      },
    };
  }

  return {
    ok: true,
    data: body as T,
  };
};

export const getRoot = async (): Promise<HalResult<HalResource>> => {
  return requestHal<HalResource>("/api/v1");
};


===== FILE: src/lib/ui-access.ts =====
import { follow, HalResource } from "./hal-client";

export const canAccessAdminFromMe = (resource: HalResource): boolean => {
  return follow(resource, "users") !== null;
};

export const adminAccessProblem = {
  type: "https://lms-219.dev/problems/forbidden",
  title: "Forbidden",
  status: 403,
  detail: "Admin access requires users management affordance from /api/v1/me.",
} as const;


===== FILE: tmp/signoff-s5.json =====
[
  {
    "id": "50638f9a-473b-467c-9a46-5da306999d83",
    "status": "CANCELLED",
    "user_id": "7bb8db07-76c0-4bb0-9675-2bea8c7135bc"
  },
  {
    "id": "277cd4db-fbda-416c-b870-4e1d43257b24",
    "status": "WAITLISTED",
    "user_id": "5de7148d-9c30-48bb-ba27-140084fa9e82"
  }
]


===== FILE: tmp/spring-launch.json =====
[
  {
    "id": "d52b106c-adff-4bb0-8528-1b9859e7ced9",
    "status": "CHECKED_IN",
    "user_id": "c16bbd06-403d-428a-84ec-529f0208d370"
  }
]


===== FILE: tmp/sprint5-manual.json =====
[
  {
    "id": "24b7f682-d026-4414-869d-2079c4f55cca",
    "status": "CHECKED_IN",
    "user_id": "412bda30-7cbf-4d89-b3d8-706fc6381fab"
  }
]


===== FILE: tsconfig.json =====
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}


===== FILE: vitest.config.ts =====
import { configDefaults, defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    exclude: [...configDefaults.exclude, "e2e/**"],
  },
});


